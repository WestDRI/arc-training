---
title: Web scraping with R
author: Marie-Hélène Burle
execute:
  cache: false
---

:::{.def}

The internet is a trove of information. A lot of it is publicly available and thus suitable for use in research. Extracting that information and putting it in an organized format for analysis can, however, be extremely tedious. Web scraping tools allow to automate parts of that process and R is a popular language for the task.

In this workshop, we will guide you through a simple example using the package [rvest](https://rvest.tidyverse.org/).

:::

:::{.callout-accordion collapse="true"}

## ***Running R***

For this workshop, we will use our temporary RStudio server. To access it:

1.  Go to the website given during the workshop,
2.  Sign in using your username and password given during the workshop (you can ignore the OTP entry),
3.  Choose the following `Server Options`:

    - Time: `1.5` hours
    - Number of cores: `1`
    - Memory: `3600` MB
    - User interface: `JupyterLab`

<!-- ![](img/jupyter_options.png){fig-alt="noshadow"} -->

4.  In JupyterLab, click on the RStudio button (big blue symbol with a white R in it).

:::{.note}

Our RStudio server already has the two packages that we will be using installed ([rvest](https://cran.r-project.org/web/packages/rvest/index.html) and [tibble](https://cran.r-project.org/web/packages/tibble/index.html)). If you want to run the code on your machine, you need to install them with `install.packages()` first.

:::

:::

## HTML and CSS



## Web scrapping



## Example

### Goal

We will use [a website](https://trace.tennessee.edu/utk_graddiss/index.html) from the [University of Tennessee](https://www.utk.edu/) containing a database of PhD theses from that university.

Our goal is to scrape data from this site to produce a dataframe with the date, major, and principal investigator (PI) for each dissertation.

:::{.note}

We will only do this for the first page which contains the links for the 100 most recent theses. If you really wanted to gather all the data, you would have to do this for all pages.

:::

### Package

We will use the package [rvest](https://cran.r-project.org/web/packages/rvest/index.html), part of the [tidyverse](https://www.tidyverse.org/)—a modern set of R packages.

Let's load it:

```{r}
library(rvest)
```

### Read in HTML data

As mentioned above, our site is the [database of PhD dissertations of the University of Tennessee](https://trace.tennessee.edu/utk_graddiss/index.html).

Let's create a character vector with the url:

```{r}
url <- "https://trace.tennessee.edu/utk_graddiss/index.html"
```

First, we read in the html data from that page:

```{r}
html <- read_html(url)
```

Let's have a look at the raw data:

```{r}
html
```

### Extracting relevant data

#### Method

To find the relevant CSS element, you can use a web inspector or, even easier, the [SelectorGadget](https://selectorgadget.com/)—a JavaScript bookmarklet built by [Andrew Cantino](https://andrewcantino.com/).

#### Extracting a single link

First, let's try to extract a single link:

```{r}
test <- html %>% html_element(".article-listing")
test
```

```

The link is in there, but we need to do more extracting.

str(test)
```{r}
```


a_test <- test %>% html_element("a")
a_test
```{r}
```

Much better, but we now need to extract the `href` attribute:


a_test %>% html_attrs()
```{r}
```


```{r}
link_test <- a_test %>% html_attr("href")
link_test
```


```{r}
str(link_test)
```


#### Getting data from our test link

`link_test` is a character vector representing a URL. We know how to deal with this!

First, as we did earlier with the database site, we need to read in the html data:

```{r}
html_test <- read_html(link_test)
html_test
```

Now, we want to extract the publication date. Let's use the [SelectorGadget](https://selectorgadget.com/) again.

We need the element `#publication_date p`. Let's extract it:

```{r}
date <- html_test %>% html_element("#publication_date p") %>% html_text2()
date
```

We also want the major for this thesis. The [SelectorGadget](https://selectorgadget.com/) allows us to find that this time, it is the `#department p` element that we need. Let's extract it:

```{r}
major <- html_test %>% html_element("#department p") %>% html_text2()
major
```

And for the PI, we need the `#advisor1 p` element:

```{r}
pi <- html_test %>% html_element("#advisor1 p") %>% html_text2()
pi
```

```{r}
cbind(date, major, pi)
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Try using the [SelectorGadget](https://selectorgadget.com/) to identify the element necessary to extract the abstract of this dissertation.

Now, write the code to extract it.

:::

#### Extracting all links

Instead of using `html_element()`, this time we will use `html_elements()` which extracts *all* matching elements (instead of just the first one):

```{r}
dat <- html %>% html_elements(".article-listing")
dat
```

str(dat)
```

```{r}
```

We now have a list of lists.

As we did for a single link, we want to extract all the links to have a list of links.

Before running for loops, it is important to initialize empty loops. It is much more efficient than growing the result at each iteration.

So let's initialize an empty list:

```{r}
list_links <- vector("list", length(dat))
```

Let's have a look at one element of our list (the second one for instance):

```{r}
list_links[[2]]
```

We now have an empty list of the appropriate size. We can run our loop:

```{r}
for (i in seq_along(dat)) {
  list_links[[i]] <- dat[[i]] %>%
    html_element("a") %>%
    html_attr("href")
}
```

Let's print again the second element of our list to make sure all looks good:

```{r}
list_links[[2]]
```

We have a character vector with one link. That's great! `list_links` is a list of links (in the form of character vectors) as we wanted.

#### Getting the data from the list of links

We will now extract the data (date, major, and PI) for all links in our list.

Again, before running a for loop, we need to allocate memory first by creating an empty container:

```{r}
list_data <- vector("list", length(list_links))
```

And here is our big loop to get the data from our list of links:

```{r}
for (i in seq_along(list_links)) {
  html <- read_html(list_links[[i]])
  date <- html %>%
    html_element("#publication_date p") %>%
    html_text2()
  major <- html %>%
    html_element("#department p") %>%
    html_text2()
  pi <- html %>%
    html_element("#advisor1 p") %>%
    html_text2()
  list_data[[i]] <- cbind(date, major, pi)
}
```

Let's make sure all looks good by printing the second element of `list_data`:

```{r}
list_data[[2]]
```

All looking good, so let's turn this big list into a tibble:

```{r}
result <- do.call(rbind.data.frame, list_data) %>%
  tibble::as_tibble()
```

:::{.note}

The notation `tibble::as_tibble()` means that we are using the function `as_tibble()` from the package [tibble](https://tibble.tidyverse.org/). A tibble is the [tidyverse](https://www.tidyverse.org/) version of a dataframe. One advantage is that it will only print the first 10 rows by default instead of printing the whole dataframe.

:::

Here is our result:

```{r}
result
```

We can rename the headers:

```{r}
names(result) <- c("Date", "Major", "PI")
```

This is what our final result looks like:

```{r}
result
```
