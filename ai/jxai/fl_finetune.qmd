---
title: Fine-tuning the model
aliases:
  - /ai/jx/fl_training
author:
  - Marie-Hélène Burle
  - Code adapted from JAX's [Implement ViT from scratch](https://docs.jaxstack.ai/en/latest/JAX_Vision_transformer.html)
---

:::{.def}

We talked about how Flax handles state, about loading data, and about model architecture. It is now time to talk about training.

Training models is the crux of deep learning. This is the part that requires a lot of time and resources (and money if you use commercial cloud services). This is also where issues with convergence, underfitting or overfitting, and vanishing or exploding gradients can come in.

Consequently, this is where optimizations and JAX's performance tricks (e.g. JIT compilation) matter the most. This is also where understanding of deep learning theory is important.

In this section, we will point to strategies and resources to navigate training. We will also see how to use the Alliance clusters to train your models.

:::

## Context

```{dot}
//| echo: false
//| fig-width: 700px

digraph {

bgcolor="transparent"
node [fontname="Inconsolata, sans-serif", color=gray55, fontsize="18pt"]
edge [color=gray55]

load [label="Load data", shape=plaintext, group=g1, fontcolor=gray55]
proc [label="Process data", shape=plaintext, group=g1, fontcolor=gray55]
nn [label="Define architecture", shape=plaintext, group=g1, fontcolor=gray55]
pretr [label="Pre-trained model", shape=plaintext, group=g1, fontcolor=gray55]
opt [label="Hyperparameters", shape=plaintext, group=g1, fontcolor=gray55]
train [label="Train", shape=plaintext, group=g1]
cp [label="Checkpoint", shape=plaintext, group=g1, fontcolor=gray55]

pt [label=torchdata, fontcolor=gray55, color=gray55]
tfds [label=tfds, group=g2, fontcolor=gray55, color=gray55]
dt [label=datasets, fontcolor=gray55, color=gray55]

gr [label=grain, fontcolor=gray55, color=gray55]
tv [label=torchvision, fontcolor=gray55, color=gray55]

tr [label=transformers, fontcolor=gray55, color=gray55]

fl1 [label=flax, group=g2, fontcolor=gray55, color=gray55]
fl2 [label=flax, group=g2, fontcolor="#00695C", color="#00695C"]

oa [label=optax, group=g2, fontcolor=gray55, color=gray55]

jx [label="JAX", fontcolor="#9D22B2", color="#9D22B2"]

ob [label=orbax, group=g2, fontcolor=gray55, color=gray55]

{rank=same; gr load tv tr}
gr -> load -> tv -> tr [style=invis]

{rank=same; fl1 proc pretr}
fl1 -> proc -> pretr [style=invis]

{rank=same; jx fl2 opt}
fl1 -> proc -> pretr [style=invis]

{pt tfds dt} -> load [color=gray55]
{gr tv} -> proc [color=gray55]
fl1 -> nn [color=gray55]
pretr -> nn [dir=none]
tr -> pretr [color=gray55]
oa -> opt [color=gray55]
jx -> fl2 [color="#9D22B2"]
fl2 -> train [color="#00695C"]
ob -> cp [color=gray55]

load -> proc -> nn -> opt -> train -> cp [dir=none]

}
```

:::{.callout-note collapse="true"}

## Minimal necessary code from previous sections

```{python}
from datasets import load_dataset
import numpy as np
from torchvision.transforms import v2 as T
import grain.python as grain

train_size = 5 * 750
val_size = 5 * 250

train_dataset = load_dataset("food101",
                             split=f"train[:{train_size}]")

val_dataset = load_dataset("food101",
                           split=f"validation[:{val_size}]")

labels_mapping = {}
index = 0
for i in range(0, len(val_dataset), 250):
    label = val_dataset[i]["label"]
    if label not in labels_mapping:
        labels_mapping[label] = index
        index += 1

inv_labels_mapping = {v: k for k, v in labels_mapping.items()}

img_size = 224

def to_np_array(pil_image):
  return np.asarray(pil_image.convert("RGB"))

def normalize(image):
    # Image preprocessing matches the one of pretrained ViT
    mean = np.array([0.5, 0.5, 0.5], dtype=np.float32)
    std = np.array([0.5, 0.5, 0.5], dtype=np.float32)
    image = image.astype(np.float32) / 255.0
    return (image - mean) / std

tv_train_transforms = T.Compose([
    T.RandomResizedCrop((img_size, img_size), scale=(0.7, 1.0)),
    T.RandomHorizontalFlip(),
    T.ColorJitter(0.2, 0.2, 0.2),
    T.Lambda(to_np_array),
    T.Lambda(normalize),
])

tv_test_transforms = T.Compose([
    T.Resize((img_size, img_size)),
    T.Lambda(to_np_array),
    T.Lambda(normalize),
])

def get_transform(fn):
    def wrapper(batch):
        batch["image"] = [
            fn(pil_image) for pil_image in batch["image"]
        ]
        # map label index between 0 - 19
        batch["label"] = [
            labels_mapping[label] for label in batch["label"]
        ]
        return batch
    return wrapper

train_transforms = get_transform(tv_train_transforms)
val_transforms = get_transform(tv_test_transforms)

train_dataset = train_dataset.with_transform(train_transforms)
val_dataset = val_dataset.with_transform(val_transforms)

seed = 12
train_batch_size = 32
val_batch_size = 2 * train_batch_size

train_sampler = grain.IndexSampler(
    len(train_dataset),
    shuffle=True,
    seed=seed,
    shard_options=grain.NoSharding(),
    num_epochs=1,
)

val_sampler = grain.IndexSampler(
    len(val_dataset),
    shuffle=False,
    seed=seed,
    shard_options=grain.NoSharding(),
    num_epochs=1,
)

train_loader = grain.DataLoader(
    data_source=train_dataset,
    sampler=train_sampler,
    worker_count=4,
    worker_buffer_size=2,
    operations=[
        grain.Batch(train_batch_size, drop_remainder=True),
    ]
)

val_loader = grain.DataLoader(
    data_source=val_dataset,
    sampler=val_sampler,
    worker_count=4,
    worker_buffer_size=2,
    operations=[
        grain.Batch(val_batch_size),
    ]
)
```

:::

## Cluster setup

First, let's start an interactive job:

```{.bash}
salloc --time=30 --mem-per-cpu=3500M
```

Nowadays, IPython (Interactive Python) is known as the kernel used by Jupyter when running Python. Before the existence of Jupyter however, this kernel was created as a better command shell than the default Python shell. For interactive Python sessions in the command line, it is nicer and faster than plain Python with no downside. So we will use it for this course:

```{.bash}
module load ipython-kernel/3.11
```

Now, let's activate the virtual python environment:

```{.bash}
source /project/60055/env/bin/activate
```

Finally, we can launch IPython:

```{.bash}
ipython
```

Then let's rerun our model architecture and initialization of the pytree of model parameters from last course:

```{.python}
import jax
import jax.numpy as jnp
from flax import linen as nn


class CNN(nn.Module):
    @nn.compact
    def __call__(self, x):
        x = nn.Conv(features=32, kernel_size=(3, 3))(x)
        x = nn.relu(x)
        x = nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2))
        x = nn.Conv(features=64, kernel_size=(3, 3))(x)
        x = nn.relu(x)
        x = nn.avg_pool(x, window_shape=(2, 2), strides=(2, 2))
        x = x.reshape((x.shape[0], -1))
        x = nn.Dense(features=256)(x)
        x = nn.relu(x)
        x = nn.Dense(features=10)(x)
        x = nn.log_softmax(x)
        return x


cnn = CNN()


def get_initial_params(key):
    init_shape = jnp.ones((1, 28, 28, 1))
    initial_params = cnn.init(key, init_shape)
    return initial_params


key = jax.random.key(0)
key, model_key = jax.random.split(key)

params = get_initial_params(model_key)
```

## Fundamental functioning

### Calculate predictions

We can create some random inputs:

```{.python}
key, x_key = jax.random.split(key)

x = jax.random.normal(x_key, (1, 28, 28, 1))
```

The predictions of our model based on these inputs are obtained by:

```{.python}
y = cnn.apply(params, x)
print(y)
```

### Update parameters

[Optax](https://optax.readthedocs.io/en/latest/index.html)—another library built on JAX—is a full toolkit for gradient processing and optimization. It contains all the classic optimizers and loss functions and makes it easy to create your own optimizers and optimizer schedulers. Flax initially used its own optimizers but has now fully adopted use of Optax.

Here is the most basic case:

```{.python}
import optax

learning_rate = 1e-1
optimiser = optax.sgd(learning_rate)
print(optimiser)
```

The optimizer is a gradient transformation. It is a tuple of an `init` and an `update` methods. Those are pure functions following the model of JAX and Flax. This means that they are stateless and that a state needs to be initialized and passed as input, exactly as we saw for Flax models.

Let's initialize the optimizer state:

```{.python}
optimiser_state = optimiser.init(params)
```

The update method returns a gradient transformation (that we can later apply to the gradients) and an updated optimizer state.

The gradients are calculated by passing a loss function to `jax.grad` and passing the parameters, the inputs, and the predictions to this transformed function (the derivative):

```{.python}
grads = jax.grad(<some-loss-function>)(params, x, y)
```

The loss function can be built from [a large array of Optax loss methods](https://optax.readthedocs.io/en/latest/api/losses.html).

Here is how to use `optimizer.update`:

```{.python}
updates, optimiser_state = optimiser.update(grads, optimiser_state, params)
```

## Key regularizations

[Flax makes it easy to apply classic regularizations and optimization techniques](https://flax.readthedocs.io/en/latest/guides/training_techniques/index.html).

[Batch normalization](https://d2l.ai/chapter_convolutional-modern/batch-norm.html) improves convergence speed and has been a classic regularization technique since [the publication of Sergey Ioffe and Christian Szegedy's key paper in 2015](https://arxiv.org/abs/1502.03167). [You can use it by adding a `flax.linen.BatchNorm` layer to your model](https://flax.readthedocs.io/en/latest/guides/training_techniques/batch_norm.html).

Similarly, [dropout techniques](https://d2l.ai/chapter_multilayer-perceptrons/dropout.html#sec-dropout) are implemented [with a `flax.linen.Dropout` layer](https://flax.readthedocs.io/en/latest/guides/training_techniques/dropout.html).

## Getting started

The best way to get started building your own model is to go over [the examples](https://flax.readthedocs.io/en/latest/examples/index.html) provided as template by Flax. They all follow the same format, making it easy to clone and modify them. You can even modify them directly in Google Colab for some of them, making experimentation easy without having to install anything.

:::{.note}

Note however that things are not as simple as the documentation makes it to appear and some of the examples will not run for various reasons (dependency problem, error in code, etc.)

:::

[Let's check this structure and look at a few models](https://github.com/google/flax/tree/main/examples).

Then let's run the [ogbg-molpcba example](https://github.com/google/flax/tree/main/examples/ogbg_molpcba) together in Google Colab to have access to a free GPU.

## Running Flax examples in the Alliance clusters

Instead of running these examples in Google Colab, you might want to run them on the Alliance clusters, particularly as you start developing your own model (rather than just run examples to learn techniques).

First, you need to get the model you are interested in to the cluster.

There are many ways you could go about it, but one option is to download the directory of that particular model to your machine as a zip file using [one of several sites making this easy](https://download-directory.github.io/).

For the ogbg-molpcba example, you paste the link "https://github.com/google/flax/tree/main/examples/ogbg_molpcba" in the site.

You can then copy it to the cluster with:

```{.bash}
scp <path-to-zip-file-on-your-machine> <user-name>@<hostname>:
```

It will look something like this (make sure to rename the zip file to remove the spaces or to quote the path):

```{.bash}
scp examples-ogbg_molpcba.zip userxx@xxx.c3.ca:
```

Then you could [run it using JupyterLab](https://docs.alliancecan.ca/wiki/Advanced_Jupyter_configuration), but a more efficient method is to use `sbatch`.

Create a script:

```{.bash filename="<your_job>.sh"}
#!/bin/bash
#SBATCH --account=def-<your_account>
#SBATCH --time=xxx
#SBATCH --mem-per-cpu=xxx
#SBATCH --cpus-per-task=xxx
#SBATCH --job-name="<your_job>"

# Setup
module load python/3.11.5
source ~/env/bin/activate
python -m pip install --upgrade pip --no-index
python -m pip install -r requirements.txt --no-index

# Run example
python main.py --workdir=./ogbg_molpcba --config=configs/default.py
```

And run the script:

```{.bash}
sbatch <your_job>.sh
```
