---
title: Data preprocessing
author: Marie-Hélène Burle
---

:::{.def}

In this section, we look at the images and create new ones that we save to disk as a preprocessing step.

:::

## Load the metadata DataFrame

```{.python}
base_dir = '<path-of-the-nabirds-dir>'
```

:::{.notenoit}

To be replaced by actual path: in our training cluster, the `base_dir` is at `/project/def-sponsor00/nabirds`:

```{.python}
base_dir = '/project/def-sponsor00/nabirds'
```

:::

```{python}
#| echo: false

base_dir = 'nabirds'
```

Let's read our Parquet file back in:

```{python}
import polars as pl

metadata = pl.read_parquet('metadata.parquet')
```

## Read in images

To read in the images, there are many options, including:

- [PIL.Image.open](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.open) from [Pillow](https://github.com/python-pillow/Pillow),
- `cv2.imread` from [OpenCV](https://github.com/opencv/opencv),
- [skimage.io.imread](https://scikit-image.org/docs/stable/api/skimage.io.html#skimage.io.imread) from [scikit-image](https://github.com/scikit-image/scikit-image).

Here, we are using `imageio.imread` from [imageio](https://github.com/imageio/imageio) which is an excellent option because it automatically creates a NumPy ndarrays, choosing a dtype based on the image, and it is faster than other options ([scikit-image](https://github.com/scikit-image/scikit-image) actually uses it now instead of their own implementation).

## Dataset class

```{python}
import os
import imageio.v3 as iio

class NABirdsDataset:
    """NABirds dataset class."""
    def __init__(self, metadata_file, data_dir):
        self.metadata_file = metadata_file
        self.data_dir = data_dir
    def __len__(self):
        return len(self.metadata_file)
    def __getitem__(self, idx):
        path = os.path.join(
            self.data_dir,
            self.metadata_file.get_column('path')[idx]
        )
        img = iio.imread(path)
        species = self.metadata_file.get_column('species')[idx].replace('_', ' ')
        subcategory = self.metadata_file.get_column('subcategory')[idx]
        if subcategory is not None:
            subcategory = subcategory.replace('_', ' ')
        photographer = self.metadata_file.get_column('photographer')[idx].replace('_', ' ')
        bbx = self.metadata_file.get_column('bb_x')[idx]
        bby = self.metadata_file.get_column('bb_y')[idx]
        bbw = self.metadata_file.get_column('bb_width')[idx]
        bbh = self.metadata_file.get_column('bb_height')[idx]
        element = {
            'img': img,
            'species': species,
            'subcategory': subcategory,
            'photographer': photographer,
            'bbx' : bbx,
            'bby' : bby,
            'bbw' : bbw,
            'bbh' : bbh
        }
        return element
```

:::{.callout-tip collapse="true"}

## Equivalent using PyTorch

PyTorch provides [`torch.utils.data.Dataset`](https://docs.pytorch.org/docs/stable/data.html#torch.utils.data.Dataset), an abstract class representing a dataset. You need to write a subclass of `torch.utils.data.Dataset` (let's call it `NABirdsDataset`) so that it inherits from `torch.utils.data.Dataset`, but with characteristics matching our own dataset.

A PyTorch custom Dataset class must implement three methods:

- `__init__`: initializes a new instance (object) of the class,
- `__len__`: returns the number of elements in the new dataset class, and
- `__getitem__`: loads and returns an element from the dataset at a given index `idx`:

```{.python}
from torch.utils.data import Dataset

class NABirdsDatasetPyTorch(Dataset):
    """NABirds dataset class."""
    def __init__(self, metadata_file, data_dir, transform=None):
        self.metadata_file = metadata_file
        self.data_dir = data_dir
        self.transform = transform
    def __len__(self):
        return len(self.metadata_file)
    def __getitem__(self, idx):
        path = os.path.join(
            self.data_dir,
            self.metadata_file.get_column('path')[idx]
        )
        img = iio.imread(path)
        species = self.metadata_file.get_column('species')[idx].replace('_', ' ')
        subcategory = self.metadata_file.get_column('subcategory')[idx]
        if subcategory is not None:
            subcategory = subcategory.replace('_', ' ')
        photographer = self.metadata_file.get_column('photographer')[idx].replace('_', ' ')
        bbx = self.metadata_file.get_column('bb_x')[idx]
        bby = self.metadata_file.get_column('bb_y')[idx]
        bbw = self.metadata_file.get_column('bb_width')[idx]
        bbh = self.metadata_file.get_column('bb_height')[idx]
        element = {
            'img': img,
            'species': species,
            'subcategory': subcategory,
            'photographer': photographer,
            'bbx' : bbx,
            'bby' : bby,
            'bbw' : bbw,
            'bbh' : bbh
        }
        if self.transform:
            element = self.transform(element)
        return element
```

:::

## Instantiate initial class

```{python}
img_dir = os.path.join(base_dir, 'images')

nabirds_initial = NABirdsDataset(
    metadata,
    img_dir
)
```

## Print an element

```{python}
next(iter(nabirds_initial))
```

:::{.note}

Note the image values between 0 and 255.

:::

## Display a sample of data

Let's display the first 4 images and their bounding boxes (remember that we have to display the photographers names as a requirement of this dataset):

```{python}
import matplotlib.pyplot as plt
import matplotlib.patches as patches

fig = plt.figure(figsize=(8, 9))

for i, element in enumerate(nabirds_initial):
    ax = plt.subplot(2, 2, i + 1)
    plt.tight_layout()
    ax.set_title(
        f"""
        Element {i}
        Species: {element['species']}
        Additional information: {element['subcategory']}
        Picture by {element['photographer']}
        """,
        fontsize=9,
        linespacing=1.5
    )
    ax.axis('off')
    plt.imshow(element['img'])
    rect = patches.Rectangle(
        (element['bbx'], element['bby']),
        element['bbw'],
        element['bbh'],
        linewidth=1,
        edgecolor='r',
        facecolor='none'
    )
    ax.add_patch(rect)
    if i == 3:
        plt.show()
        break
```

## Print info on a sample of data

```{python}
for i, element in enumerate(nabirds_initial):
    print(f"Image dimensions: {element['img'].shape}, data type: {element['img'].dtype}")
    if i == 3:
        break
```

Notice how the images are all of different sizes. This is a problem because neural networks need images of the same size.

We are also not making use of the bounding boxes this dataset comes with. This means that we have a large number of pixels we know do not contain any bird part.

Lastly, our images are fairly large (often up to 1024 pixels in width or height). Classification models often come with a few variants for a handful of different image sizes, but the most standard size is 224 by 224 (good compromise between detail and speed).

In this section, we do the first step of addressing these problems: we crop the images to the bounding boxes, with a 20% margin, and save them to disk. The rest will be addressed during the data augmentation step (and resizing for the evaluation set).

## Cleaning Dataset class

We could write a function to clean our images. Another, more elegant approach is to create a class:

```{python}
class CleaningDataset:
    """Cleaning dataset class."""
    def __init__(self, metadata_file, source_dir, target_dir):
        self.metadata_file = metadata_file
        self.source_dir = source_dir
        self.target_dir = target_dir

    def __len__(self):
        return len(self.metadata_file)

    def __getitem__(self, idx):
        """Returns cropped image and save path."""

        # Build paths
        read_path = os.path.join(
            self.source_dir,
            self.metadata_file.get_column('path')[idx]
        )
        save_path = os.path.join(
            self.target_dir,
            self.metadata_file.get_column('path')[idx]
        )

        # Load image
        try:
            img = iio.imread(read_path)
        except Exception as e:
            print(f"Error loading {filename}: {e}")
            return None, None

        # If a file has an alpha channel, drop it
        if img.shape[2] == 4: # <1>
            img = img[:,:,:3]

        # Get metadata
        species = self.metadata_file.get_column('species')[idx].replace('_', ' ')
        subcategory = self.metadata_file.get_column('subcategory')[idx]
        if subcategory is not None:
            subcategory = subcategory.replace('_', ' ')
        photographer = self.metadata_file.get_column('photographer')[idx].replace('_', ' ')

        # Get bounding box data
        bbx = self.metadata_file.get_column('bb_x')[idx]
        bby = self.metadata_file.get_column('bb_y')[idx]
        bbw = self.metadata_file.get_column('bb_width')[idx]
        bbh = self.metadata_file.get_column('bb_height')[idx]

        # Crop image with a 20% margin:
        # 1. Get the image dimensions (to make sure we don't go out of bounds)
        height, width = img.shape[:2]

        # 2. Calculate the margin size (20% of the box dimensions)
        # We use int() because pixel coordinates must be integers
        margin_w = int(bbw * 0.2)
        margin_h = int(bbh * 0.2)

        # 3. Calculate the new coordinates with the margin
        x1 = bbx - margin_w
        y1 = bby - margin_h
        x2 = bbx + bbw + margin_w
        y2 = bby + bbh + margin_h

        # 4. Set limits to coordinates to ensure they stay inside the image
        # x1 and y1 cannot be less than 0
        # x2 and y2 cannot be larger than the image width/height
        x1 = max(0, x1)
        y1 = max(0, y1)
        x2 = min(width, x2)
        y2 = min(height, y2)

        # 5. Crop
        img_cropped = img[y1:y2, x1:x2]

        return img_cropped, save_path
```

1. Reason for this step:

:::{.notenoit}

Even serious, well curated datasets often contain inconsistent or erroneous data. After playing with this dataset, I realized that at least one image has 4 channels (RGBA, i.e. RGB and the alpha channel). This means that its NumPy array version has 4 instead of 3 dimensions...

This didn't make any sense to me since all the images were JPEG (it is easy to verify that with command line utilities such as [fd](https://github.com/sharkdp/fd)) and JPEG images do not have an alpha channel.

So I wrote a function that would return the path of the (first) image with an extra channel and I got `0344/3b69ce35b9404f3eb321100c93dd2b43.jpg`.

It *appears* to be a JPEG image. However, when passing it to the [identify](https://imagemagick.org/script/identify.php) command from [ImageMagick](https://imagemagick.org/), I realized that it was in fact a PNG image *mislabelled as a JPEG*...

Here is an equivalent way to show this in Python:

```{python}
from PIL import Image

img = os.path.join(img_dir, '0344/3b69ce35b9404f3eb321100c93dd2b43.jpg')

with Image.open(img) as img:
    print(f"The actual format of the image is {img.format}.")
```

:::

## Create the clean data in parallel

Built-in multiprocessing in Python can be done with either of the `ProcessPoolExecutor` class from the [`concurrent.futures` module](https://docs.python.org/3/library/concurrent.futures.html) or the `Pool` class from the [`multiprocessing` package](https://docs.python.org/3/library/multiprocessing.html).

Let's use the first one:

```{python}
from concurrent.futures import ProcessPoolExecutor
from tqdm import tqdm  # to display a progress bar
```

Let's instantiate our `CleaningDataset`:

```{python}
cleaned_img_dir = os.path.join(base_dir, 'cleaned_images')

dataset_to_clean = CleaningDataset(
    metadata_file=metadata,
    source_dir=img_dir,
    target_dir=cleaned_img_dir
)
```

We can now create a helper function:

```{python}
def process_idx(i):
    """Helper function for the parallel worker."""
    img, path = dataset_to_clean[i]
    if img is not None:
        # Create target directory if it doesn't exist
        os.makedirs(os.path.dirname(path), exist_ok=True)
        # Save cleaned image
        iio.imwrite(path, img)
        return 1 # Success
    return 0 # Failure
```

And run it in parallel:

:::{.info}

Note that you will not be able to run the following chunk:

- Cropping 50,000 images takes a lot on the CPUs and if we do it all, we will probably crash the cluster.
- Additionally, we would all be trying to write to the same path, creating weird file conflicts.

I ran this ahead of time and already created the cropped files and I did not give you write access to the dataset.

If you want to run the code and experiment with various numbers of CPUs, you can do this later on your machine or on a production cluster.

:::

```{.python filename="Don't try to run this chunk in the training cluster."}
# Use as many workers as you have CPU cores
with ProcessPoolExecutor() as executor:
    # Map indices to the process function
    results = list(tqdm(
        executor.map(process_idx, range(len(dataset_to_clean))),
        total=len(dataset_to_clean),
        desc='Cleaning Images'
    ))

print(f"Done. {sum(results)} images processed.")
```

```
Done. 48562 images processed.
```

You can watch the parallel work live with an application such as [htop](https://github.com/htop-dev/htop/) (on your machine or the cluster) or [btop](https://github.com/aristocratos/btop) (on your machine).

Here is a screenshot I took from `btop` on my machine while creating the cleaned images. You can see that my 16 cores are working in parallel:

![](img/multiprocessing_img_cleaning.png){width="70%"}

## Instantiate treated class

Now we can instantiate a new instance of our Dataset class with the cropped data:

```{python}
nabirds = NABirdsDataset(
    metadata,
    cleaned_img_dir
)
```

## Print info on a sample

```{python}
for i, element in enumerate(nabirds):
    print(f"Image new dimensions: {element['img'].shape}, data type: {element['img'].dtype}")
    if i == 3:
        break
```

## Display a sample

Let's display the first 4 cleaned images to make sure they look like what we expect:

```{python}
fig = plt.figure(figsize=(8, 9))

for i, element in enumerate(nabirds):
    ax = plt.subplot(2, 2, i + 1)
    plt.tight_layout()
    ax.set_title(
        f"""
        Element {i}
        Species: {element['species']}
        Additional information: {element['subcategory']}
        Picture by {element['photographer']}
        """,
        fontsize=9,
        linespacing=1.5
    )
    ax.axis('off')
    plt.imshow(element['img'])
    if i == 3:
        plt.show()
        break
```
