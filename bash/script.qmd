---
title: Writing scripts
author:
  - Marie-Hélène Burle
  - Alex Razoumov
---

We now know a lot of UNIX commands! Wouldn't it be great if we could save certain commands so that we
could run them later or not have to type them out again? As it turns out, this is extremely easy to
do. Saving a list of commands to a file is called a "shell script". These shell scripts can be run
whenever we want, and are a great way to automate our work.

```{.bash}
cd ~/Desktop/data-shell/molecules
nano process.sh
	#!/bin/bash         # this is called sha-bang; can be omitted for generic (bash/csh/tcsh) commands
	echo Looking into file octane.pdb
	head -15 octane.pdb | tail -5       # what does it do?
bash process.sh   # the script ran!
```

Alternatively, you can change file permissions:

```{.bash}
chmod u+x process.sh
./process.sh
```

Let's pass an arbitrary file to it:

```{.bash}
nano process.sh
	#!/bin/bash
	echo Looking into file $1       # $1 means the first argument to the script
    head -15 $1 | tail -5
./process cubane.pdb
./process propane.pdb
```

* head -15 "$1" | tail -5     # placing in double-quotes lets us pass filenames with spaces
* head $2 $1 | tail $3        # what will this do?
* $# holds the number of command-line arguments
* $@ means all command-lines arguments to the script (words in a string)

<!-- > **Quiz 11:** script.sh in molecules Users/nelle/molecules. -->

<!-- > **Exercise:** write a script that takes any number of filenames, e.g., "scriptName.sh cubane.pdb -->
<!-- > propane.pdb", for each file prints the number of lines and its first five lines, and separates the -->
<!-- > output from different files by an empty line. -->

{{< question num="`file permissions`" >}}
Let's talk more about file permissions.
{{< /question >}}

{{< question num=34 >}}
In the `molecules` directory (download link mentioned <a href="../bash/bash-04-tar-gzip" target="_blank">here</a>),
create a shell script called `scan.sh` containing the following:
```{.bash}
#!/bin/bash
head -n $2 $1
tail -n $3 $1
```
While you are in that current directory, you type the following command (with space between two 1s):
```{.bash}
./scan.sh  '*.pdb'  1  1
```
What output would you expect to see?
1. All of the lines between the first and the last lines of each file ending in `.pdb` in the current directory
2. The first and the last line of each file ending in `.pdb` in the current directory
3. The first and the last line of each file in the current directory
4. An error because of the quotes around `*.pdb`
{{< /question >}}

[Here](https://youtu.be/UGZI6_HDyDc) and [here](https://youtu.be/rNnrcqkhXQo) are two videos on this topic.

## Variables

We already saw variables that were specific to scripts ($1, $@, ...) and to loops ($file). Variables can be used
outside of scripts:

```{.bash}
myvar=3        # no spaces permitted around the equality sign!
echo myvar     # will print the string 'myvar'
echo $myvar    # will print the value of myvar
```

Sometimes you can see the notation:

```{.bash}
export myvar=3
```

Using 'export' will make sure that all inherited processes of this shell will have access to this
variable. Try defining the variable *newvar* without/with 'export' and then running the script:

```{.bash}
nano process.sh
	#!/bin/bash
    echo $newvar
```

You can assign a command's output to a variable to use in another command (this is called *command
substitution*) -- we'll see this later when we play with 'find' command.

```{.bash}
printenv    # print all declared variables
env         # same
unset myvar   # unset a variable
```

{{< question num="`using a variable inside a string`" >}}
```{.bash}
var="sun"
echo $varshine
echo ${var}shine
echo "$var"shine
```
{{< /question >}}

{{< question num="`variable manipulation`" >}}
```{.bash}
myvar="hello"
echo $myvar
echo ${myvar:offset}
echo ${myvar:offset:length}
echo ${myvar:2:3}    # 3 characters starting from character 2
echo ${myvar/l/L}    # replace the first match of a pattern
echo ${myvar//l/L}   # replace all matches of a pattern
```
{{< /question >}}

Environment variables are those that affect the behaviour of the shell and user interface:

```{.bash}
echo $HOME
echo $PATH
echo $PWD
echo $PS1
```

It is best to define custom environment variables inside your ~/.bashrc file. It is loaded every time you
start a new shell.

{{< question num=22 >}}
Play with variables and their values. Change the prompt, e.g. `PS1="\u@\h \w> "`.
{{< /question >}}

[Here](https://youtu.be/nNf4Xb56yEs) is a video on this topic.

## Scripts in other languages

As a side note, it possible to incorporate scripts in other languages into your bash code, e.g. consider this:

```{.bash}
function test() {
    randomFile=${RANDOM}${RANDOM}.py
    cat << EOF > $randomFile
#!/usr/bin/python3
print("do something in Python")
EOF
    chmod u+x $randomFile
    ./$randomFile
    /bin/rm $randomFile
}
```

Here `EOF` is a random delimiter string, and `<<` tells bash to wait for the delimiter to end input. For example, try
the following:

```{.bash}
cat << the_end
This text will be
printed in the terminal.
the_end
```
