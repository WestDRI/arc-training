---
title: Functions
author:
  - Marie-Hélène Burle
  - Alex Razoumov
---

:::{.def}

As in any programming language, Bash functions are blocks of code that can be accessed by their names.

:::

## Function definition

You define a new function with the following syntax:

```default
<name>() {
	<commands>
}
```

:::{.example}

Example of function definition:

:::

```{.bash}
greetings() {
  echo hello
}
```

The syntax for arguments place-holders is the same as the one used in [scripts](script.html) (e.g. `$1`, `$2`, `$#`, `$@`).

## Storing functions

You can define a new function directly in the terminal. Such function would however only be available during your current session. Since functions contain code that is intended to be run repeatedly, it makes sense to store function definitions in a file. Before functions become available, the file needs to be sourced (e.g. `source file.sh`).

A convenient file is `~/.bashrc`. The file is automatically sourced every time you start a shell so your functions will always be defined and ready for use.

## Example

Let's write a function called `combine` that takes all the files we pass to it, copies them into a randomly named directory, and prints that directory to the terminal:

```{.bash}
combine() {
  if [ $# -eq 0 ]; then
    echo "No arguments specified. Usage: combine file1 [file2 ...]"
    return 1                # Return a non-zero error code
  fi
  dir=$RANDOM$RANDOM
  mkdir $dir
  cp $@ $dir
  echo look in the directory $dir
}
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Write a function to swap two file names. \
Add a check that both files exist before renaming them.

:::

<!-- {{< solution >}} -->
<!-- ```{.bash} -->
<!-- function swap() { -->
<!--     if [ -e $1 ] && [ -e $2 ] ; then -->
<!--         mv $2 $2.bak -->
<!--         mv $1 $2 -->
<!--         mv $2.bak $1 -->
<!--     else -->
<!--         echo At least one of these files does not exist. -->
<!--     fi -->
<!-- } -->
<!-- ``` -->
<!-- {{< /solution >}} -->

<!-- Write a function `archive()` to replace directories with their gzipped archives. -->

<!-- ```{.bash} -->
<!-- ls -F -->
<!-- chapter1/  chapter2/  notes/ -->
<!-- archive chapter* notes/ -->
<!-- ls -->
<!-- chapter1.tar.gz  chapter2.tar.gz  notes.tar.gz -->
<!-- ``` -->

<!-- Write a function `countfiles` to count files in all directories passed to it as arguments (need to loop through all arguments). -->

<!-- At the beginning add the check: -->

<!-- ```{.bash} -->
<!--     if [ $# -eq 0 ]; then -->
<!--         echo "No arguments given. Usage: countfiles dir1 dir2 ..." -->
<!--         return 1 -->
<!--     fi -->
<!-- ``` -->

<!-- {{< solution >}} -->
<!-- ```{.bash} -->
<!-- function countfiles() { -->
<!--     if [ $# -eq 0 ]; then -->
<!--         echo "No arguments given. Usage: countfiles dir1 dir2 ..." -->
<!--         return 1 -->
<!--     fi -->
<!--     for dir in $@; do -->
<!--         echo in $dir we found $(find $dir -type f | wc -l) files -->
<!--     done -->
<!-- } -->
<!-- ``` -->
<!-- {{< /solution >}} -->

## Scripts vs functions

Scripts and functions play similar roles and they both can take command-line arguments.

A *script* is a file sitting at a given path whereas a *function* is defined in your environment. Therefore, you need to prepend a script's path to its name to run it, while you can call a function by its name without the need for a path.

*[Here](https://youtu.be/gSCRWUG9fy4) is a video of a previous version of this workshop.*
