---
title: Variables
author: Marie-Hélène Burle
---

```{r}

```

:::{.def}



:::

## Declaring variables

You declare a variable (i.e. a name that holds a value) with the `=` sign:

```{.bash}
var=value
```

:::{.note}

Make sure not to put spaces around the equal sign.

:::

:::{.example}

Example:

:::

```{bash}
var=5
```

## Expanding variables

To expand a variable (to access its value), you need to prepend its name with `$`.

:::{.example}

This is not what we want:

:::

```{bash}
var=value
echo var
```

:::{.example}

This however works:

:::

```{bash}
var=value
echo $var
```

### Quotes

Quotes are necessary for values containing special characters such as spaces.

:::{.example}

This doesn't work:

:::

```{bash}
var=value with spaces
echo $var
```

:::{.example}

This works:

:::

```{bash}
var="value with spaces"
echo $var
```

:::{.example}

This also works:

:::

```{bash}
var='value with spaces'
echo $var
```

While not necessary in many situations, it is safer to expand variables in double quotes, in case the expansion leads to problematic special characters. In the example above, this was not problematic and using `$var` or `"$var"` are the same.

In the following example however, it is problematic:

```{.bash}
var="value with spaces"
touch $var
```

This creates 3 files called `value`, `with`, and `spaces`. Probably not what you want.

The following creates a single file called `value with spaces`:

```{.bash}
var="value with spaces"
touch "$var"
```

:::{.note}

To be safe, it is thus a good habit to quote expanded variables.

:::

It is important to note however that [single quotes don't expand variables]{.emph} (only double quotes do).

The following would thus create a file called `$var`:

```{.bash}
var="value with spaces"
touch '$var'
```

## Exporting variables

Using `export` ensures that all inherited processes of this shell also have access to this variable:

```{.bash}
export var=3
```

<!-- Try defining the variable *newvar* without/with 'export' and then running the script: -->

<!-- ```{.bash} -->
<!-- nano process.sh -->
<!-- 	#!/bin/bash -->
<!--     echo $newvar -->
<!-- ``` -->

<!-- You can assign a command's output to a variable to use in another command (this is called *command -->
<!-- substitution*) -- we'll see this later when we play with 'find' command. -->

<!-- ```{bash} -->
<!-- var="sun" -->
<!-- echo $varshine -->
<!-- echo ${var}shine -->
<!-- echo "$var"shine -->
<!-- ``` -->

<!-- ```{bash} -->
<!-- myvar="hello" -->
<!-- echo $myvar -->
<!-- echo ${myvar:offset} -->
<!-- echo ${myvar:offset:length} -->
<!-- echo ${myvar:2:3}    # 3 characters starting from character 2 -->
<!-- echo ${myvar/l/L}    # replace the first match of a pattern -->
<!-- echo ${myvar//l/L}   # replace all matches of a pattern -->
<!-- ``` -->

## Variable manipulation

When recalling the value of a variable, you can make changes to it.

:::{.example}

Example:

:::

```{bash}
myvar="hello"
echo $myvar
echo ${myvar:2:3}    # Print 3 characters starting from character 2
echo ${myvar/l/L}    # Replace the first match of a pattern
echo ${myvar//l/L}   # Replace all matches of a pattern
```

You delete a variable with:

```{bash}
unset var
```

## Environment variables

[Environment variables](https://en.wikipedia.org/wiki/Environment_variable) help control the behaviour of processes on a machine. You can think of them as customizations of your system.

Many are set automatically.

:::{.example}

Example:

:::

```{.bash}
echo $HOME
```

```
/home/user20
```

There are many other environment variables (e.g. `PATH`, `PWD`, `PS1`). To see the list, you can run `printenv` or `env`.

If you want to add new environment variables, you can add them to your `~/.bashrc` file which is sourced each time you start a new shell.

<!-- Play with variables and their values. Change the prompt, e.g. `PS1="\u@\h \w> "`. -->

*[Here](https://youtu.be/nNf4Xb56yEs) is a video of a previous version of this workshop.*

