---
title: Control flow
aliases:
  - control_flow.html
author:
  - Marie-Hélène Burle
  - Alex Razoumov
---

```{r}

```

:::{.def}

By default, scripts get executed linearly from top to bottom. Often however, you want to control what gets executed when.

This section covers various ways to control the flow of execution through a script.

:::

:::{.callout-note collapse="true"}

## Data for this section (same data as previous section)

For this section, we will play with files created by [The Carpentries](https://carpentries.org/).

You can download them into a zip file called `data.zip` with:

```{.bash}
curl --output data.zip https://mint.westdri.ca/bash/data.zip
```

You can then unzip that file with:

```{.bash}
unzip data.zip
```

You should now have a `data` directory.

`cd` into it:

```{.bash}
cd data
```

:::

## Normal execution of commands

Commands get executed from top to bottom and from left to right. Different commands are separated by a line break and/or a semi-colon.

:::{.example}

Example:

:::

Look at the following commands:

```{.bash}
unzip bash.zip
rm bash.zip
```

This is equivalent to:

```{.bash}
unzip bash.zip;
rm bash.zip
```

and to:

```{.bash}
unzip bash.zip; rm bash.zip
```

This is what we did to get the data for the past few sessions.

In all three cases, both commands will try to run. Now, if for some reason, the unzipping fails, the zip file still gets deleted. That's a bummer.

## Conditional on previous command

### Execution conditional on success

Commands can be limited to running only if the previous command ran successfully thanks to the double-ampersand (`&&`).

:::{.example}

Example:

:::

```{.bash}
unzip bash.zip &&
	rm bash.zip
```

This is equivalent to:

```{.bash}
unzip bash.zip && rm bash.zip
```

If the unzipping works (if it returns a zero [exit status](https://en.wikipedia.org/wiki/Exit_status)), then the Zip file gets deleted. If however, the unzipping fails (if it returns a non-zero exit status), the script aborts and we haven't lost our Zip file.

### Execution conditional on failure

The opposite of `&&` is `||`: the second command only gets executed if the first one failed.

:::{.example}

Example:

:::

```{.bash}
unzip bash.zip || echo "Unzipping failed"
```

This can also be written as:

```{.bash}
unzip bash.zip ||
	echo "Unzipping failed"
```

## Conditional executions

Commands can be executed or not depending on some conditions. To achieve this, we first need to have expressions that define these conditions.

### Predicates

Predicates are expressions that, when evaluated, return either true or false.

Here are examples of predicates:

`[ $var == 'text' ]` checks whether `var` is equal to `'text'`.

`[ $var == number ]` checks whether `var` is equal to `number`.

`[ -e name ]` checks whether `name` exists.

`[ -d name ]` checks whether `name` is a directory.

`[ -f name ]` checks whether `name` is a file.

[Make sure to have spaces around each bracket.]{.emph}

:::{.exo}

:::{.yourturn}

Your turn:

:::

- Create a directory `d1` and a file `f1`.

<!-- ```{.bash} -->
<!-- mkdir d1 -->
<!-- touch f1 -->
<!-- ``` -->

- Write the predicates that test whether:

- `d1` exists,
- `d1` is a file,
- `d1` is a directory,
- `f1` is a file,
- `f1` is a directory.

:::

### If statements

#### Syntax

In its simplest form, `if` statements look like:

```{.bash}
if [ predicate ]
then
	command1
	command2
	...
fi
```

:::{.notenoit}

This can also be written as:

```{.bash}
if [ predicate ]; then command1; command2; ...; fi
```

:::

If the condition is true, the commands are executed, if the condition is false, nothing happens.

#### Examples

```{bash}
var=f1

if [ -e $var ]
then
	echo "$var exists"
fi
```

```{bash}
var=f2

if [ -e $var ]
then
	echo "$var exists"
fi
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Write a conditional expression that prints "d1 is a directory" if `d1` is a directory and test it.

:::

### If else statements

#### Syntax

If you want a different set of commands to be executed when the condition is false, you add an `else` statement:

```{.bash}
if [ predicate ]
then
	command1
	command2
	...
else
	command3
	command4
	...
fi
```

#### Examples

```{bash}
var=f1

if [ -e $var ]
then
	echo "$var exists"
else
	echo "$var does not exist"
fi
```

```{bash}
var=f2

if [ -e $var ]
then
	echo "$var exists"
else
	echo "$var does not exist"
fi
```

### If elif else statements

Of course, you can have multiple conditions defining trees of `if` statements. In that case, you use `elif` (any number of times):

#### Syntax

```{.bash}
if [ predicate1 ]
then
	command1
	command2
	...
elif [ predicate2 ]
then
	command3
	command4
	...
else
	command5
	command6
	...
fi
```

#### Examples

```{bash}
var=4

if (( $var < 0 ))
then
	echo "$var is negative"
elif (( $var > 0 ))
then
	echo "$var is positive"
else
	echo "$var is equal to zero"
fi
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Play with the value of `var` to test our if elif else statement.

:::

## Conditionally repeated executions

Commands can be executed as long as a condition returns `True` thanks to *while loops*.

### Syntax

The syntax of a while loop in Bash is:

```{.bash}
while [ predicate ]
do
	command1
	command2
	...
done
```

### Example

```{bash}
var=0

while (($var<10))
do
    echo "$var"
	((var++))
done
```

Be careful that while loops can lead to infinite loops. Such loops need to be manually interrupted (by pressing `<Ctrl+C>`).

:::{.example}

Example of infinite loop:

:::

```{.bash}
var=1

while (($var>0))
do
	echo "$var (Press <Ctrl+C> to stop)"
	((var++))
	sleep 1
done
```

## Executions repeated over a collection

Commands can be repeated for each element of a list thanks to *for loops*.

### Collections

For loops run a set of commands for each item of a collection. How do you create those collections?

#### Listing items one by one

The least efficient method is to list all the items one by one:

```{bash}
for i in file1 file2 file3
do
	echo $i
done
```

#### Wildcards

```{bash}
ls *.pdb
```

#### Brace expansion

Collections can also be created with brace expansion.

:::{.example}

Examples:

:::

```{bash}
echo {1,2,5}
```

:::{.note}

Make sure not to add a space after the commas.

:::

```{bash}
echo {list,of,strings}
```

```{bash}
echo {file1,file2}.sh
```

```{bash}
ls {ethane,methane,pentane}.pdb
```

```{bash}
echo {1..5}
```

```{bash}
echo {01..10}
```

```{bash}
echo {r..v}
```

```{bash}
echo {v..r}
```

```{bash}
echo {a..e}{1..3}
```

```{bash}
echo {a..c}{a..c}
```

```{bash}
echo {1..5}.txt
```

```{bash}
echo file{3..6}.sh
```

#### Sequences

Collections can also be sequences:

```{bash}
seq 1 2 10
```

:::{.note}

Here, `1` is the start of the sequence, `10` is the end, and `2` is the step.

:::

### For loops

#### Syntax

The general structure of a for loop is as follows:

```{.bash}
for iterable in collection
do
	command1
	command2
	...
done
```

#### Examples

The `molecules` directory contains a number of `.pdb` files. We want to rename them by prepending "gas_" to their current names.

We can do this by creating a collection with a wildcard and applying the command to each element of the collection with a for loop:

```{.bash}
for file in *.pdb
do
	mv $file gas_$file
done
```

:::{.notenoit}

This can also be written as:

```{.bash}
for file in *.pdb; do mv $file gas_$file; done
```

:::

Here is a for loop using a collection created by a sequence:

```{bash}
for i in $(seq 1 2 10)
do
	echo file$i.txt
done
```

<!-- :::{.exo} -->

<!-- :::{.yourturn} -->

<!-- Your turn: -->

<!-- ::: -->

<!-- Using what we learnt in the [string manipulation](https://mint.westdri.ca/bash/variables.html#string-manipulation) section, how could you remove the `gas_` prefix to all these files? -->

<!-- ::: -->

<!-- for ((i=1; i<=5; i++)) do echo $i; done   # can use C-style loops -->

:::{.exo}

:::{.yourturn}

Your turn:

:::

In a directory the command `ls` returns:

```
fructose.dat  glucose.dat  sucrose.dat  maltose.txt
```

What would be the output of the following loop?

```{.bash}
for datafile in *.dat
do
  cat $datafile >> sugar.dat
done
```

1. All of the text from `fructose.dat`, `glucose.dat` and `sucrose.dat` would be concatenated and saved to a file called `sugar.dat`.

2. The text from `sucrose.dat` will be saved to a file called `sugar.dat`.

3. All of the text from `fructose.dat`, `glucose.dat`, `sucrose.dat`, and `maltose.txt` would be concatenated and saved to a file called `sugar.dat`.

4. All of the text from `fructose.dat`, `glucose.dat` and `sucrose.dat` will be printed to the screen and saved into a file called `sugar.dat`.

:::

<!-- Write a loop that concatenates all .pdb files in `data-shell/molecules` subdirectory into one file called `allmolecules.txt`, prepending each fragment with the name of the corresponding .pdb file, and separating different files with an empty line. Run the loop, make sure it works, bring it up with the &nbsp;**↑**&nbsp; key and paste into the chat. -->

<!-- What will the loop `for i in hello 1 2 * bye; do echo $i; done` print? Try answering without running the loop. -->

<!-- Create a loop that writes into 10 files `chapter01.md`, `chapter02.md`, ..., `chapter10.md`. Each file should contain -->
<!-- chapter-specific lines, e.g. `chapter05.md` will contain exactly these lines: -->

*[Here](https://youtu.be/cCunoOIksAE) is a video of a previous version of this workshop.*
