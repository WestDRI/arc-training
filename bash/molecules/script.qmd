---
title: Writing scripts
author:
  - Marie-Hélène Burle
  - Alex Razoumov
---

:::{.def}

There are series of commands that you need to run regularly. Instead of having to type them each time, you can write them in a text file (called a script) with a `.sh` extension and execute that file whenever you want to run that set of commands. This is a great way to automate work.

This section covers scripts syntax and execution.

:::

:::{.callout-accordion collapse="true"}

## ***Data for this section***

For this section, we will be using data put together by [The Carpentries](https://carpentries.org/). You can download it by clicking [here](http://bit.ly/bashfile).

This will download a zip filed called `bfiles.zip`. Unzip it to your home directory. You should now see a `data-shell` directory. In it is a subdirectory called `molecules`.

This is what we will use for now, so `cd` into it:

```{.bash}
cd data-shell/molecules
```

:::

```{.bash}
cd ~/Desktop/data-shell/molecules
nano process.sh
	#!/bin/bash         # this is called sha-bang; can be omitted for generic (bash/csh/tcsh) commands
	echo Looking into file octane.pdb
	head -15 octane.pdb | tail -5       # what does it do?
bash process.sh   # the script ran!
```

Alternatively, you can change file permissions:

```{.bash}
chmod u+x process.sh
./process.sh
```

Let's pass an arbitrary file to it:

```{.bash}
nano process.sh
	#!/bin/bash
	echo Looking into file $1       # $1 means the first argument to the script
    head -15 $1 | tail -5
./process cubane.pdb
./process propane.pdb
```

* head -15 "$1" | tail -5     # placing in double-quotes lets us pass filenames with spaces
* head $2 $1 | tail $3        # what will this do?
* $# holds the number of command-line arguments
* $@ means all command-lines arguments to the script (words in a string)

<!-- > **Quiz 11:** script.sh in molecules Users/nelle/molecules. -->

<!-- > **Exercise:** write a script that takes any number of filenames, e.g., "scriptName.sh cubane.pdb -->
<!-- > propane.pdb", for each file prints the number of lines and its first five lines, and separates the -->
<!-- > output from different files by an empty line. -->

{{< question num="`file permissions`" >}}
Let's talk more about file permissions.
{{< /question >}}

{{< question num=34 >}}
In the `molecules` directory (download link mentioned <a href="../bash/bash-04-tar-gzip" target="_blank">here</a>),
create a shell script called `scan.sh` containing the following:
```{.bash}
#!/bin/bash
head -n $2 $1
tail -n $3 $1
```
While you are in that current directory, you type the following command (with space between two 1s):
```{.bash}
./scan.sh  '*.pdb'  1  1
```
What output would you expect to see?
1. All of the lines between the first and the last lines of each file ending in `.pdb` in the current directory
2. The first and the last line of each file ending in `.pdb` in the current directory
3. The first and the last line of each file in the current directory
4. An error because of the quotes around `*.pdb`
{{< /question >}}

*[Here](https://youtu.be/UGZI6_HDyDc) and [here](https://youtu.be/rNnrcqkhXQo) are two videos of a previous version of this workshop.*

## Variables

We already saw variables that were specific to scripts ($1, $@, ...) and to loops ($file). Variables can be used
outside of scripts:

```{.bash}
myvar=3        # no spaces permitted around the equality sign!
echo myvar     # will print the string 'myvar'
echo $myvar    # will print the value of myvar
```

Sometimes you can see the notation:

```{.bash}
export myvar=3
```

Using 'export' will make sure that all inherited processes of this shell will have access to this
variable. Try defining the variable *newvar* without/with 'export' and then running the script:

```{.bash}
nano process.sh
	#!/bin/bash
    echo $newvar
```

You can assign a command's output to a variable to use in another command (this is called *command
substitution*) -- we'll see this later when we play with 'find' command.

```{.bash}
printenv    # print all declared variables
env         # same
unset myvar   # unset a variable
```

{{< question num="`using a variable inside a string`" >}}
```{.bash}
var="sun"
echo $varshine
echo ${var}shine
echo "$var"shine
```
{{< /question >}}

{{< question num="`variable manipulation`" >}}
```{.bash}
myvar="hello"
echo $myvar
echo ${myvar:offset}
echo ${myvar:offset:length}
echo ${myvar:2:3}    # 3 characters starting from character 2
echo ${myvar/l/L}    # replace the first match of a pattern
echo ${myvar//l/L}   # replace all matches of a pattern
```
{{< /question >}}

Environment variables are those that affect the behaviour of the shell and user interface:

```{.bash}
echo $HOME
echo $PATH
echo $PWD
echo $PS1
```

It is best to define custom environment variables inside your ~/.bashrc file. It is loaded every time you
start a new shell.

{{< question num=22 >}}
Play with variables and their values. Change the prompt, e.g. `PS1="\u@\h \w> "`.
{{< /question >}}

*[Here](https://youtu.be/nNf4Xb56yEs) is a video of a previous version of this workshop.*

## Scripts in other languages

As a side note, it possible to incorporate scripts in other languages into your bash code, e.g. consider this:

```{.bash}
function test() {
    randomFile=${RANDOM}${RANDOM}.py
    cat << EOF > $randomFile
#!/usr/bin/python3
print("do something in Python")
EOF
    chmod u+x $randomFile
    ./$randomFile
    /bin/rm $randomFile
}
```

Here `EOF` is a random delimiter string, and `<<` tells bash to wait for the delimiter to end input. For example, try
the following:

```{.bash}
cat << the_end
This text will be
printed in the terminal.
the_end
```
