---
title: Writing scripts
author:
  - Marie-Hélène Burle
  - Alex Razoumov
---

```{r}

```

:::{.def}

There are series of commands that you need to run regularly. Instead of having to type them each time, you can write them in a text file (called a script) with a `.sh` extension and execute that file whenever you want to run that set of commands. This is a great way to automate work.

This section covers scripts syntax and execution.

:::

:::{.callout-accordion collapse="true"}

## ***Data for this section***

For this section, we will play with files created by [The Carpentries](https://carpentries.org/).

You can download them into a zip file called `bash.zip` with:

```{.bash}
wget http://bit.ly/bashfile -O bash.zip
```

You can then unzip that file with:

```{.bash}
unzip bash.zip
```

Finally, you can delete the zip file:

```{.bash}
rm bash.zip
```

You should now have a `data-shell` directory with a `molecules` subdirectory.

`cd` into it:

```{.bash}
cd data-shell/molecules
```

:::

## Writing and executing scripts

### Scripts as arguments to `bash`

A shell script is simply a text file. You can create it with a text editor such as [nano](https://en.wikipedia.org/wiki/GNU_nano) which is installed on most systems.

Let's try to create one that we will call `test.sh`:

```{.bash}
nano test.sh
```

In the file, write the command: `echo This is my first script`.

To distinguish between commands run in the terminal and commands written in a file, I will display the content of files this way:

```{.bash filename="<file name>"}
<commands>
```

So this is the content of our `test.sh` file:

```{.bash filename="test.sh"}
echo This is my first script
```

Now, how do we run this?

We simply pass it as an argument to the `bash` command:

```{.bash}
bash test.sh
```

```
This is my first script
```

And it worked!

### Shebang

There is another way to write and execute scripts: we can use a [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).

A shebang consists of the characters `#!` followed by the path of an executable. Here, the executable we want is `bash` and its path is `/bin/bash`.

So our script becomes:

```{.bash filename="test.sh"}
#!/bin/bash

echo This is my first script.
```

Now, the cool thing about this is that we don't need to pass the script as an argument of the `bash` command anymore since the information that this should be executed by Bash is already written in the shebang. Instead, we can execute it with `./test.sh`.

But there is a little twist:

```{.bash}
./test.sh
```

```
bash: ./test.sh: Permission denied
```

We first need to make the file executable by changing its permissions.

### Unix permissions

Unix systems such as Linux use [POSIX permissions](https://en.wikipedia.org/wiki/File-system_permissions#POSIX_permissions).

To add an executable permission to a file, you need to run:

```{.bash}
chmod u+x test.sh
```

Now that our script is executable, we can run:

```{.bash}
./test.sh
```

```
This is my first script
```

<!-- ```{.bash} -->
<!-- echo Looking into file octane.pdb -->
<!-- head -15 octane.pdb | tail -5       # what does it do? -->
<!-- bash process.sh   # the script ran! -->
<!-- ``` -->

<!-- ```{.bash} -->
<!-- #!/bin/bash -->
<!-- echo Looking into file octane.pdb -->
<!-- head -15 octane.pdb | tail -5       # what does it do? -->
<!-- bash process.sh   # the script ran! -->
<!-- ``` -->

<!-- Alternatively, you can change file permissions: -->

<!-- ```{.bash} -->
<!-- chmod u+x process.sh -->
<!-- ./process.sh -->
<!-- ``` -->

<!-- Let's pass an arbitrary file to it: -->

<!-- ```{.bash} -->
<!-- nano process.sh -->
<!-- 	#!/bin/bash -->
<!-- 	echo Looking into file $1       # $1 means the first argument to the script -->
<!--     head -15 $1 | tail -5 -->
<!-- ./process cubane.pdb -->
<!-- ./process propane.pdb -->
<!-- ``` -->

<!-- * head -15 "$1" | tail -5     # placing in double-quotes lets us pass filenames with spaces -->
<!-- * head $2 $1 | tail $3        # what will this do? -->
<!-- * $# holds the number of command-line arguments -->
<!-- * $@ means all command-lines arguments to the script (words in a string) -->

<!-- > **Quiz 11:** script.sh in molecules Users/nelle/molecules. -->

<!-- > **Exercise:** write a script that takes any number of filenames, e.g., "scriptName.sh cubane.pdb -->
<!-- > propane.pdb", for each file prints the number of lines and its first five lines, and separates the -->
<!-- > output from different files by an empty line. -->

<!-- In the `molecules` directory (download link mentioned <a href="../bash/bash-04-tar-gzip" target="_blank">here</a>), -->
<!-- create a shell script called `scan.sh` containing the following: -->
<!-- ```{.bash} -->
<!-- #!/bin/bash -->
<!-- head -n $2 $1 -->
<!-- tail -n $3 $1 -->
<!-- ``` -->
<!-- While you are in that current directory, you type the following command (with space between two 1s): -->
<!-- ```{.bash} -->
<!-- ./scan.sh  '*.pdb'  1  1 -->
<!-- ``` -->
<!-- What output would you expect to see? -->
<!-- 1. All of the lines between the first and the last lines of each file ending in `.pdb` in the current directory -->
<!-- 2. The first and the last line of each file ending in `.pdb` in the current directory -->
<!-- 3. The first and the last line of each file in the current directory -->
<!-- 4. An error because of the quotes around `*.pdb` -->

*[Here](https://youtu.be/UGZI6_HDyDc) and [here](https://youtu.be/rNnrcqkhXQo) are two videos of a previous version of this workshop.*

## Variables

In Bash, it is possible to define variables. Let's create a variable and print its value:

```{bash}
var=3     # Do not add spaces around the equality sign
echo var
```

Mmm... not what we wanted...

To retrieve the value of a shell variable, we need to prepend `$` to it:

```{bash}
var=3
echo $var
```

Sometimes you will see this notation:

```{.bash}
export myvar=3
```

Using `export` ensures that all inherited processes of this shell also have access to this variable.

<!-- Try defining the variable *newvar* without/with 'export' and then running the script: -->

<!-- ```{.bash} -->
<!-- nano process.sh -->
<!-- 	#!/bin/bash -->
<!--     echo $newvar -->
<!-- ``` -->

<!-- You can assign a command's output to a variable to use in another command (this is called *command -->
<!-- substitution*) -- we'll see this later when we play with 'find' command. -->

To delete a variable, run:

```{bash}
unset var
```

Variables are extremely useful in scripts.

<!-- ```{bash} -->
<!-- var="sun" -->
<!-- echo $varshine -->
<!-- echo ${var}shine -->
<!-- echo "$var"shine -->
<!-- ``` -->

<!-- ```{bash} -->
<!-- myvar="hello" -->
<!-- echo $myvar -->
<!-- echo ${myvar:offset} -->
<!-- echo ${myvar:offset:length} -->
<!-- echo ${myvar:2:3}    # 3 characters starting from character 2 -->
<!-- echo ${myvar/l/L}    # replace the first match of a pattern -->
<!-- echo ${myvar//l/L}   # replace all matches of a pattern -->
<!-- ``` -->

### Variable manipulation

When recalling the value of a variable, you can make changes to it.

:::{.example}

Example:

:::

```{bash}
myvar="hello"
echo $myvar
echo ${myvar:2:3}    # Print 3 characters starting from character 2
echo ${myvar/l/L}    # Replace the first match of a pattern
echo ${myvar//l/L}   # Replace all matches of a pattern
```

### Environment variables

[Environment variables](https://en.wikipedia.org/wiki/Environment_variable) help control the behaviour of processes on a machine. You can think of them as customizations of your system.

Many are set automatically.

:::{.example}

Example:

:::

```{.bash}
echo $HOME
```

```
/home/user20
```

There are many other environment variables (e.g. `PATH`, `PWD`, `PS1`). To see the list, you can run `printenv` or `env`.

If you want to add new environment variables, you can add them to your `~/.bashrc` file which is sourced each time you start a new shell.

<!-- Play with variables and their values. Change the prompt, e.g. `PS1="\u@\h \w> "`. -->

*[Here](https://youtu.be/nNf4Xb56yEs) is a video of a previous version of this workshop.*

## Scripts in other languages

As a side note, it is possible to incorporate scripts in other languages into your bash code.

:::{.example}

Example:

:::

```{.bash}
function test() {
    randomFile=${RANDOM}${RANDOM}.py
    cat << EOF > $randomFile
#!/usr/bin/python3
print("do something in Python")
EOF
    chmod u+x $randomFile
    ./$randomFile
    /bin/rm $randomFile
}
```

:::{.note}

`EOF` is a random delimiter string and `<<` tells Bash to wait for that delimiter to end the input.

Here is an example of this syntax:

```{.bash}
cat << the_end
This text
will be printed
in the terminal.
the_end
```

:::
