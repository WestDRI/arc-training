---
title: Collections
author: Marie-Hélène Burle
---

## Lists

Lists are declared in square brackets. **They are mutable, ordered (thus indexable), and possibly heterogeneous collections of values.**

Lists are ordered:

```{python}
['b', 'a'] == ['b', 'a']
```

```{python}
['b', 'a'] == ['a', 'b']
```

They can have repeat values:

```{python}
type(['a', 'a', 'a', 't'])
```

Lists can be homogeneous:

```{python}
type(['b', 'a', 'x', 'e'])
```

```{python}
type('b') == type('a') == type('x') == type('e')
```

or heterogeneous:

```{python}
type([3, 'some string', 2.9, 'z'])
```

```{python}
type(3) == type('some string') == type(2.9) == type('z')
```

They can even be nested:

```{python}
type([3, ['b', 'e', 3.9, ['some string', 9.9]], 8])
```

The length of a list is the number of items it contains and can be obtained with the function `len`:

```{python}
len([3, ['b', 'e', 3.9, ['some string', 9.9]], 8])
```

To extract an item from a list, you index it:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][0]
```

:::{.note}

Python starts indexing at `0`, so what we tend to think of as the "first" element of a list is for Python the "zeroth" element.

:::

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][1]
```

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][2]
```

```{python}
# Of course you can't extract items that don't exist
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][3]
```

You can index from the end of the list with negative values (here you start at `-1` for the last element):

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][-1]
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

How could you extract the string `'some string'` from the list `[3, ['b', 'e', 3.9, ['some string', 9.9]], 8]`?

:::

You can also slice (index multiple values) a list:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][0:1]
```

:::{.note}

Notice how slicing returns a list.

Notice also how the left index is included but the right index excluded.

:::

If you omit the first index the slice starts at the beginning of the list:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][:6]
```

If you omit the second index the slice goes to the end of the list:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][6:]
```

When slicing, you can specify the stride:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][2:7:2]
```

:::{.note}

The default stride is `1`:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][2:7] == [1, 2, 3, 4, 5, 6, 7, 8, 9][2:7:1]
```

:::

A consequence of the stride is that you can reverse the order of a list with a `-1` stride applied on the whole list:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][::-1]
```

You can test whether an item is in a list:

```{python}
3 in [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

```{python}
9 in [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

or not in a list:

```{python}
3 not in [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

You can get the index (position) of an item inside a list:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8].index(3)
```

:::{.note}

Note that this only returns the index of the first occurrence:

```{python}
[3, 3, ['b', 'e', 3.9, ['some string', 9.9]], 8].index(3)
```

:::

Lists are mutable (they can be modified):

- You can replace items in a list by other items:

```{python}
L = [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
L
```

```{python}
L[1] = 2
L
```

- You can delete items from a list:

```{python}
# Using their indices with list.pop
L.pop(2)
L
```

:::{.note}

Here, because we are using `list.pop`, `2` represents the index (the 3rd item).

:::

```{python}
# Using their indexes with del
del L[0]
L
```

:::{.note}

Notice how a list can have a single item:

```{python}
len(L)
```

It is then called a "singleton list".

:::

```{python}
# Using their values
L.remove(2)
L
```

:::{.note}

Here, because we are using `list.remove`, `2` is the value `2`.

:::

:::{.note}

Notice how a list can even be empty:

```{python}
len(L)
```

You can actually initialise empty lists:

```{python}
M = []
type(M)
```

:::

- You can add items to a list:

One at a time:

```{python}
L.append(7)
L
```

And if you want to add multiple items at once?


```{python}
# This doesn't work...
L.append(3, 6, 9)
```

```{python}
# This doesn't work either (that's not what we wanted)
L.append([3, 6, 9])
L
```

In this case, you need to use `list.extend`:

```{python}
L.extend([3, 6, 9])
L
```

If you don't want to add an item at the end of a list, you can use `list.insert(<index>, <object>)`:

```{python}
L.insert(3, 'test')
L
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Insert the string `'nested'` in the zeroth position of the nested list `[3, 6, 9]` in `L`.

(If you are running behind, you can recreate `L` with:

```{python}
L = [7, [3, 6, 9], 3, 'test', 6, 9]
```

:::

- You can sort an homogeneous list:

```{python}
# Items of different types cannot be sorted
L = [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
L.sort()
```

```{python}
L = [3, 9, 10, 0]
L.sort()
L
```

```{python}
L = ['some string', 'b', 'a']
L.sort()
L
```

You can also get the min and max value of homogeneous lists:

```{python}
min([3, 9, 10, 0])
```

```{python}
max(['some string', 'b', 'a'])
```

But not heterogeneous lists:

```{python}
min([3, ['b', 'e', 3.9, ['some string', 9.9]], 8])
```

Lists can also be concatenated with `+`:

```{python}
L + [3, 6, 9]
```

or repeated with `*`:

```{python}
L * 3
```

## Strings

Strings behave (a little) like lists of characters in that they have a length (the number of characters):

```{python}
S = 'This is a string.'
len(S)
```

They have a min and a max:

```{python}
min(S)
```

```{python}
max(S)
```

You can index them:

```{python}
S[3]
```

Slice them:

```{python}
S[10:16]
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Reverse the order of the string `S`.

:::

They can also be concatenated with `+`:

```{python}
T = 'This is another string.'
print(S + ' ' + T)
```

or repeated with `*`:

```{python}
print(S * 3)
```

```{python}
print((S + ' ') * 3)
```

This is where the similarities stop however: methods such as `list.sort`, `list.append`, etc. will not work on strings.

## Arrays

Python comes with a built-in [array](https://docs.python.org/3/library/array.html) module. When you need arrays for storing and retrieving data, this module is perfectly suitable and extremely lightweight. [This tutorial](https://www.softwaretestinghelp.com/how-to-use-python-array/) covers the syntax in detail.

Whenever you plan on performing calculations on your data however (which is the vast majority of cases), you should instead use the [NumPy](https://numpy.org/) package that Alex will cover this afternoon.

## Tuples

Tuples are declared in parentheses. They are immutable and ordered (thus indexable) collections of values.

## Sets

Sets are declared in square brackets.

## Dictionaries

<!-- Dictionaries are declared in curly braces. They are mutable and unordered sets of key/value pairs. -->

<!-- ```{python} -->
<!-- favs = {'mary': 'orange', 'john': 'green', 'eric': 'blue'} -->
<!-- print(favs) -->
<!-- print(favs['john']) -->
<!-- print(favs['mary']) -->
<!-- ``` -->

<!-- Now let's see how to add items to a dictionary: -->

<!-- ```{python} -->
<!-- concepts = {} -->
<!-- concepts['list'] = 'An ordered collection of values' -->
<!-- concepts['dictionary'] = 'A collection of key-value pairs' -->
<!-- print(concepts) -->
<!-- ``` -->

<!-- We can modify the values: -->

<!-- ```{python} -->
<!-- concepts['list'] = 'Simple: ' + concepts['list'] -->
<!-- concepts['dictionary'] = 'Complex: ' + concepts['dictionary'] -->
<!-- print(concepts) -->
<!-- ``` -->

<!-- Deleting dictionary pairs: -->

<!-- ```{python} -->
<!-- del concepts['list']      # Removes the key 'list' and its value -->
<!-- print(concepts) -->
<!-- ``` -->

<!-- Values can be numerical: -->

<!-- ```{python} -->
<!-- grades = {} -->
<!-- grades['mary'] = 5 -->
<!-- grades['john'] = 4.5 -->
<!-- print(grades) -->
<!-- ``` -->

<!-- The keys can also be numerical: -->

<!-- ```{python} -->
<!-- grades[1] = 2 -->
<!-- print(grades) -->
<!-- ``` -->

## Collections module

Python has a built-in [collections](https://docs.python.org/3/library/collections.html) module providing the additional data structures: [deque](https://docs.python.org/3/library/collections.html#collections.deque), [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict), [namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple), [OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict), [Counter](https://docs.python.org/3/library/collections.html#collections.Counter), [ChainMap](https://docs.python.org/3/library/collections.html#collections.ChainMap), [UserDict](https://docs.python.org/3/library/collections.html#collections.UserDict), [UserList](https://docs.python.org/3/library/collections.html#collections.UserList), and [UserList](https://docs.python.org/3/library/collections.html#collections.UserString), but we will not cover these in this workshop.
