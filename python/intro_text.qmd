---
title: Playing with text
author: Marie-HÃ©lÃ¨ne Burle
resources: data/pratchett.txt
---

:::{.def}

There are fancy tools to scrape the web and play with text. In preparation for those, in this section, we will download a text file from the internet and play with it using very simple tools.

:::

## Downloading a text file from URL

First, we need to load the [`urllib.request` module](https://docs.python.org/3/library/urllib.request.html#module-urllib.request) from the Python standard library. It contains functions to deal with URLs:

```{python}
import urllib.request
```

The snippet of text we will play with is in a text file containing the very beginning of the novel [Going Postal](https://en.wikipedia.org/wiki/Going_Postal) by [Terry Pratchett](https://en.wikipedia.org/wiki/Terry_Pratchett) and located at the URL <https://mint.westdri.ca/python/data/pratchett.txt>. We can create a variable that we call `url` (we can call it whatever we want) and that contains the string of the URL:

```{python}
url = "https://mint.westdri.ca/python/data/pratchett.txt"
```

```{python}
print(url)
```

```{python}
type(url)
```

To download a text file from a URL, we use the `urllib.request.urlopen` function:

```{python}
urllib.request.urlopen(url)
```

This return an `HTTPResponse` object. It is not very useful in this form, but we can get the text out of it by applying the `read` method:

```{python}
urllib.request.urlopen(url).read()
```

We can save our text in a new variable:

```{python}
encoded_text = urllib.request.urlopen(url).read()
```

Now, `encoded_text` is not of a very convenient type:

```{python}
type(encoded_text)
```

Before we can really start playing with it, we want to convert it to a string by decoding it:

```{python}
text = encoded_text.decode("utf-8")
print(text)
```

The output looks the same, but `text` is a string:

```{python}
type(text)
```

And now we can start playing with the data ðŸ™‚

## Counting things

For instance, we can count the number of occurrences of the name of the main character ("Moist"â€”I know ... what a crazy name):

```{python}
text.count("Moist")
```

Or we could try to see how many words there are in this text.

:::{.exo}

:::{.yourturn}

Your turn:

:::

How would you go about this?

:::

Another method to count the number of words is to use the `split` method:

```{python}
words = text.split()
print(words)
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

What is the type of the variable `words`?

:::

To get its length, we can use the `len` function:

```{python}
len(words)
```

Now, let's try to count how many times the word `the` is in the text.

:::{.exo}

:::{.yourturn}

Your turn:

:::

We could use:

```{python}
text.count("the")
```

but it won't answer our question. Why?

:::

Instead, we should use the list of words that we called `words` and count how many of them are equal to `the`. We do this with a loop:

```{python}
# We set our counter (the number of occurrences) to zero:
occurrences = 0

# And now we can use a loop to test the words one by one and add 1 to our counter each time the equality returns true
for word in words:
    if word == "the":
        occurrences += 1

print(occurrences)        
```

An alternative syntax that looks a lot more elegant is the following:

```{python}
sum(word == "the" for word in words)
```

However, elegance and short syntax don't mean fast code.

We can benchmark Python code very easy when we use Jupyter or IPython by using the magic `%%timeit` at the top of a code cell.

Let's try it:

```{python}
%%timeit

# We set our counter (the number of occurrences) to zero:
occurrences = 0

# And now we can use a loop to test the words one by one and add 1 to our counter each time the equality returns true
for word in words:
    if word == "the":
        occurrences += 1
```

:::{.note}

I removed the `print` function so that we don't end up printing the result a bunch of times: `timeit` does a lot of tests and takes the average. At each run, we would have a printed result!

:::

And for the other method

```{python}
%%timeit

occurrences = sum(word == "the" for word in words)
```

:::{.note}

To make a fair comparison with the previous expression, I am not printing the result here either, but assigning it to a variable.

:::

As you can see, the short neat-looking expression takes more than twice the time of the not so nice-looking one. Without benchmarking, it is very hard to predict what code is efficient.

## Extracting characters from strings

### Indexing

Let's go back to our text. Remember that we have this object `text` which is a list.

```{python}
type(text)
```

You can extract characters from strings by *indexing*.

Indexing in Python is done with square brackets and starts at 0 (the first element has index 0). This means that we can extract the first character with:

```{python}
print(text[0])
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

How would you index the 4^th^ element? Try it out. It should return "y".

:::

You can extract the last element with a minus sign (and this time, the indexing starts at 1):

```{python}
print(text[-1])
```

We aren't getting any output here because the last character is the special character `\n` which encodes for a line break. You can see it when you don't use the `print` function (`print` makes things look nicer and transforms those characters into what they represent):

```{python}
text[-1]
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

**Question 1:** \
How would you get the last letter of the text?

**Question 2:** \
How would you index the 11^th^ element from the end? Give it a try. You should get "V".

:::

### Slicing

You can also extract multiple contiguous elements with a *slice*. A slice is also defined with square brackets, but this time you add a colon in it. Left of the colon is the start of the slice and right of the colon is the end of the slice.

In Python, the left element of a slice is *included*, but the right element is *excluded*.

First, let's omit both indices on either side of the colon:

```{python}
print(text[:])
```

This returns the full text. This is because when a slice boundary is omitted, by default it starts at the very beginning of the object you are slicing.

We can test that we indeed get the full text by comparing it to the non-sliced version of `text`:

```{python}
text[:] == text
```

Now, let's slice the first 10 elements of `text`:

```{python}
print(text[:10])
```

:::{.hnote}

Let's explain this code a bit:

We want our slice to start at the beginning of the text, so we are omitting that boundary (we could also use `0` left of the colon).

Because indexing starts at 0, the 10^th^ element is actually not "t", but the following "h". The reason we get "t" rather than "h" is because the right boundary of a slice is excluded.

:::

:::{.exo}

:::{.yourturn}

Your turn:

:::

**Question 1:** \
Try to write some code that will return "prospect".

<!-- ```{python} -->
<!-- text[18:26] -->
<!-- ``` -->

**Question 2:** \
Now, remember how we created the `words` object earlier? Try to use it to get the same result.

<!-- ```{python} -->
<!-- words[4] -->
<!-- ``` -->

:::

## Striding

A last way to extract characters out of a string is to use *strides*. A stride is defined with square brackets and 3 values separated by colons. The first value is the left boundary (included), the second value is the right boundary (excluded), and the third value is the step. By default (if omitted), the step is 1.

:::{.exo}

:::{.yourturn}

Your turn:

:::

**Question 1:** \
What do you think that `text[::]` would return?

**Question 2:** \
How would you test it?

**Question 3:** \
How would you get every 3^rd^ character of the whole text?

:::

Now, a fun one: the step can also take a negative value. With `-1`, we get the text backward! This is because `-` indicates that we want to step from the end and `1` means that we want every character:

```{python}
print(text[::-1])
```
