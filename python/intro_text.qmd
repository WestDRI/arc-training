---
title: Playing with text
author: Marie-HÃ©lÃ¨ne Burle
resources: data/pratchett.txt
---

:::{.def}

There are fancy tools to scrape the web and play with text. In preparation for those, in this section, we will download a text file from the internet and play with it using very simple tools.

:::

First, we need to load the [`urllib.request` module](https://docs.python.org/3/library/urllib.request.html#module-urllib.request) from the Python standard library. It contains functions to deal with URLs:

```{python}
import urllib.request
```

The snippet of text we will play with is in a text file containing the very beginning of the novel [Going Postal](https://en.wikipedia.org/wiki/Going_Postal) by [Terry Pratchett](https://en.wikipedia.org/wiki/Terry_Pratchett) and located at the URL <https://mint.westdri.ca/python/data/pratchett.txt>. We can create a variable that we call `url` (we can call it whatever we want) and that contains the string of the URL:

```{python}
url = "https://mint.westdri.ca/python/data/pratchett.txt"
```

```{python}
print(url)
```

```{python}
type(url)
```

To download a text file from a URL, we use the `urllib.request.urlopen` function:

```{python}
urllib.request.urlopen(url)
```

This return an `HTTPResponse` object. It is not very useful in this form, but we can get the text out of it by applying the `read` method:

```{python}
urllib.request.urlopen(url).read()
```

We can save our text in a new variable:

```{python}
encoded_text = urllib.request.urlopen(url).read()
```

Now, `encoded_text` is not of a very convenient type:

```{python}
type(encoded_text)
```

Before we can really start playing with it, we want to convert it to a string by decoding it:

```{python}
text = encoded_text.decode("utf-8")
print(text)
```

The output looks the same, but `text` is a string:

```{python}
type(text)
```

And now we can start playing with the data ðŸ™‚

For instance, we can count the number of occurrences of the name of the main character ("Moist"â€”I know ... what a crazy name):

```{python}
text.count("Moist")
```

Or we could try to see how many words there are in this text.

:::{.exo}

:::{.yourturn}

Your turn:

:::

How would you go about this?

:::

Another method to count the number of words is to use the `split` method:

```{python}
words = text.split()
print(words)
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

What is the type of the variable `words`?

:::

To get its length, we can use the `len` function:

```{python}
len(words)
```

Now, let's try to count how many times the word `the` is in the text.

:::{.exo}

:::{.yourturn}

Your turn:

:::

We could use:

```{python}
text.count("the")
```

but it won't answer our question. Why?

:::

Instead, we should use the list of words that we called `words` and count how many of them are equal to `the`. We do this with a loop:

```{python}
# We set our counter (the number of occurrences) to zero:
occurrences = 0

# And now we can use a loop to test the words one by one and add 1 to our counter each time the equality returns true
for word in words:
    if word == "the":
        occurrences += 1

print(occurrences)        
```

An alternative syntax that looks a lot more elegant is the following:

```{python}
sum(word == "the" for word in words)
```

However, elegance and short syntax don't mean fast code.

We can benchmark Python code very easy when we use Jupyter or IPython by using the magic `%%timeit` at the top of a code cell.

Let's try it:

```{python}
%%timeit

# We set our counter (the number of occurrences) to zero:
occurrences = 0

# And now we can use a loop to test the words one by one and add 1 to our counter each time the equality returns true
for word in words:
    if word == "the":
        occurrences += 1
```

:::{.note}

I removed the `print` function so that we don't end up printing the result a bunch of times: `timeit` does a lot of tests and takes the average. At each run, we would have a printed result!

:::

And for the other method

```{python}
%%timeit

occurrences = sum(word == "the" for word in words)
```

:::{.note}

To make a fair comparison with the previous expression, I am not printing the result here either, but assigning it to a variable.

:::

As you can see, the short neat-looking expression takes more than twice the time of the not so nice-looking one. Without benchmarking, it is very hard to predict what code is efficient.
