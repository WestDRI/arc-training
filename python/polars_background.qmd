---
title: The world of data frames
author: Marie-Hélène Burle
---

:::{.def}

Let's talk about data frames, how they came to the world of programming, how Pandas had the monopoly for many years in Python, and how things are changing very quickly at the moment.

:::

## Tabular data

Many fields of machine learning, data science, and humanities rely on tabular data where

- columns hold variables and are homogeneous (same data type),
- rows contain observations and can be heterogeneous.

Early computer options to manipulate such data were limited to [spreadsheets](https://en.wikipedia.org/wiki/Spreadsheet) (e.g. Microsoft Excel).

Dataframes (data frames or DataFrames) are two dimensional objects that brought tabular data to programming.

## Early history of dataframes

After data frames emerged in S, then R, they were added to Python with the library [Pandas](https://pandas.pydata.org/) in 2008.

```{dot}
//| echo: false
//| fig-height: 250px

strict graph {
  
bgcolor="transparent"
graph [fontname="Inconsolata, sans-serif"]
node [fontname="Inconsolata, sans-serif", fontsize=15]

y1 [label=1990, shape=plaintext, group=g1, group=g1]
y2 [label=2000, shape=plaintext, group=g1, group=g1]
y3 [label=2008, shape=plaintext, group=g1]

l1 [label="S programming language", href="https://en.wikipedia.org/wiki/S_(programming_language)", shape=plaintext, group=g2, fontcolor="#5592FD"]
l2 [label="R", href="https://en.wikipedia.org/wiki/R_(programming_language)", shape=plaintext, group=g2, fontcolor="#5592FD"]
l3 [label="Pandas (Python)", href="https://en.wikipedia.org/wiki/Pandas_(software)", shape=plaintext, group=g2, fontcolor="#5592FD"]

{rank=same; y1 l1}

y1 -- y2 -- y3
l1 -- l2 -- l3 [style=invis]

}
```

The world was simple ... but slow with high memory usage and it remains thus for a long time.

## Issues with Pandas

While Pandas was *the* Python data frame library and is now at the core of many other libraries, [Wes McKinney](https://wesmckinney.com/) (pandas creator) himself [has complaints about it](https://wesmckinney.com/blog/apache-arrow-pandas-internals/), mostly:

- the internals are too far from the hardware,
- no support for memory-mapped datasets,
- poor performance in database and file ingest / export,
- lack of proper support for missing data,
- lack of memory use and RAM management transparency,
- weak support for categorical data,
- `groupby` operations are complex, awkward, and slow,
- appending data to a DataFrame tedious and very costly,
- limited, non-extensible type metadata,
- eager evaluation model with no query planning,
- slow and limited multicore algorithms for large datasets.

## A rich new field

After years of Pandas as *the* Python dataframe library, there is currently an exuberant explosion of faster alternatives.

### Parallel computing

The Python [global interpreter lock (GIL)](https://en.wikipedia.org/wiki/Global_interpreter_lock) gets in the way of multi-threading.

Libraries such as [Ray](https://github.com/ray-project/ray), [Dask](https://github.com/dask/dask), and [Apache Spark](https://github.com/apache/spark) allow the use of multiple cores and bring dataframes to clusters.

Dask and Spark have APIs for Pandas and [Modin](https://docs.ray.io/en/latest/ray-more-libs/modin/index.html) makes this even more trivial by providing a drop-in replacement for Pandas on Dask, Spark, and Ray.

[fugue](https://github.com/fugue-project/fugue/) provides a unified interface for distributed computing that works on Spark, Dask, and Ray.

### Accelerators

[RAPIDS](https://rapids.ai/) brings dataframes on the GPUs with the [cuDF library](https://github.com/rapidsai/cudf).

Integration with pandas is easy.

### Lazy out-of-core

[Vaex](https://github.com/vaexio/vaex) exists as an alternative to pandas.

### SQL

[Structured query language (SQL)](https://en.wikipedia.org/wiki/SQL) handles [relational databases](https://en.wikipedia.org/wiki/Relational_database), but the distinction between SQL and dataframe software is getting increasingly blurry with most libraries now able to handle both.

[DuckDB](https://github.com/duckdb/duckdb) is a very fast and popular option with good integration with pandas.

Many additional options such as [dbt](https://github.com/dbt-labs/dbt-core) and the [snowflake snowpark Python API](https://github.com/snowflakedb/snowpark-python) exist, although integration with pandas is not always as good.

## Polars

And then came [Polars](https://pola.rs/).

The new memory standard is [Apache Arrow](https://arrow.apache.org/) and the most efficient library making use of it is Polars.

In addition, most libraries are developing an integration with Polars, making it harder and harder to still find reasons to use Pandas.

For maximum dataframe efficiency, the best strategy currently seems to be:

- single machine&nbsp; ➔ &nbsp;use Polars,
- cluster&nbsp; ➔ &nbsp;use Polars + [fugue](https://github.com/fugue-project/fugue/) ([example benchmark](https://medium.com/fugue-project/benchmarking-pyspark-pandas-pandas-udfs-and-fugue-polars-198c3109a226), [documentation of Polars integration](https://fugue-tutorials.readthedocs.io/tutorials/integrations/backends/polars.html)),
- GPUs available&nbsp; ➔ &nbsp;use Polars + [RAPIDS](https://rapids.ai/) library [cuDF](https://github.com/rapidsai/cudf) ([Polars integration coming soon](https://pola.rs/posts/polars-on-gpu/)),
- SQL&nbsp; ➔ &nbsp;use Polars + [DuckDB](https://github.com/duckdb/duckdb) ([documentation of Polars integration](https://duckdb.org/docs/guides/python/polars.html)),
- combination of the above (e.g. cluster with GPUs)&nbsp; ➔ &nbsp;use a combination of the above tools (e.g. Polars + fugue + RAPIDS).
