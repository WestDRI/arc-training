---
title: Collections
aliases:
  - collections.html
author: Marie-HÃ©lÃ¨ne Burle
---

:::{.def}

Values can be stored in collections. This section introduces tuples, dictionaries, sets, and arrays in Python.

:::

## Lists

Lists are declared in square brackets:

```{python}
l = [2, 1, 3]
```

```{python}
type(l)
```

They are ordered:

```{python}
['b', 'a'] == ['a', 'b']
```

They can have repeat values:

```{python}
['a', 'a', 'a', 't']
```

They can be homogeneous:

```{python}
['b', 'a', 'x', 'e']
```

```{python}
type('b') == type('a') == type('x') == type('e')
```

or heterogeneous:

```{python}
[3, 'some string', 2.9, 'z']
```

```{python}
type(3) == type('some string') == type(2.9) == type('z')
```

They can even be nested:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

The length of a list is the number of items it contains and can be obtained with the function `len`:

```{python}
len([3, ['b', 'e', 3.9, ['some string', 9.9]], 8])
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

What are the 3 elements of this list? \
What are their respective types?

:::

To extract an item from a list, you index it:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][0]
```

:::{.note}

Python starts indexing at `0`, so what we tend to think of as the "first" element of a list is for Python the "zeroth" element.

:::

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][1]
```

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][2]
```

Of course you can't extract items that don't exist:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][3]
```

You can index from the end of the list with negative values (here you start at `-1` for the last element):

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][-1]
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

How could you extract the string `'some string'` from the list:

```{.python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

:::

You can also slice a list:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8][0:1]
```

:::{.note}

Notice how slicing returns a list. \
Notice also how the left index is included but the right index excluded.

:::

If you omit the first index, the slice starts at the beginning of the list:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][:6]
```

If you omit the second index, the slice goes to the end of the list:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][6:]
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

From the list:

```{.python}
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Extract the list `[4, 5, 6]`.

:::

When slicing, you can specify the stride (the step size):

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][2:7:2]
```

:::{.notenoit}

The default stride is `1`:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][2:7] == [1, 2, 3, 4, 5, 6, 7, 8, 9][2:7:1]
```

:::

You can reverse the order of a list with a `-1` stride applied on the whole list:

```{python}
[1, 2, 3, 4, 5, 6, 7, 8, 9][::-1]
```

You can test whether an item is in a list:

```{python}
3 in [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

```{python}
9 in [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

or not in a list:

```{python}
3 not in [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

You can get the index (position) of an item inside a list:

```{python}
[3, ['b', 'e', 3.9, ['some string', 9.9]], 8].index(3)
```

:::{.notenoit}

Note that this only returns the index of the first occurrence:

```{python}
[3, 3, ['b', 'e', 3.9, ['some string', 9.9]], 8].index(3)
```

:::

Lists are mutable (they can be modified), so you can replace items in a list by other items:

```{python}
L = [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
```

```{python}
L[1] = 2
print(L)
```

You can delete items from a list using their indices with `list.pop`:

```{python}
L.pop(2)
print(L)
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Why is `2` still in the list after using `L.pop(2)`?

:::

or with `del`:

```{python}
del L[0]
print(L)
```

:::{.notenoit}

Notice how a list can have a single item:

```{python}
len(L)
```

It is then called a "singleton list".

:::

You can also delete items from a list using their values with `list.remove`:

```{python}
L.remove(2)
L
```

:::{.note}

Here, because we are using `list.remove`, `2` represents the value `2`, not the index.

:::

:::{.notenoit}

Notice how a list can even be empty:

```{python}
len(L)
```

You can actually initialise empty lists:

```{python}
M = []
type(M)
```

:::

You can add items to a list. One at a time as we saw at the top of this page:

```{python}
L.append(7)
print(L)
```

And if you want to add multiple items at once?


```{python}
# This doesn't work...
L.append(3, 6, 9)
```

```{python}
# This doesn't work either (that's not what we wanted)
L.append([3, 6, 9])
print(L)
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Fix this mistake we just made and delete the nested list `[3, 6, 9]`.

:::

To add multiple values to a list (and not a nested list), you need to use `list.extend`:

```{python}
L.extend([3, 6, 9])
print(L)
```

If you don't want to add an item at the end of a list, you can use `list.insert(<index>, <object>)`.

:::{.exo}

:::{.yourturn}

Your turn:

:::

Between which elements will `'test'` be inserted?

:::

You can sort homogeneous lists:

```{python}
L = [3, 9, 10, 0]
L.sort()
print(L)
```

```{python}
L = ['some string', 'b', 'a']
L.sort()
print(L)
```

:::{.notenoit}

Heterogeneous lists cannot be sorted:

```{python}
L = [3, ['b', 'e', 3.9, ['some string', 9.9]], 8]
L.sort()
```

:::

You can also get the min and max value of homogeneous lists:

```{python}
min([3, 9, 10, 0])
```

```{python}
max(['some string', 'b', 'a'])
```

:::{.notenoit}

For heterogeneous lists, this also doesn't work:

```{python}
min([3, ['b', 'e', 3.9, ['some string', 9.9]], 8])
```

:::

Lists can be concatenated with `+`:

```{python}
L + [3, 6, 9]
```

or repeated with `*`:

```{python}
L * 3
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Do you remember this exercise from [an earlier section](intro_objects#assignment)?

:::{.notenoit}

```{.python}
a = 1
b = a
a = 2
```

What do you think the value of `b` is now?

:::

Here is a new exercise for you:

```{.python}
a = [0, 1, 2]
b = a
a.append(3)
```

What do you think the value of `b` is now?

:::

:::{.callout-note collapse="true"}

## Explanation

Wait, what? ðŸ˜µ

This is because, in Python, a scalar (an object with a single value) is immutable, meaning that you can't change its value.

So in the first example, when we run `a = 2`, we are creating a new object (because the value of the initial object cannot be changed).

Lists however are mutable. So when we run `a.append(3)`, we are not creating a new object. Instead we are modifying the existing object. Since both `a` and `b` point to that object, if the object changes, the value of both `a` and `b` changes.

In this case, if you want to create a copy, you have to use the [`copy` function from the `copy` module](https://docs.python.org/3/library/copy.html) (we will talk about modules [later in the course](intro_pkg)):

```{python}
import copy

a = [0, 1, 2]
b = a.copy()
a.append(3)

print(b)
```

:::

:::{.info}

To sum up, lists are declared in square brackets. They are mutable, ordered (thus indexable), and possibly heterogeneous collections of values.

:::

### List comprehensions

[List comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) allow to create lists by applying a function to or testing a condition on each element of iterables.

:::{.example}

Examples:

:::

Create a new list by applying a function to each element of a first list:

```{python}
l = [-3, 5, -2, 0, 9]
l2 = [x**2 for x in l]
print(l2)
```

Create a new list by testing a condition on each element of a first list:

```{python}
l3 = [x for x in l if x<=0]
print(l3)
```

Create a new list by applying a function to each element of a first list matching a condition:

```{python}
l4 = [x**2 for x in l if x<=0]
print(l4)
```

Flatten a list with two `for` statements:

```{python}
nested_l = [[1, 2], [3], [4, 5, 6]]
flat_l = [x for y in nested_l for x in y]
print(flat_l)
```

By adding more `for` statements, you can flatten more deeply nested lists:

```{python}
l = [[[3, 4], [4]]]
[x for y in l for z in y for x in z]
```

### Strings

Strings behave (a little) like lists of characters in that they have a length (the number of characters):

```{python}
S = 'This is a string.'
len(S)
```

They have a min and a max:

```{python}
min(S)
```

```{python}
max(S)
```

You can index them:

```{python}
S[3]
```

Slice them:

```{python}
S[10:16]
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Reverse the order of the string `S`.

:::

They can also be concatenated with `+`:

```{python}
T = 'This is another string.'
print(S + ' ' + T)
```

or repeated with `*`:

```{python}
print(S * 3)
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Modify the last expression to have spaces after the periods.

:::

This is where the similarities stop however: methods such as `list.sort`, `list.append`, etc. will not work on strings.

```{python}
S.append('This will fail.')
```

## Arrays

Python comes with a built-in [array](https://docs.python.org/3/library/array.html) module. When you need arrays for storing and retrieving data, this module is perfectly suitable and extremely lightweight. [This tutorial](https://www.softwaretestinghelp.com/how-to-use-python-array/) covers the syntax in detail.

Whenever you plan on performing calculations on your data however (which is the vast majority of cases), you should instead use the [NumPy](https://numpy.org/) package. We will talk about NumPy briefly [in another section](intro_numpy).

## Tuples

Tuples are defined with parentheses:

```{python}
t = (3, 1, 4, 2)
```

```{python}
type(t)
```

They are ordered:

```{python}
(2, 3) == (3, 2)
```

This means that they are indexable and sliceable:

```{python}
(2, 4, 6)[2]
```

```{python}
(2, 4, 6)[::-1]
```

They can be nested:

```{python}
type((3, 1, (0, 2)))
```

```{python}
len((3, 1, (0, 2)))
```

```{python}
max((3, 1, 2))
```

They can be heterogeneous:

```{python}
type(('string', 2, True))
```

You can create empty tuples:

```{python}
type(())
```

You can also create singleton tuples, but the syntax is a bit odd:

```{python}
# This is not a tuple...
type((1))
```

```{python}
# This is the weird way to define a singleton tuple
type((1,))
```

However, the big difference with lists is that tuples are **immutable**:

```{python}
T = (2, 5)
T[0] = 8
```

Tuples are quite fascinating:

```{python}
a, b = 1, 2
print(a, b)
```

```{python}
a, b = b, a
print(a, b)
```

:::{.info}

Tuples are declared in parentheses. They are immutable, ordered (thus indexable), and possibly heterogeneous collections of values.

:::

## Sets

Sets are declared in curly braces:

```{python}
s = {3, 2, 5}
```

```{python}
type(s)
```

They are unordered:

```{python}
{2, 4, 1} == {4, 2, 1}
```

Consequently, it makes no sense to index a set:

```{python}
s[0]
```

Sets can be heterogeneous:

```{python}
S = {2, 'a', 'string'}
isinstance(S, set)
```

```{python}
type(2) == type('a') == type('string')
```

There are no duplicates in a set:

```{python}
{2, 2, 'a', 2, 'string', 'a'}
```

You can define an empty set, but only with the `set` function (because empty curly braces define a dictionary as we will see below):

```{python}
t = set()
```

```{python}
len(t)
```

```{python}
type(t)
```

Since strings an iterables, you can use `set` to get a set of the unique characters:

```{python}
set('abba')
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

How could you create a set with the single element `'abba'` in it?

:::

:::{.info}

Sets are declared in curly brackets. They are mutable, unordered (thus non indexable), possibly heterogeneous collections of unique values.

:::

## Dictionaries

Dictionaries are also declared in curly braces. They associate values to keys:

```{python}
d = {'key1': 'value1', 'key2': 'value2'}
```

```{python}
type(d)
```

The key/value pairs are unique:

```{python}
{'key1': 'value1', 'key2': 'value2', 'key1': 'value1'}
```

They are unordered:

```{python}
{'a': 1, 'b': 2} == {'b': 2, 'a': 1}
```

Consequently, the pairs themselves cannot be indexed:

```{python}
d[0]
```

However, you can access values from their keys:

```{python}
D = {'c': 1, 'a': 3, 'b': 2}
D['b']
```

or:

```{python}
D.get('b')
```

There are methods to get the items (the pairs), the values, or the keys:

```{python}
D.items()
```

```{python}
D.values()
```

```{python}
D.keys()
```

To return a sorted list of keys:

```{python}
sorted(D)
```

You can create empty dictionaries:

```{python}
E = {}
type(E)
```

Dictionaries are mutable, so you can add, remove, or replace items.

Let's add an item to our empty dictionary `E`:

```{python}
E['author'] = 'Proust'
print(E)
```

We can add another one:

```{python}
E['title'] = 'In search of lost time'
print(E)
```

We can modify one:

```{python}
E['author'] = 'Marcel Proust'
E
```

:::{.exo}

:::{.yourturn}

Your turn:

:::

Add a third item to `E` with the number of volumes.

:::

We can also remove items:

```{python}
E.pop('author')
print(E)
```

or:

```{python}
del E['title']
print(E)
```

:::{.info}

Dictionaries are declared in curly braces. They are mutable and unordered collections of unique key/value pairs. They play the role of an associative array.

:::

## Conversion between collections

From tuple to list:

```{python}
list((3, 8, 1))
```

From tuple to set:

```{python}
set((3, 2, 3, 3))
```

From list to tuple:

```{python}
tuple([3, 1, 4])
```

From list to set:

```{python}
set(['a', 2, 4])
```

From set to tuple:

```{python}
tuple({2, 3})
```

From set to list:

```{python}
list({2, 3})
```


## Collections module

Python has a built-in [collections](https://docs.python.org/3/library/collections.html) module providing the additional much more niche data structures: [deque](https://docs.python.org/3/library/collections.html#collections.deque), [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict), [namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple), [OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict), [Counter](https://docs.python.org/3/library/collections.html#collections.Counter), [ChainMap](https://docs.python.org/3/library/collections.html#collections.ChainMap), [UserDict](https://docs.python.org/3/library/collections.html#collections.UserDict), [UserList](https://docs.python.org/3/library/collections.html#collections.UserList), and [UserList](https://docs.python.org/3/library/collections.html#collections.UserString).
