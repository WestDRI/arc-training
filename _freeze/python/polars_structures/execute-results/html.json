{
  "hash": "2e99ac58d07c62736e6f82649eec9064",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Data structures\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nPolars provides two fundamental data structures: Series and DataFrames.\n\n:::\n\n## Series\n\nIn Polars, **Series are one-dimensional and homogeneous** (all elements have the same data type).\n\n:::{.note}\n\nIn other frameworks or languages (e.g. pandas, R), such data structure would be called a *vector*.\n\n:::\n\n::: {#810c1731 .cell execution_count=2}\n``` {.python .cell-code}\nimport polars as pl\n\ns1 = pl.Series(range(5))\nprint(s1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (5,)\nSeries: '' [i64]\n[\n\t0\n\t1\n\t2\n\t3\n\t4\n]\n```\n:::\n:::\n\n\n### Data types\n\nPolars infers data types from the data. Defaults are Int64 and Float64. For other options, you can create typed Series by specifying the type:\n\n::: {#115c4ee6 .cell execution_count=3}\n``` {.python .cell-code}\ns2 = pl.Series(range(5), dtype=pl.Int32)\nprint(s2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (5,)\nSeries: '' [i32]\n[\n\t0\n\t1\n\t2\n\t3\n\t4\n]\n```\n:::\n:::\n\n\n### Named Series\n\nSeries can be named:\n\n::: {#527102da .cell execution_count=4}\n``` {.python .cell-code}\ns3 = pl.Series(\"Name\", [\"Bob\", \"Luc\", \"Lucy\"])\nprint(s3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (3,)\nSeries: 'Name' [str]\n[\n\t\"Bob\"\n\t\"Luc\"\n\t\"Lucy\"\n]\n```\n:::\n:::\n\n\n## DataFrames\n\nDataFrames are **two-dimensional and composed of named Series of equal lengths**. This means that DataFrames are heterogeneous, but that columns contain homogeneous data.\n\nThey can be created from:\n\n- lists of Series:\n\n::: {#f02a0e53 .cell execution_count=5}\n``` {.python .cell-code}\ndf1 = pl.DataFrame([s3, pl.Series(\"Colour\", [\"Red\", \"Green\", \"Blue\"])])\nprint(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (3, 2)\n┌──────┬────────┐\n│ Name ┆ Colour │\n│ ---  ┆ ---    │\n│ str  ┆ str    │\n╞══════╪════════╡\n│ Bob  ┆ Red    │\n│ Luc  ┆ Green  │\n│ Lucy ┆ Blue   │\n└──────┴────────┘\n```\n:::\n:::\n\n\n- dictionaries:\n\n::: {#b1ec7695 .cell execution_count=6}\n``` {.python .cell-code}\nfrom datetime import date\n\ndf2 = pl.DataFrame(\n    {\n        \"Date\": [\n            date(2024, 10, 1),\n            date(2024, 10, 2),\n            date(2024, 10, 3),\n            date(2024, 10, 6)\n        ],\n        \"Rain\": [2.1, 0.5, 0.0, 1.8],\n        \"Cloud cover\": [1, 1, 0, 2]\n        }\n    )\nprint(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (4, 3)\n┌────────────┬──────┬─────────────┐\n│ Date       ┆ Rain ┆ Cloud cover │\n│ ---        ┆ ---  ┆ ---         │\n│ date       ┆ f64  ┆ i64         │\n╞════════════╪══════╪═════════════╡\n│ 2024-10-01 ┆ 2.1  ┆ 1           │\n│ 2024-10-02 ┆ 0.5  ┆ 1           │\n│ 2024-10-03 ┆ 0.0  ┆ 0           │\n│ 2024-10-06 ┆ 1.8  ┆ 2           │\n└────────────┴──────┴─────────────┘\n```\n:::\n:::\n\n\n- NumPy ndarrays:\n\n::: {#81849a0b .cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\n\ndf3 = pl.DataFrame(np.array([(1, 2), (3, 4)]))\nprint(df3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (2, 2)\n┌──────────┬──────────┐\n│ column_0 ┆ column_1 │\n│ ---      ┆ ---      │\n│ i64      ┆ i64      │\n╞══════════╪══════════╡\n│ 1        ┆ 2        │\n│ 3        ┆ 4        │\n└──────────┴──────────┘\n```\n:::\n:::\n\n\nBecause NumPy ndarrays are stored in memory by rows, the values in the first dimension of the array fill in the first row. If you want to fill in the DataFrame by column, you use the `orient` parameter:\n\n::: {#6ef9c6b4 .cell execution_count=8}\n``` {.python .cell-code}\ndf4 = pl.DataFrame(np.array([(1, 2), (3, 4)]), orient=\"col\")\nprint(df4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (2, 2)\n┌──────────┬──────────┐\n│ column_0 ┆ column_1 │\n│ ---      ┆ ---      │\n│ i64      ┆ i64      │\n╞══════════╪══════════╡\n│ 1        ┆ 3        │\n│ 2        ┆ 4        │\n└──────────┴──────────┘\n```\n:::\n:::\n\n\nTo specify column names, you can use the schema parameter:\n\n::: {#4a3e37d1 .cell execution_count=9}\n``` {.python .cell-code}\ndf5 = pl.DataFrame(np.array([(1, 2), (3, 4)]), schema=[\"Var1\", \"Var2\"])\nprint(df5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (2, 2)\n┌──────┬──────┐\n│ Var1 ┆ Var2 │\n│ ---  ┆ ---  │\n│ i64  ┆ i64  │\n╞══════╪══════╡\n│ 1    ┆ 2    │\n│ 3    ┆ 4    │\n└──────┴──────┘\n```\n:::\n:::\n\n\n### Data types\n\nTo specify data types different from the default, you also use the schema parameter:\n\n::: {#cd1aa6de .cell execution_count=10}\n``` {.python .cell-code}\ndf6 = pl.DataFrame(\n    {\n        \"Rain\": [2.1, 0.5, 0.0, 1.8],\n        \"Cloud cover\": [1, 1, 0, 2],\n    },\n    schema={\"Rain\": pl.Float32, \"Cloud cover\": pl.Int32}\n)\nprint(df6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape: (4, 2)\n┌──────┬─────────────┐\n│ Rain ┆ Cloud cover │\n│ ---  ┆ ---         │\n│ f32  ┆ i32         │\n╞══════╪═════════════╡\n│ 2.1  ┆ 1           │\n│ 0.5  ┆ 1           │\n│ 0.0  ┆ 0           │\n│ 1.8  ┆ 2           │\n└──────┴─────────────┘\n```\n:::\n:::\n\n\n",
    "supporting": [
      "polars_structures_files"
    ],
    "filters": [],
    "includes": {}
  }
}