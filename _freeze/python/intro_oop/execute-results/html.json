{
  "hash": "25f5c6019cadf92eb40c286e2db5cce5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Object-oriented programming\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nPython is a flexible language that can be written using various programming styles. Different paradigms can be used in different parts of the same code to suit specific needs.\n\nSo far in this course, we have focused on procedural programming. In this section, I will briefly talk about the various programming paradigms in Python, then focus on a very common style: object-oriented programming.\n\n:::\n\n## Programming paradigms in Python\n\n### Imperative programming\n\nIn [imperative programming](https://en.wikipedia.org/wiki/Imperative_programming), the code follows an [execution flow](https://en.wikipedia.org/wiki/Control_flow) and the state of a program changes throughout its execution.\n\nThis is the paradigm most commonly used in Python and the one you are most likely to be familiar with.\n\n#### Procedural programming\n\n[Procedural programming](https://en.wikipedia.org/wiki/Procedural_programming) is a subtype of imperative programming widely used for simple, top-down sets of instructions. The focus is on procedures (functions) that operate on data.\n\nSmall scripts, task automation, and data analyses often rely on procedural programming. This is what we have covered in this course so far.\n\n#### Object-oriented programming\n\nIn [object-oriented programming (OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming), the code is organized around objects which are instances of classes and bundle together data (attributes) and behaviour (methods). This reduces the amount of code that needs to be written thanks to the property of inheritance. It also hides parts of the code that doesn't need to be exposed.\n\nWeb applications, software development, and complex code such as can be seen in deep learning rely on OOP, making it probably the most common programming style in Python outside of data science.\n\n### Declarative programming\n\n[Declarative programming](https://en.wikipedia.org/wiki/Declarative_programming) does not rely on state changes or control flow, but instead on formal logic.\n\n#### Functional programming\n\n[Functional programming](https://en.wikipedia.org/wiki/Functional_programming) is the subset of declarative programming that can be used in Python. It relies on [pure functions](https://en.wikipedia.org/wiki/Pure_function) without side effects.\n\nThis is a restrictive style, but it has the benefits of being more readable, easier to maintain, and promotes better code modularity and reusability.\n\nIf you ever want to use [JAX](https://docs.jax.dev/en/latest/beginner_guide.html#beginner-guide)—a Python library for high-performance array computing, you will have to write functional programming code.\n\n## OOP in Python\n\nObject-oriented programming allows to create objects with attributes and methods.\n\nFirst you define a [class]{.emph} which works as the blueprint for those objects, then you instantiate individual objects from that class. Those objects are called [instances]{.emph}.\n\nThis is very convenient in a number of situations. For instance, in deep learning, most frameworks define model classes and you create a model as an instance of one of these classes. The data is also often packaged in a Dataset class which contains methods convenient to access individual samples.\n\n### Defining classes\n\nBy convention, classes names are capitalized (and compound class names use TheCamelCase notation). You define a class with the `class` keyword:\n\n::: {#4cf2281b .cell execution_count=2}\n``` {.python .cell-code}\nclass Attendee:\n    # Class attributes (same for all instances of the class)\n    topic = \"Programming\"\n    language = \"Python\"\n    level = \"Intro\"\n\n    # Instance attributes (specific to each instance)\n    def __init__(self, name, email):\n        self.name =  name\n        self.email = email\n\n    # Instance methods\n    def introduce(self):\n        return f\"My name is {self.name}.\"\n\n    def goal(self, goal_description):\n        return f\"I want to learn Python {goal_description}.\"\n```\n:::\n\n\n`__init__` is called a dunder (double underscore), special method, or magic method. To get the list of all dunders, you can run:\n\n::: {#2d3b6e00 .cell execution_count=3}\n``` {.python .cell-code}\nprint(dir(int))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']\n```\n:::\n:::\n\n\nHere is an example [from one of my deep learning courses](/ai/jxai/jxai_preprocess#final-dataset-class.qmd) on how to define a dataset class:\n\n```{.python}\nclass NABirdsDataset:\n    \"\"\"NABirds dataset class.\"\"\"\n    def __init__(self, metadata, data_dir):\n        self.metadata = metadata\n        self.data_dir = data_dir\n\n    def __len__(self):\n        return len(self.metadata)\n\n    def __getitem__(self, idx):\n        path = os.path.join(self.data_dir, self.metadata.get_column('path')[idx])\n        img = iio.imread(path)\n        species_name = self.metadata.get_column('species_name')[idx]\n        species_id = self.metadata.get_column('species_id')[idx]\n        photographer = self.metadata.get_column('photographer')[idx]\n        element = {\n            'img': img,\n            'species_name': species_name,\n            'species_id': species_id,\n            'photographer': photographer,\n        }\n\n        return element\n```\n\n:::{.note}\n\nNote the use of dunders to set the methods here. When a dunder already exists, you don't have to define the method yourself. `__len__` is a method that allows us to get the length of the dataset and `__getitem__` allows us to get samples from it.\n\n:::\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n- How many class attributes does this class have? \\\n- How many instance attributes? \\\n- How many methods?\n\n:::\n\n### Instantiating objects\n\nTo create an instance of a class, you run the class name followed by parentheses. If it doesn't have instance attributes, you don't pass anything between the parentheses. If it does, you pass the attributes as arguments.\n\nIn our case, we have 2 instance attributes, so we need to pass to arguments to create instances:\n\n::: {#04b04737 .cell execution_count=4}\n``` {.python .cell-code}\nattendee1 = Attendee(\"Alex\", \"alex@email.com\")\nattendee2 = Attendee(\"Marie\", \"marie@email.com\")\n```\n:::\n\n\n`attendee1` and  `attendee2` are instances of the class `Attendee`.\n\n::: {#ec339f87 .cell execution_count=5}\n``` {.python .cell-code}\nprint(attendee1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.Attendee object at 0x7f515ad93620>\n```\n:::\n:::\n\n\n### Using instances\n\nYou can get attributes:\n\n::: {#e6bb529f .cell execution_count=6}\n``` {.python .cell-code}\nprint(attendee1.topic)\nprint(attendee1.name)\nprint(attendee1.email)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProgramming\nAlex\nalex@email.com\n```\n:::\n:::\n\n\nAnd use the methods:\n\n::: {#0897d4d0 .cell execution_count=7}\n``` {.python .cell-code}\nprint(attendee1.introduce())\nprint(attendee1.goal(\"to teach it\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy name is Alex.\nI want to learn Python to teach it.\n```\n:::\n:::\n\n\n### Inheritance\n\nClasses can inherit attributes and methods from another class. The initial class is called a *superclass*, *parent class*, or *base class*. The class that inherits from it is called a *subclass*, or *child class*. This is a useful way to recycle code.\n\nFor instance, when you define a Model class in most frameworks, you will define it as a subclass of some superclass defined in the framework of your choice.\n\nHere is an example from [a JAX tutorial](https://docs.jaxstack.ai/en/latest/neural_net_basics.html#defining-the-flax-model):\n\n```{.python}\n# nnx.Module is the superclass\n# SimpleNN is the subclass\nclass SimpleNN(nnx.Module):\n\n    # Instance attributes\n    def __init__(self, n_features: int = 64, n_hidden: int = 100, n_targets: int = 10,\n                 *, rngs: nnx.Rngs):\n        self.n_features = n_features\n        self.layer1 = nnx.Linear(n_features, n_hidden, rngs=rngs)\n        self.layer2 = nnx.Linear(n_hidden, n_hidden, rngs=rngs)\n        self.layer3 = nnx.Linear(n_hidden, n_targets, rngs=rngs)\n\n    # Method for the forward pass\n    def __call__(self, x):\n        x = x.reshape(x.shape[0], self.n_features)\n        x = nnx.selu(self.layer1(x))\n        x = nnx.selu(self.layer2(x))\n        x = self.layer3(x)\n        return x\n```\n\nThis makes the code very lean: the `nnx.Module` from the Flax library already contains all the attributes and behaviours that you want for a Model class. All you have to do is to overwrite a handful of them to fit your particular needs.\n\nWith our example of a the class Attendee, we could create a subclass for another course by overwriting a handful of sections while keeping the rest as is:\n\n::: {#b7939d49 .cell execution_count=8}\n``` {.python .cell-code}\nclass NewAttendee(Attendee):\n    language = \"Julia\"\n\n    def goal(self, goal_description):\n        return f\"I want to learn Julia {goal_description}.\"\n```\n:::\n\n\n:::{.note}\n\nNote how we don't have to define what we are happy to inherit from the superclass. This is efficient code recycling.\n\n:::\n\n::: {#d23551ae .cell execution_count=9}\n``` {.python .cell-code}\nnew_attendee = NewAttendee(\"Eric\", \"eric@email.com\")\n```\n:::\n\n\n::: {#32b411d1 .cell execution_count=10}\n``` {.python .cell-code}\nprint(new_attendee.topic)\nprint(new_attendee.language)\nprint(new_attendee.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProgramming\nJulia\nEric\n```\n:::\n:::\n\n\n::: {#2bc15da3 .cell execution_count=11}\n``` {.python .cell-code}\nprint(new_attendee.introduce())\nprint(new_attendee.goal(\"because it is fast\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy name is Eric.\nI want to learn Julia because it is fast.\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCreate a subclass of `Attendee` for an advanced Python course.\n\n:::\n\n",
    "supporting": [
      "intro_oop_files"
    ],
    "filters": [],
    "includes": {}
  }
}