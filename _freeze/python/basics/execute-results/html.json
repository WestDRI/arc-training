{
  "hash": "4d71278a6c218e4f560fa56de43e2b49",
  "result": {
    "markdown": "---\ntitle: Python basics\n---\n\n## Documentation\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nhelp(round)            # In Jupyter, you can also use: ?round\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on built-in function round in module builtins:\n\nround(number, ndigits=None)\n    Round a number to a given precision in decimal digits.\n    \n    The return value is an integer if ndigits is omitted or None.  Otherwise\n    the return value has the same type as the number.  ndigits may be negative.\n\n```\n:::\n:::\n\n\n## Variables and assignments\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nage = 20\nfirstName = 'Jason'\nprint(firstName, 'is', age, 'years old')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJason is 20 years old\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\na = 1; b = 2              # You can use ; to separate multiple commands in one line\na, b = 1, 2               # You can define multiple variables at once\na = b = 10                # You can assign a value to multiple variables at the same time\nb = \"b is now a string\"   # Variables can change type\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nage += 3                                   # Another syntax for: age = age + 3\nprint(\"Jason's age in three years:\", age)  # Note that we have to use double quotes here\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJason's age in three years: 23\n```\n:::\n:::\n\n\n{{<exo>}}\nWhat is the final value of the variable `b` in the following code?\n{{</exo>}}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\na = \"left\"\nb = a\na = \"right\"\n```\n:::\n\n\n## Types\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(type(52))\nprint(type(52.0))\nprint(type('52'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'int'>\n<class 'float'>\n<class 'str'>\n```\n:::\n:::\n\n\n## Strings\n\nUse square brackets to get a substring:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nelement = 'helium'\nprint(element[0])\nprint(element[0:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh\nhel\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nname = 'Paul'\nprint(name+' Smith')   # You can add strings\nprint(name*10)         # You can replicate strings by mutliplying by a number\nprint(len(name))       # Strings have lengths\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPaul Smith\nPaulPaulPaulPaulPaulPaulPaulPaulPaulPaul\n4\n```\n:::\n:::\n\n\n## Lists\n\nA list is a collection of multiple values. This means that multiple values are stored within a single object.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nT = [27.3, 27.5, 27.7, 27.5, 27.6]\nprint('temperature:', T)\nprint('length:', len(T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntemperature: [27.3, 27.5, 27.7, 27.5, 27.6]\nlength: 5\n```\n:::\n:::\n\n\nPython starts indexing at `0`:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint('zeroth item of T is', T[0])\nprint('fourth item of T is', T[4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nzeroth item of T is 27.3\nfourth item of T is 27.6\n```\n:::\n:::\n\n\nLists are mutable (they can be modified):\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nT[0] = 21.3\nprint('temperature is now:', T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntemperature is now: [21.3, 27.5, 27.7, 27.5, 27.6]\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\na = [2, 3, 5]\nprint('a is initially', a)\na.append(7)\na.append(11)\nprint('a has become', a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na is initially [2, 3, 5]\na has become [2, 3, 5, 7, 11]\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nprint('a before', a)\ndel a[4]                 # Remove 4th element\nprint('a after', a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na before [2, 3, 5, 7, 11]\na after [2, 3, 5, 7]\n```\n:::\n:::\n\n\nYou can initialize an empty list and fill it in:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\na = []                   # Start with an empty list\na.append('Vancouver')\na.append('Toronto')\na.append('Kelowna')\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Vancouver', 'Toronto', 'Kelowna']\n```\n:::\n:::\n\n\nLists can be heterogeneous and nested:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\na = [11, 21, 31]\nb = ['Mercury', 'Venus', 'Earth']\nc = 'hello'\nnestedList = [a, b, c]\nprint(nestedList)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[11, 21, 31], ['Mercury', 'Venus', 'Earth'], 'hello']\n```\n:::\n:::\n\n\nYou can search inside a list:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nprint('Venus' in b)\nprint('Mars' in b)\nb.index('Venus')      # Returns the index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n1\n```\n:::\n:::\n\n\nAnd you sort lists alphabetically:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nb.sort()\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Earth', 'Mercury', 'Venus']\n```\n:::\n:::\n\n\nTo delete an item from a list:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nb.pop(2)              # Using its index\nprint(b)\n\nb.remove('Earth')     # Using its value\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Earth', 'Mercury']\n['Mercury']\n```\n:::\n:::\n\n\n## Dictionaries\n\nDictionaries are unordered sets of key/value pairs.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfavs = {'mary': 'orange', 'john': 'green', 'eric': 'blue'}\nprint(favs)\nprint(favs['john'])\nprint(favs['mary'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'mary': 'orange', 'john': 'green', 'eric': 'blue'}\ngreen\norange\n```\n:::\n:::\n\n\nNow let's see how to add items to a dictionary:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nconcepts = {}\nconcepts['list'] = 'An ordered collection of values'\nconcepts['dictionary'] = 'A collection of key-value pairs'\nprint(concepts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'list': 'An ordered collection of values', 'dictionary': 'A collection of key-value pairs'}\n```\n:::\n:::\n\n\nWe can modify the values:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nconcepts['list'] = 'Simple: ' + concepts['list']\nconcepts['dictionary'] = 'Complex: ' + concepts['dictionary']\nprint(concepts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'list': 'Simple: An ordered collection of values', 'dictionary': 'Complex: A collection of key-value pairs'}\n```\n:::\n:::\n\n\nDeleting dictionary pairs:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\ndel concepts['list']      # Removes the key 'list' and its value\nprint(concepts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'dictionary': 'Complex: A collection of key-value pairs'}\n```\n:::\n:::\n\n\nValues can be numerical:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ngrades = {}\ngrades['mary'] = 5\ngrades['john'] = 4.5\nprint(grades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'mary': 5, 'john': 4.5}\n```\n:::\n:::\n\n\nThe keys can also be numerical:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ngrades[1] = 2\nprint(grades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'mary': 5, 'john': 4.5, 1: 2}\n```\n:::\n:::\n\n\n## Conditionals\n\nPython implements conditionals via *if*, *elif* (short for \"else if\") and *else*. Use an *if* statement to control\nwhether some block of code is executed or not.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nmass = 3.54\nif mass > 3.0:\n    print(mass, 'is large')  # The indentation is important!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.54 is large\n```\n:::\n:::\n\n\nLet's modify the mass:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nmass = 2.07\nif mass > 3.0:\n    print (mass, 'is large')\n```\n:::\n\n\n{{<notes>}}\nNote that we don't get any output.\n{{</notes>}}\n\nAdd an *else* statement:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nmass = 2.07\nif mass > 3.0:\n    print(mass, 'is large')\nelse:\n    print(mass, 'is small')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.07 is small\n```\n:::\n:::\n\n\nAdd an *elif* statement:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nx = 5\nif x > 0:\n    print(x, 'is positive')\nelif x < 0:\n    print(x, 'is negative')\nelse:\n    print(x, 'is zero')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 is positive\n```\n:::\n:::\n\n\n{{<exo>}}\nWhat is the problem with the following code?\n{{</exo>}}\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ngrade = 85\nif grade >= 70:\n    print('grade is C')\nelif grade >= 80:\n    print('grade is B')\nelif grade >= 90:\n    print('grade is A')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngrade is C\n```\n:::\n:::\n\n\n## Loops\n\n### For loops\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nfor number in [2, 3, 5]:\n    print(number)          # The indentation is important!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\n5\n```\n:::\n:::\n\n\nThis is equivalent to:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nprint(2)\nprint(3)\nprint(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\n5\n```\n:::\n:::\n\n\n{{<exo>}}\nWhat do you think that this will print?\n{{</exo>}}\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nfor number in [2, 3, 5]:\n    print(number)\nprint(number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\n5\n5\n```\n:::\n:::\n\n\nThe loop variable could be called anything:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nfor i in 'hello':\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh\ne\nl\nl\no\n```\n:::\n:::\n\n\nUse `range` to iterate over a sequence of numbers:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nfor i in range(0, 3):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\nLet's add numbers 1 to 10:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ntotal = 0\nfor number in range(10):\n    total += number + 1\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n55\n```\n:::\n:::\n\n\n### While loops\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nx = 2\nwhile x > 1.0:\n    x /= 1.1\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.8181818181818181\n1.652892561983471\n1.5026296018031553\n1.366026910730141\n1.2418426461183099\n1.1289478601075542\n1.026316236461413\n0.9330147604194662\n```\n:::\n:::\n\n\n## Functions\n\nPython comes with many built-in functions. You can also install packages that contain additional functions. But you can also write your own functions:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ndef greeting():\n    print('Hello!')\n```\n:::\n\n\nLet's run our new function:\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ngreeting()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello!\n```\n:::\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ndef printDate(year, month, day):\n    joined = str(year) + '-' + str(month) + '-' + str(day)\n    print(joined)\nprintDate(1871, 3, 19)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1871-3-19\n```\n:::\n:::\n\n\n## Packages\n\nWhen you launch Python, you can access many functions.\n\nBut Python also comes with a *standard library* of several modules. Each module contains additional functions that can be loaded in a session.\n\n{{<ex>}}\nExample: the `math` module.\n{{</ex>}}\n{{<br size=\"1\">}}\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nprint('pi is', pi)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'pi' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nimport math\nprint('pi is', math.pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npi is 3.141592653589793\n```\n:::\n:::\n\n\nYou can create an alias from the library:\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nimport math as m\nprint(m.pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.141592653589793\n```\n:::\n:::\n\n\nYou can also import `math`'s items directly:\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nfrom math import pi, sin\nprint(sin(pi/6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.49999999999999994\n```\n:::\n:::\n\n\n```{.python}\nhelp(math)   # Help for libraries works just like help for functions\n```\n\n",
    "supporting": [
      "basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}