{
  "hash": "e669e5375eda222d40ebf68be955a058",
  "result": {
    "markdown": "---\ntitle: Distributed computing\nauthor: Marie-Hélène Burle\n---\n\n## Launching several Julia processes\n\nJulia supports distributed computing thanks to the module `Distributed` from its standard library.\n\nThere are two ways to launch several Julia processes (called \"workers\"):\n\n### Launch Julia on n workers\n\nJulia can be started with the `-p` flag followed by the number of workers by running (in a terminal):\n\n```{.bash}\njulia -p n\n```\n\nThis launches `n` workers, available for parallel computations, in addition to the process running the interactive prompt (so there are `n + 1` Julia processes in total).\n\nThe module `Distributed` is needed whenever you want to use several workers, but the `-p` flag loads it automatically.\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\njulia -p 4\n```\n\nWithin Julia, you can see how many workers are running with:\n\n```{.julia}\nnworkers()\n```\n\nThe total number of processes can be seen with:\n\n```{.julia}\nnprocs()\n```\n\n### Start workers from within a Julia session\n\nAlternatively, workers can be started from within a Julia session. In this case, you need to load the module `Distributed` explicitly:\n\n```{.julia}\nusing Distributed\n```\n\nTo launch `n` workers:\n\n```{.julia}\naddprocs(n)\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.julia}\naddprocs(4)\n```\n\n## Managing workers\n\nTo list all the worker process identifiers:\n\n```{.julia}\nworkers()\n```\n\n:::{.note}\n\nThe process running the Julia prompt has id `1`.\n\n:::\n\nTo kill a worker:\n\n```{.julia}\nrmprocs(<pid>)\n```\n\nwhere `<pid>` is the process identifier of the worker you want to kill (you can kill several workers by providing a list of pids).\n\n## Using workers\n\nThere are a number of [macros](https://docs.julialang.org/en/v1/manual/metaprogramming/#man-macros-1) that are very convenient here:\n\n- To execute an expression on all processes, there is `@everywhere`\n\nFor instance, if your parallel code requires a module or an external package to run, you need to load that module or package with `@everywhere`:\n\n```{.julia}\n@everywhere using DataFrames\n```\n\nIf the parallel code requires a script to run:\n\n```{.julia}\n@everywhere include(\"script.jl\")\n```\n\nIf it requires a function that you are defining, you need to define it on all the workers:\n\n```\n@everywhere function <name>(<arguments>)\n    <body>\nend\n```\n\n- To assign a task to a particular worker, you use `@spawnat`\n\nThe first argument indicates the process id, the second argument is the expression that should be evaluated:\n\n```\n@spawnat <pid> <expression>\n```\n\n`@spawnat` returns of `Future`: the placeholder for a computation of unknown status and time. The function `fetch` waits for a `Future` to complete and returns the result of the computation.\n\n:::{.example}\n\nExample:\n\n:::\n\nThe function `myid` gives the id of the current process. As I mentioned earlier, the process running the interactive Julia prompt has the pid `1`. So `myid()` normally returns `1`.\n\nBut we can \"spawn\" `myid` on one of the worker, for instance the first worker (so pid `2`):\n\n```{.julia}\n@spawnat 2 myid()\n```\n\nAs you can see, we get a `Future` as a result. But if we pass it through `fetch`, we get the result of `myid` ran on the worker with pid `2`:\n\n```{.julia}\nfetch(@spawnat 2 myid())\n```\n\nIf you want tasks to be assigned to any worker automatically, you can pass the symbol `:any` to `@spawnat` instead of the worker id:\n\n```{.julia}\n@spawnat :any myid()\n```\n\nTo get the result:\n\n```{.julia}\nfetch(@spawnat :any myid())\n```\n\nIf you run this multiple times, you will see that `myid` is run on any of your available workers. This will however never return `1`, *except* when you only have one running Julia process (in that case, the process running the prompt is considered a worker).\n\n",
    "supporting": [
      "distributed_files"
    ],
    "filters": [],
    "includes": {}
  }
}