{
  "hash": "82e378dba9c85cd17b6f954bdd98faec",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Functions\naliases:\n  - functions.html\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nFunctions are objects containing a set of instructions. \\\nWhen you pass a tuple of argument(s) (possibly an empty tuple) to them, you get one or more values as output.\n\n:::\n\n## Operators\n\nOperators are functions and can be written in a way that shows the tuple of arguments more explicitly.\n\n:::{.example}\n\nFor instance, you can use the addition operator (`+`) in 2 ways:\n\n:::\n\n::: {#71057e30 .cell execution_count=2}\n``` {.julia .cell-code}\n3 + 2\n+(3, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n5\n```\n:::\n:::\n\n\nThe multiplication operator can be omitted when this does not create any ambiguity:\n\n::: {#691bccbf .cell execution_count=3}\n``` {.julia .cell-code}\na = 3;\n2a\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n6\n```\n:::\n:::\n\n\nJulia has \"assignment by operation\" operators:\n\n::: {#e4b15bae .cell execution_count=4}\n``` {.julia .cell-code}\na = 2;\na += 7    # this is the same as a = a + 7\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n9\n```\n:::\n:::\n\n\nThere is a *left* division operator:\n\n::: {#cf0f714d .cell execution_count=5}\n``` {.julia .cell-code}\n2\\8 == 8/2\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\ntrue\n```\n:::\n:::\n\n\nJulia supports fraction operations:\n\n::: {#f4bfb589 .cell execution_count=6}\n``` {.julia .cell-code}\n4//8\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n1//2\n```\n:::\n:::\n\n\n::: {#abc115f2 .cell execution_count=7}\n``` {.julia .cell-code}\n1//2 + 3//4\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n5//4\n```\n:::\n:::\n\n\n## Function definition\n\nThere are 2 ways to define a new function:\n\n### Long form\n\n```\nfunction <name>(<arguments>)\n    <body>\nend\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#2a151c11 .cell execution_count=8}\n``` {.julia .cell-code}\nfunction hello1()\n    println(\"Hello\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nhello1 (generic function with 1 method)\n```\n:::\n:::\n\n\n### Assignment form\n\n```\n<name>(<arguments>) = <body>\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#642a31a0 .cell execution_count=9}\n``` {.julia .cell-code}\nhello1() = println(\"Hello\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nhello1 (generic function with 1 method)\n```\n:::\n:::\n\n\nThe function `hello1` defined with this terse syntax is exactly the same as the one we defined above.\n\n### Stylistic convention\n\nJulia suggests to use lower case without underscores as function names when the name is readable enough.\n\n## Calling functions\n\nSince you pass a tuple to a function when you run it, you call a function by appending parentheses to its name:\n\n::: {#8272e95b .cell execution_count=10}\n``` {.julia .cell-code}\nhello1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\n```\n:::\n:::\n\n\n:::{.note}\n\nHere, our function does not take any argument, so the tuple is empty.\n\n:::\n\n## Arguments\n\n### No argument\n\nOur function `hello1` does not accept any argument. If we pass an argument, we get an error message:\n\n```{.julia}\nhello1(\"Bob\")\n```\n\n```\nLoadError: MethodError: no method matching hello1(::String)\n```\n\n### One argument\n\nTo define a function which accepts an argument, we need to add a placeholder for it in the function definition.\n\n:::{.example}\n\nSo let's try this:\n\n:::\n\n::: {#89d37f0e .cell execution_count=11}\n``` {.julia .cell-code}\nfunction hello2(name)\n    println(\"Hello name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nhello2 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {#b74e32cd .cell execution_count=12}\n``` {.julia .cell-code}\nhello2(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello name\n```\n:::\n:::\n\n\nMmm ... not quite ... this function works but does not give the result we wanted.\n\nHere, we need to use [string interpolation:](https://en.wikipedia.org/wiki/String_interpolation)\n\n::: {#242956ac .cell execution_count=13}\n``` {.julia .cell-code}\nfunction hello3(name)\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nhello3 (generic function with 1 method)\n```\n:::\n:::\n\n\n`$name` in the body of the function points to `name` in the tuple of argument.\n\nWhen we run the function, `$name` is replaced by the value we used in lieu of `name` in the function definition:\n\n::: {#b6aa264c .cell execution_count=14}\n``` {.julia .cell-code}\nhello3(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob\n```\n:::\n:::\n\n\nHere is the corresponding assignment form for `hello3`:\n\n::: {#089b7316 .cell execution_count=15}\n``` {.julia .cell-code}\nhello3(name) = println(\"Hello $name\")\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nhello3 (generic function with 1 method)\n```\n:::\n:::\n\n\n:::{.example}\n\nNote that this dollar sign is only required with strings. Here is an example with integers:\n\n:::\n\n::: {#05d66aff .cell execution_count=16}\n``` {.julia .cell-code}\nfunction addTwo(a)\n    a + 2\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\naddTwo (generic function with 1 method)\n```\n:::\n:::\n\n\nAnd the corresponding assignment form:\n\n::: {#fc70223c .cell execution_count=17}\n``` {.julia .cell-code}\naddTwo(a) = a + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\naddTwo (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {#78013c7e .cell execution_count=18}\n``` {.julia .cell-code}\naddTwo(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n6\n```\n:::\n:::\n\n\n### Multiple arguments\n\nNow, let's write a function which accepts 2 arguments. For this, we put 2 placeholders in the tuple passed to the function in the function definition:\n\n::: {#f39ea5a0 .cell execution_count=19}\n``` {.julia .cell-code}\nfunction hello4(name1, name2)\n    println(\"Hello $name1 and $name2\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nhello4 (generic function with 1 method)\n```\n:::\n:::\n\n\nThis means that this function expects a tuple of 2 values:\n\n::: {#86997d9e .cell execution_count=20}\n``` {.julia .cell-code}\nhello4(\"Bob\", \"Pete\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob and Pete\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nSee what happens when you pass no argument, a single argument, or three arguments to this function.\n\n:::\n\n### Default arguments\n\nYou can set a default value for some or all arguments. In this case, the function will run with or without a value passed for those arguments. If no value is given, the default is used. If a value is given, it will replace the default.\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#6379c44a .cell execution_count=21}\n``` {.julia .cell-code}\nfunction hello5(name=\"\")\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nhello5 (generic function with 2 methods)\n```\n:::\n:::\n\n\n::: {#30b3c6ee .cell execution_count=22}\n``` {.julia .cell-code}\nhello5()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello \n```\n:::\n:::\n\n\n::: {#431f68c5 .cell execution_count=23}\n``` {.julia .cell-code}\nhello5(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob\n```\n:::\n:::\n\n\n:::{.example}\n\nAnother example:\n\n:::\n\n::: {#8bba1195 .cell execution_count=24}\n``` {.julia .cell-code}\nfunction addSomethingOrTwo(a, b=2)\n    a + b\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\naddSomethingOrTwo (generic function with 2 methods)\n```\n:::\n:::\n\n\n::: {#f9f5a99a .cell execution_count=25}\n``` {.julia .cell-code}\naddSomethingOrTwo(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n5\n```\n:::\n:::\n\n\n::: {#2de99e76 .cell execution_count=26}\n``` {.julia .cell-code}\naddSomethingOrTwo(3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n7\n```\n:::\n:::\n\n\n## Returning the result\n\nIn Julia, functions return the value(s) of the last expression automatically.<br>\nIf you want to return something else instead, you need to use the `return` statement. This causes the function to exit early.\n\n:::{.example}\n\nLook at these 5 functions:\n\n:::\n\n```{.julia}\nfunction test1(x, y)\n    x + y\nend\n\nfunction test2(x, y)\n    return x + y\nend\n\nfunction test3(x, y)\n    x * y\n    x + y\nend\n\nfunction test4(x, y)\n    return x * y\n    x + y\nend\n\nfunction test5(x, y)\n    return x * y\n    return x + y\nend\n\nfunction test6(x, y)\n    x * y, x + y\nend\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWithout running the code, try to guess the outputs of:\n\n:::\n\n```{.julia}\ntest1(1, 2)\ntest2(1, 2)\ntest3(1, 2)\ntest4(1, 2)\ntest5(1, 2)\ntest6(1, 2)\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nNow, run the code and draw some conclusions on the behaviour of the return statement.\n\n:::\n\n## Anonymous functions\n\nAnonymous functions are functions which aren't given a name:\n\n```\nfunction (<arguments>)\n    <body>\nend\n```\n\nIn compact form:\n\n```\n<arguments> -> <body>\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#b9cbeb5c .cell execution_count=27}\n``` {.julia .cell-code}\nfunction (name)\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n#13 (generic function with 1 method)\n```\n:::\n:::\n\n\nCompact form:\n\n::: {#0b2958a8 .cell execution_count=28}\n``` {.julia .cell-code}\nname -> println(\"Hello $name\")\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n#15 (generic function with 1 method)\n```\n:::\n:::\n\n\n### When would you want to use anonymous functions?\n\nThis is very useful for functional programming (when you apply a function—for instance `map`—to other functions to apply them in a vectorized manner which avoids repetitions).\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#894b0c4e .cell execution_count=29}\n``` {.julia .cell-code}\nmap(name -> println(\"Hello $name\"), [\"Bob\", \"Lucie\", \"Sophie\"]);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob\nHello Lucie\nHello Sophie\n```\n:::\n:::\n\n\n## Pipes\n\n`|>` is the pipe in Julia.<br>\nIt redirects the output of the expression on the left as the input of the expression on the right.\n\n:::{.example}\n\nThe following 2 expressions are equivalent:\n\n:::\n\n```{.julia}\nprintln(\"Hello\")\n\"Hello\" |> println\n```\n\n:::{.example}\n\nHere is another example:\n\n:::\n\n::: {#e461ad96 .cell execution_count=30}\n``` {.julia .cell-code}\nsqrt(2) == 2 |> sqrt\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\ntrue\n```\n:::\n:::\n\n\n## Function composition\n\nYou can pass a function inside another function:\n\n```\n<function2>(<function1>(<arguments>))\n```\n\n`<arguments>` will be passed to `<function1>` and the result will then be passed to `<function2>`.\n\nAn equivalent syntax is to use the composition operator `∘` (in the REPL, type `\\circ` then press tab):\n\n```\n(<function2> ∘ <function1>)(<arguments>)\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#a76dcfa2 .cell execution_count=31}\n``` {.julia .cell-code}\n# sum is our first function\nsum(1:3)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n6\n```\n:::\n:::\n\n\n::: {#1ce6f505 .cell execution_count=32}\n``` {.julia .cell-code}\n# sqrt is the second function\nsqrt(sum(1:3))\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n2.449489742783178\n```\n:::\n:::\n\n\n::: {#2a3d98ee .cell execution_count=33}\n``` {.julia .cell-code}\n# This is equivalent\n(sqrt ∘ sum)(1:3)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n2.449489742783178\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWrite three other equivalent expressions using the pipe.\n\n:::\n\n:::{.example}\n\nAnother example:\n\n:::\n\n::: {#e1584fe5 .cell execution_count=34}\n``` {.julia .cell-code}\nexp(+(-3, 1))\n\n(exp ∘ +)(-3, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n0.1353352832366127\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to write the same expression in another 2 different ways.\n\n:::\n\n## Mutating functions\n\nFunctions usually do not modify their argument(s):\n\n::: {#58717980 .cell execution_count=35}\n``` {.julia .cell-code}\na = [-2, 3, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n3-element Vector{Int64}:\n -2\n  3\n -5\n```\n:::\n:::\n\n\n::: {#a2374778 .cell execution_count=36}\n``` {.julia .cell-code}\nsort(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n3-element Vector{Int64}:\n -5\n -2\n  3\n```\n:::\n:::\n\n\n::: {#17138f64 .cell execution_count=37}\n``` {.julia .cell-code}\na\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n3-element Vector{Int64}:\n -2\n  3\n -5\n```\n:::\n:::\n\n\nJulia has a set of functions which modify their argument(s). By convention, their names end with `!`\n\n:::{.example}\n\nThe function sort has a mutating equivalent sort!:\n\n:::\n\n::: {#78fabcf9 .cell execution_count=38}\n``` {.julia .cell-code}\nsort!(a);\na\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n3-element Vector{Int64}:\n -5\n -2\n  3\n```\n:::\n:::\n\n\n:::{.note}\n\nIf you write functions which modify their arguments, make sure to follow this convention too.\n\n:::\n\n## Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n:::{.example}\n\nLet's create a collection (here a tuple):\n\n:::\n\n::: {#35107e67 .cell execution_count=39}\n``` {.julia .cell-code}\na = (2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n(2, 3)\n```\n:::\n:::\n\n\n:::{.example}\n\nIf we pass `a` to the string function, that function applies to the whole collection:\n\n:::\n\n::: {#d90921de .cell execution_count=40}\n``` {.julia .cell-code}\nstring(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n\"(2, 3)\"\n```\n:::\n:::\n\n\n:::{.example}\n\nIn contrast, we can broadcast the function string to all elements of a:\n\n:::\n\n::: {#38e0bf3e .cell execution_count=41}\n``` {.julia .cell-code}\nbroadcast(string, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n(\"2\", \"3\")\n```\n:::\n:::\n\n\n:::{.example}\n\nAn alternative syntax is to add a period after the function name:\n\n:::\n\n::: {#e634fac6 .cell execution_count=42}\n``` {.julia .cell-code}\nstring.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n(\"2\", \"3\")\n```\n:::\n:::\n\n\n:::{.example}\n\nHere is another example:\n\n:::\n\n```{.julia}\na = [-3, 2, -5]\nabs(a)\n```\n\n```\nERROR: MethodError: no method matching abs(::Array{Int64,1})\n```\n\nThis doesn't work because the function `abs` only applies to single elements.\n\nBy broadcasting `abs`, you apply it to each element of `a`:\n\n::: {#a984fcda .cell execution_count=43}\n``` {.julia .cell-code}\nbroadcast(abs, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n(2, 3)\n```\n:::\n:::\n\n\nThe dot notation is equivalent:\n\n::: {#d6eb8b67 .cell execution_count=44}\n``` {.julia .cell-code}\nabs.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n(2, 3)\n```\n:::\n:::\n\n\nIt can also be applied to the pipe, to unary and binary operators, etc.\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {#ba7b15ed .cell execution_count=45}\n``` {.julia .cell-code}\na .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n(2, 3)\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to understand the difference between the following 2 expressions:\n\n:::\n\n::: {#ee773d8c .cell execution_count=46}\n``` {.julia .cell-code}\nabs.(a) == a .|> abs\nabs.(a) .== a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\n(true, true)\n```\n:::\n:::\n\n\n## Multiple dispatch\n\nIn some programming languages, functions can be polymorphic (multiple versions exist under the same function name). The process of selecting which version to use is called *dispatch*.\n\nThere are multiple types of dispatch depending on the language:\n\n- *Dynamic dispatch*: the process of selecting one version of a function at run time.\n- *Single dispatch*: the choice of version is based on a single object.\n\n:::{.note}\n\nThis is typical of object-oriented languages such as Python, C++, Java, Smalltalk, etc.\n\n:::\n\n- *[Multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch)*: the choice of version is based on the combination of all operands and their types.\n\n:::{.note}\n\nThis the case of Lisp and Julia. In Julia, these versions are called *methods*.\n\n:::\n\n## Methods\n\nRunning `methods(+)` let's you see that the function `+` has 206 methods!\n\nMethods can be added to existing functions.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nRun the following and try to understand the outputs:\n\n```{.julia}\nabssum(x::Int64, y::Int64) = abs(x + y)\nabssum(x::Float64, y::Float64) = abs(x + y)\n\nabssum(2, 4)\nabssum(2.0, 4.0)\nabssum(2, 4.0)\n```\n\nWhat could you do if you wanted the last expression to work?\n\n:::\n\n",
    "supporting": [
      "intro_functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}