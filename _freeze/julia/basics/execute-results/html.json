{
  "hash": "f7b66fc2824f58afc2073c1229d5c183",
  "result": {
    "markdown": "---\ntitle: Basics of the Julia language\nauthor: Marie-H√©l√®ne Burle\n---\n\n## How to run Julia\n\nThere are several ways to run Julia interactively:\n\n- Directly in [the REPL](https://westgrid-julia.netlify.app/2022_modules/05_jl_repl),\n- In interactive notebooks (e.g. [Jupyter](https://jupyter.org/), [Pluto](https://github.com/fonsp/Pluto.jl)),\n- In an editor able to run Julia interactively (e.g. [Emacs](https://github.com/JuliaEditorSupport/julia-emacs), [VS Code](https://www.julia-vscode.org/), [Vim](https://github.com/JuliaEditorSupport/julia-vim)).\n\nJulia can also be run non interactively as we will see [in a further section](https://westgrid-julia.netlify.app/2022_modules/16_jl_non_interactive).\n\nFor now, we will run Julia directly in [the REPL](https://westgrid-julia.netlify.app/2022_modules/05_jl_repl).\n\n## Comments\n\nComments do not get evaluated by Julia and are for humans only.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n# Comments in Julia are identified by hastags\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n#=\nComments can also spread over multiple lines\nif you enclose them with this syntax\n=#\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nx = 2          # Comments can be added at the end of lines\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n2\n```\n:::\n:::\n\n\n## Basic operations\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# By default, Julia returns the output\n2 + 3\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n5\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n# Trailing semi-colons suppress the output\n3 + 7;\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# Alternative syntax that can be used with operators\n+(2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n7\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# Updating operators\na = 3\na += 8    # this is the same as a = a + 8\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n11\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\n# Operator precedence follows standard rules\n3 + 2 ^ 3 * 10\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n83\n```\n:::\n:::\n\n\n### More exotic operators\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n# Usual division\n6 / 2\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n3.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n# Inverse division\n2 \\ 6\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n3.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n# Integer division (division truncated to an integer)\n7 √∑ 2\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\n# Remainder\n7 % 2        # equivalent to rem(7, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\n# Fraction\n4//8\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n1//2\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n# Julia supports fraction operations\n1//2 + 3//4\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n5//4\n```\n:::\n:::\n\n\n## Variables\n\nA variable is a name bound to a value:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\na = 3;\n```\n:::\n\n\nIt can be called:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\na\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n3\n```\n:::\n:::\n\n\nOr used in expressions:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\na + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n5\n```\n:::\n:::\n\n\n### Assignment\n\nYou can re-assign new values to variables:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\na = 3;\na = -8.2;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n-8.2\n```\n:::\n:::\n\n\nEven values of a different type:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\na = \"a is now a string\"\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n\"a is now a string\"\n```\n:::\n:::\n\n\nYou can define multiple variables at once:\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\na, b, c = 1, 2, 3\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2\n```\n:::\n:::\n\n\n### Variable names\n\nThese names are extremely flexible and [can use Unicode character:](https://docs.julialang.org/en/v1/manual/unicode-input/)\n\n```{.julia}\n\\omega\t\t # press TAB\n\\sum         # press TAB\n\\sqrt\t     # press TAB\n\\in          # press TAB\n\\:phone:     # press TAB\n```\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nŒ¥ = 8.5;\nüêå = 3;\nŒ¥ + üêå\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n11.5\n```\n:::\n:::\n\n\nAdmittedly, using emojis doesn't seem very useful, but using Greek letters to write equations really makes Julia a great mathematical language:\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nœÉ = 3\nŒ¥ = œÄ\nœï = 8\n\n(5œÉ + 3Œ¥) / œï\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n3.0530972450961724\n```\n:::\n:::\n\n\n:::{.note}\n\nNote how the multiplication operator can be omitted when this does not lead to confusion.<br>\nAlso note how the mathematical constant œÄ is available in Julia without having to load any module.\n\n:::\n\nIf you want to know how to type a symbol, ask Julia: type `?` and paste it in the REPL.\n\n[The only hard rules for variable names are:]{.underline}\n\n- They must begin with a letter or an underscore,\n- They cannot take the names of [built-in keywords](https://docs.julialang.org/en/v1/base/base/#Keywords) such as `if`, `do`, `try`, `else`,\n- They cannot take the names of built-in constants (e.g. `œÄ`) and keywords in use in a session.\n\n:::{.example}\n\nWe thus get an error here:\n\n:::\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nfalse = 3\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: syntax: invalid assignment location \"false\" around In[24]:1\n```\n:::\n:::\n\n\nIn addition, the [Julia Style Guide](https://docs.julialang.org/en/v1/manual/style-guide/#Style-Guide-1) recommends to follow these conventions:\n\n- Use lower case,\n- Word separation can be indicated by underscores, but better not to use them if the names can be read easily enough without them.\n\n### The ans variable\n\nThe keyword `ans` is a variable which, in the REPL, takes the value of the last computation:\n\n```{.julia}\na = 3 ^ 2;\nans + 1\n```\n\n```\n10\n```\n\n### Printing\n\nTo print the value of a variable in an interactive session, you only need to call it:\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\na = 3;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n3\n```\n:::\n:::\n\n\nIn non interactive sessions, you have to use the `println` function:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nprintln(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\n## Collections\n\nValues can also be stored in collections.\n\n### Tuples\n\nTuples are immutable, indexable, and possibly heterogeneous collections of elements. The order of elements matters.\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\n# Possibly heterogeneous (values can be of different types)\ntypeof((2, 'a', 1.0, \"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nTuple{Int64, Char, Float64, String}\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\n# Indexable (note that indexing in Julia starts with 1)\nx = (2, 'a', 1.0, \"test\");\nx[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n1.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\n# Immutable (they cannot be modified)\n# So this returns an error\nx[3] = 8\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching setindex!(::Tuple{Int64, Char, Float64, String}, ::Int64, ::Int64)\n```\n:::\n:::\n\n\n#### Named tuples\n\nTuples can have named components:\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\ntypeof((a=2, b='a', c=1.0, d=\"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\nNamedTuple{(:a, :b, :c, :d), Tuple{Int64, Char, Float64, String}}\n```\n:::\n:::\n\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\nx = (a=2, b='a', c=1.0, d=\"test\");\nx.c\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n1.0\n```\n:::\n:::\n\n\n### Dictionaries\n\nJulia also has dictionaries: associative collections of key/value pairs:\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\nx = Dict(\"Name\"=>\"Roger\", \"Age\"=>52, \"Index\"=>0.3)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Roger\"\n```\n:::\n:::\n\n\n`\"Name\"`, `\"Age\"`, and `\"Index\"` are the keys; `\"Roger\"`, `52`, and `0.3` are the values.\n\nThe `=>` operator is the same as the `Pair` function:\n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\np = \"foo\" => 7\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n\"foo\" => 7\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.julia .cell-code}\nq = Pair(\"bar\", 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n\"bar\" => 8\n```\n:::\n:::\n\n\nDictionaries can be heterogeneous (as in this example) and the order doesn't matter. They are also indexable:\n\n::: {.cell execution_count=35}\n``` {.julia .cell-code}\nx[\"Name\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n\"Roger\"\n```\n:::\n:::\n\n\nAnd mutable (they can be modified):\n\n::: {.cell execution_count=36}\n``` {.julia .cell-code}\nx[\"Name\"] = \"Alex\";\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Alex\"\n```\n:::\n:::\n\n\n### Sets\n\nSets are collections without duplicates. The order of elements doesn't matter.\n\n::: {.cell execution_count=37}\n``` {.julia .cell-code}\nset1 = Set([9, 4, 8, 2, 7, 8])\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\nSet{Int64} with 5 elements:\n  4\n  7\n  2\n  9\n  8\n```\n:::\n:::\n\n\n:::{.note}\n\nNotice how this is a set of 5 (and not 6) elements: the duplicated 8 didn't matter.\n\n:::\n\n::: {.cell execution_count=38}\n``` {.julia .cell-code}\nset2 = Set([10, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\nSet{Int64} with 3 elements:\n  2\n  10\n  3\n```\n:::\n:::\n\n\nYou can compare sets:\n\n::: {.cell execution_count=39}\n``` {.julia .cell-code}\n# The union is the set of elements that are in one OR the other set\nunion(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\nSet{Int64} with 7 elements:\n  4\n  7\n  2\n  10\n  9\n  8\n  3\n```\n:::\n:::\n\n\n::: {.cell execution_count=40}\n``` {.julia .cell-code}\n# The intersect is the set of elements that are in one AND the other set\nintersect(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\nSet{Int64} with 1 element:\n  2\n```\n:::\n:::\n\n\n::: {.cell execution_count=41}\n``` {.julia .cell-code}\n# The setdiff is the set of elements that are in the first set but not in the second\n# Note that the order matters here\nsetdiff(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\nSet{Int64} with 4 elements:\n  4\n  7\n  9\n  8\n```\n:::\n:::\n\n\nSets can be heterogeneous:\n\n::: {.cell execution_count=42}\n``` {.julia .cell-code}\nSet([\"test\", 9, :a])\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\nSet{Any} with 3 elements:\n  :a\n  \"test\"\n  9\n```\n:::\n:::\n\n\n### Arrays\n\nArrays are indexable and mutable collections. The order of elements matters and they can be heterogeneous. We will talk about them in [a later section](https://westgrid-julia.netlify.app/2022_modules/13_jl_arrays).\n\n## Quotes\n\nNote the difference between single and double quotes:\n\n::: {.cell execution_count=43}\n``` {.julia .cell-code}\ntypeof(\"a\")\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\nString\n```\n:::\n:::\n\n\n::: {.cell execution_count=44}\n``` {.julia .cell-code}\ntypeof('a')\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\nChar\n```\n:::\n:::\n\n\n::: {.cell execution_count=45}\n``` {.julia .cell-code}\n\"This is a string\"\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n\"This is a string\"\n```\n:::\n:::\n\n\n::: {.cell execution_count=46}\n``` {.julia .cell-code}\n'This is not a sring'\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: syntax: character literal contains multiple characters\n```\n:::\n:::\n\n\n:::{.note}\n\nWe got an error here since `'` is used for the character type and can thus only contain a single character.\n\n:::\n\n::: {.cell execution_count=47}\n``` {.julia .cell-code}\n'a'\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}