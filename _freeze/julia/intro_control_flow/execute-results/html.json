{
  "hash": "db52e6b9826514c980561b296b13146b",
  "result": {
    "markdown": "---\ntitle: Control flow\naliases:\n  - control_flow.html\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nControl flow statements alter the linear execution of code, allowing for one or another section of code to be executed, or for one section of code to be executed multiple times.\n\n:::\n\n## Conditional statements\n\nConditional statements allow to run instructions based on predicates: different sets of instructions will be executed depending on whether the predicates return `true` or `false`.\n\n### Predicates\n\n:::{.example}\n\nHere are a few examples of predicates with classic operators:\n\n:::\n\n```{.julia}\noccursin(\"that\", \"this and that\")\n4 < 3\na == b\na != b\n2 in 1:3\n3 <= 4 && 4 > 5\n3 <= 4 || 4 > 5\n```\n\nIn addition, Julia possesses more exotic operators that can be used in predicates:\n\n- The inexact equality comparator, useful to compare floating-point numbers despite computer rounding.\n\n:::{.note}\n\nThe function `isapprox` or the equivalent binary operator `≈` (typed with `\\approx<tab>`) can be used:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n0.1 + 0.2 == 0.3\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nfalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n0.1 + 0.2 ≈ 0.3\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\ntrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nisapprox(0.1 + 0.2, 0.3)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\ntrue\n```\n:::\n:::\n\n\nThe negatives are the function `!isapprox` and `≉` (typed with `\\napprox<tab>`).\n\n:::\n\n- The equivalent or triple equal operator compares objects in deeper ways (address in memory for mutable objects and content at the bit level for immutable objects).\n\n:::{.note}\n\n`===` or `≡` (typed with `\\equiv<tab>`) can be used:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\na = [1, 2]; b = [1, 2];\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\ntrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\na ≡ b     # This can also be written `a === b`\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nfalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\na ≡ a\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\ntrue\n```\n:::\n:::\n\n\n:::\n\n### If statements\n\n```\nif <predicate>\n    <some action>\nend\n```\n\n- If `<predicate>` evaluates to `true`, the body of the if statement gets evaluated (`<some action>` is run),\n- If `<predicate>` evaluates to `false`, nothing happens.\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction testsign1(x)\n    if x >= 0\n        println(\"x is positive\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\ntestsign1 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\ntestsign1(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is positive\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\ntestsign1(-2)\n```\n:::\n\n\n:::{.note}\n\nNothing gets returned since the predicate returned `false`.\n\n:::\n\n### If else statements\n\n```\nif <predicate>\n    <some action>\nelse\n    <some other action>\nend\n```\n\n- If `<predicate>` evaluates to `true`, `<some action>` is done,\n- If `<predicate>` evaluates to `false`, `<some other action>` is done.\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nfunction testsign2(x)\n    if x >= 0\n        println(\"x is positive\")\n    else\n        println(\"x is negative\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\ntestsign2 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\ntestsign2(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is positive\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\ntestsign2(-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is negative\n```\n:::\n:::\n\n\nIf else statements can be written in a terse format using the ternary operator:\n\n```\n<predicate> ? <some action> : <some other action>\n```\n\n:::{.example}\n\nHere is our function `testsign2` written in terse format:\n\n:::\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nfunction testsign2(x)\n    x >= 0 ? println(\"x is positive\") : println(\"x is negative\")\nend\n\ntestsign2(-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is negative\n```\n:::\n:::\n\n\n:::{.example}\n\nHere is another example:\n\n:::\n\n```{.julia}\na = 2\nb = 2.0\n\nif a == b\n    println(\"It's true\")\nelse\n    println(\"It's false\")\nend\n```\n\nAnd in terse format:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\na == b ? println(\"It's true\") : println(\"It's false\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt's true\n```\n:::\n:::\n\n\n### If elseif else statements\n\n```\nif <predicate1>\n    <some action>\nelseif <predicate2>\n    <some other action>\nelse\n    <yet some other action>\nend\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nfunction testsign3(x)\n    if x > 0\n        println(\"x is positive\")\n    elseif x == 0\n        println(\"x is zero\")\n    else\n        println(\"x is negative\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\ntestsign3 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\ntestsign3(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is positive\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\ntestsign3(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is zero\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\ntestsign3(-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is negative\n```\n:::\n:::\n\n\n## Loops\n\n### For loops\n\nFor loops run a set of instructions for each element of an iterable:\n\n```\nfor <iterable>\n    <some action>\nend\n```\n\n:::{.example}\n\nExamples:\n\n:::\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nfor name = [\"Paul\", \"Lucie\", \"Sophie\"]\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Paul\nHello Lucie\nHello Sophie\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nfor i = 1:3, j = 3:5\n    println(i + j)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n5\n6\n5\n6\n7\n6\n7\n8\n```\n:::\n:::\n\n\n### While loops\n\nWhile loops run as long as a condition remains true:\n\n```\nwhile <predicate>\n    <some action>\nend\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\ni = 0\n\nwhile i <= 10\n    println(i)\n    i += 1\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```\n:::\n:::\n\n\n",
    "supporting": [
      "intro_control_flow_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}