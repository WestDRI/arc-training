{
  "hash": "039bf1a010393937237f8b09a14f3056",
  "result": {
    "markdown": "---\ntitle: Functions\nauthor: Marie-Hélène Burle\n---\n\nFunctions are objects containing a set of instructions. \\\nWhen you pass a tuple of argument(s) (possibly an empty tuple) to them, you get one or more values as output.\n\n## Operators\n\nOperators are functions and can be written in a way that shows the tuple of arguments more explicitly:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n3 + 2 == +(3, 2)  # `==` tests for equality\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\ntrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n+(3, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n5\n```\n:::\n:::\n\n\n## Function definition\n\nThere are 2 ways to define a new function:\n\n### Long form\n\n```{.julia}\nfunction <name>(<arguments>)\n    <body>\nend\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nfunction hello1()\n    println(\"Hello\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nhello1 (generic function with 1 method)\n```\n:::\n:::\n\n\n### Assignment form\n\n```{.julia}\n<name>(<arguments>) = <body>\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nhello1() = println(\"Hello\")\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nhello1 (generic function with 1 method)\n```\n:::\n:::\n\n\nThe function `hello1` defined with this compact syntax is exactly the same as the one we defined above.\n\n### Stylistic convention\n\nJulia suggests to use lower case, without underscores, as function names.\n\n## Calling functions\n\nSince you pass a tuple to a function when you run it, you call a function by appending parentheses to its name:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nhello1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\n```\n:::\n:::\n\n\n:::{.note}\n\nHere, our function does not take any argument, so the tuple is empty.\n\n:::\n\n## Arguments\n\n### No argument\n\nOur function `hello` does not accept any argument. If we pass an argument, we get an error message:\n\n```{.julia}\nhello1(\"Bob\")\n```\n\n```\nLoadError: MethodError: no method matching hello1(::String)\n```\n\n### One argument\n\nTo define a function which accepts an argument, we need to add a placeholder for it in the function definition.\n\n:::{.example}\n\nSo let's try this:\n\n:::\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfunction hello2(name)\n    println(\"Hello name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nhello2 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nhello2(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello name\n```\n:::\n:::\n\n\nMmm ... not quite ... this function works but does not give the result we wanted.\n\nHere, we need to use [string interpolation:](https://en.wikipedia.org/wiki/String_interpolation)\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfunction hello3(name)\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nhello3 (generic function with 1 method)\n```\n:::\n:::\n\n\n`$name` in the body of the function points to `name` in the tuple of argument.\n\nWhen we run the function, `$name` is replaced by the value we used in lieu of `name` in the function definition:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nhello3(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob\n```\n:::\n:::\n\n\n:::{.example}\n\nNote that this dollar sign is only required with strings. Here is an example with integers:\n\n:::\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfunction cube(a)\n    a ^ 3\nend\n\ncube(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n64\n```\n:::\n:::\n\n\n### Multiple arguments\n\nNow, let's write a function which accepts 2 arguments. For this, we put 2 placeholders in the tuple passed to the function in the function definition:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction hello4(name1, name2)\n    println(\"Hello $name1 and $name2\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nhello4 (generic function with 1 method)\n```\n:::\n:::\n\n\nThis means that this function expects a tuple of 2 values:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nhello4(\"Bob\", \"Pete\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob and Pete\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nSee what happens when you pass no argument, a single argument, or three arguments to this function.\n\n:::\n\n### Default arguments\n\nYou can set a default value for some or all arguments. In this case, the function will run with or without a value passed for those arguments. If no value is given, the default is used. If a value is given, it will replace the default.\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction hello5(name=\"\")\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nhello5 (generic function with 2 methods)\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nhello5()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello \n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nhello5(\"Bob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob\n```\n:::\n:::\n\n\n## Returning the result\n\nIn Julia, functions return the value(s) of the last expression automatically.<br>\nIf you want to return something else instead, you need to use the `return` statement. This causes the function to exit early.\n\n:::{.example}\n\nLook at these 5 functions:\n\n:::\n\n```{.julia}\nfunction test1(x, y)\n    x + y\nend\n\nfunction test2(x, y)\n    return x + y\nend\n\nfunction test3(x, y)\n    x * y\n    x + y\nend\n\nfunction test4(x, y)\n    return x * y\n    x + y\nend\n\nfunction test5(x, y)\n    return x * y\n    return x + y\nend\n\nfunction test6(x, y)\n    x * y, x + y\nend\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWithout running the code, try to guess the outputs of:\n\n:::\n\n```{.julia}\ntest1(1, 2)\ntest2(1, 2)\ntest3(1, 2)\ntest4(1, 2)\ntest5(1, 2)\ntest6(1, 2)\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nNow, run the code and draw some conclusions on the behaviour of the return statement.\n\n:::\n\n## Anonymous functions\n\nAnonymous functions are functions which aren't given a name:\n\n```{.julia}\nfunction (<arguments>)\n    <body>\nend\n```\n\nIn compact form:\n\n```{.julia}\n<arguments> -> <body>\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfunction (name)\n    println(\"Hello $name\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n#11 (generic function with 1 method)\n```\n:::\n:::\n\n\nCompact form:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nname -> println(\"Hello $name\")\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n#13 (generic function with 1 method)\n```\n:::\n:::\n\n\n### When would you want to use anonymous functions?\n\nThis is very useful for functional programming (when you apply a function—for instance `map`—to other functions to apply them in a vectorized manner which avoids repetitions).\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nmap(name -> println(\"Hello $name\"), [\"Bob\", \"Lucie\", \"Sophie\"]);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Bob\nHello Lucie\nHello Sophie\n```\n:::\n:::\n\n\n## Pipes\n\n`|>` is the pipe in Julia.<br>\nIt redirects the output of the expression on the left as the input of the expression on the right.\n\n:::{.example}\n\nThe following 2 expressions are equivalent:\n\n:::\n\n```{.julia}\nprintln(\"Hello\")\n\"Hello\" |> println\n```\n\n:::{.example}\n\nHere is another example:\n\n:::\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nsqrt(2) == 2 |> sqrt\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\ntrue\n```\n:::\n:::\n\n\n## Function composition\n\nYou can pass a function inside another function:\n\n```{.julia}\n<function2>(<function1>(<arguments>))\n```\n\n`<arguments>` will be passed to `<function1>` and the result will then be passed to `<function2>`.\n\nAn equivalent syntax is to use the composition operator `∘` (in the REPL, type `\\circ` then press tab):\n\n```{.julia}\n(<function2> ∘ <function1>)(<arguments>)\n```\n\n:::{.example}\n\nExample:\n\n:::\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\n# sum is our first function\nsum(1:3)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n6\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\n# sqrt is the second function\nsqrt(sum(1:3))\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n2.449489742783178\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\n# This is equivalent\n(sqrt ∘ sum)(1:3)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2.449489742783178\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWrite three other equivalent expressions using the pipe.\n\n:::\n\n## Mutating functions\n\nFunctions usually do not modify their argument(s):\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\na = [-2, 3, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n3-element Vector{Int64}:\n -2\n  3\n -5\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nsort(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n3-element Vector{Int64}:\n -5\n -2\n  3\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\na\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n3-element Vector{Int64}:\n -2\n  3\n -5\n```\n:::\n:::\n\n\nJulia has a set of functions which modify their argument(s). By convention, their names end with `!`\n\n:::{.example}\n\nThe function sort has a mutating equivalent sort!:\n\n:::\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nsort!(a);\na\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3-element Vector{Int64}:\n -5\n -2\n  3\n```\n:::\n:::\n\n\n:::{.note}\n\nIf you write functions which modify their arguments, make sure to follow this convention too.\n\n:::\n\n## Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n:::{.example}\n\nLet's create a collection (here a tuple):\n\n:::\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\na = (2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n(2, 3)\n```\n:::\n:::\n\n\n:::{.example}\n\nIf we pass `a` to the string function, that function applies to the whole collection:\n\n:::\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\nstring(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n\"(2, 3)\"\n```\n:::\n:::\n\n\n:::{.example}\n\nIn contrast, we can broadcast the function string to all elements of a:\n\n:::\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nbroadcast(string, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n(\"2\", \"3\")\n```\n:::\n:::\n\n\n:::{.example}\n\nAn alternative syntax is to add a period after the function name:\n\n:::\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nstring.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n(\"2\", \"3\")\n```\n:::\n:::\n\n\n",
    "supporting": [
      "functions_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}