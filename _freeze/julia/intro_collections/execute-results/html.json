{
  "hash": "078c3a077bb27a5ad64595bf1095824b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Collections\naliases:\n  - collections.html\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nValues can be stored in collections. This workshop introduces tuples, dictionaries, sets, and arrays in Julia.\n\n:::\n\n## Tuples\n\nTuples are immutable, indexable, and possibly heterogeneous collections of elements. The order of elements matters.\n\n::: {#567d9f24 .cell execution_count=2}\n``` {.julia .cell-code}\n# Possibly heterogeneous (values can be of different types)\ntypeof((2, 'a', 1.0, \"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTuple{Int64, Char, Float64, String}\n```\n:::\n:::\n\n\n::: {#4c78ad81 .cell execution_count=3}\n``` {.julia .cell-code}\n# Indexable (note that indexing in Julia starts with 1)\nx = (2, 'a', 1.0, \"test\");\nx[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1.0\n```\n:::\n:::\n\n\n::: {#f8927398 .cell execution_count=4}\n``` {.julia .cell-code}\n# Immutable (they cannot be modified)\n# So this returns an error\nx[3] = 8\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching setindex!(::Tuple{Int64, Char, Float64, String}, ::Int64, ::Int64)\n```\n:::\n:::\n\n\n#### Named tuples\n\nTuples can have named components:\n\n::: {#c82eac11 .cell execution_count=5}\n``` {.julia .cell-code}\ntypeof((a=2, b='a', c=1.0, d=\"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n@NamedTuple{a::Int64, b::Char, c::Float64, d::String}\n```\n:::\n:::\n\n\n::: {#0ad19993 .cell execution_count=6}\n``` {.julia .cell-code}\nx = (a=2, b='a', c=1.0, d=\"test\");\nx.c\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n1.0\n```\n:::\n:::\n\n\n## Dictionaries\n\nJulia also has dictionaries: associative collections of key/value pairs:\n\n::: {#1f503ba8 .cell execution_count=7}\n``` {.julia .cell-code}\nx = Dict(\"Name\"=>\"Roger\", \"Age\"=>52, \"Index\"=>0.3)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Roger\"\n```\n:::\n:::\n\n\n`\"Name\"`, `\"Age\"`, and `\"Index\"` are the keys; `\"Roger\"`, `52`, and `0.3` are the values.\n\nThe `=>` operator is the same as the `Pair` function:\n\n::: {#4638b05c .cell execution_count=8}\n``` {.julia .cell-code}\np = \"foo\" => 7\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n\"foo\" => 7\n```\n:::\n:::\n\n\n::: {#04e2db45 .cell execution_count=9}\n``` {.julia .cell-code}\nq = Pair(\"bar\", 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n\"bar\" => 8\n```\n:::\n:::\n\n\nDictionaries can be heterogeneous (as in this example) and the order doesn't matter. They are also indexable:\n\n::: {#dac48f05 .cell execution_count=10}\n``` {.julia .cell-code}\nx[\"Name\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n\"Roger\"\n```\n:::\n:::\n\n\nAnd mutable (they can be modified):\n\n::: {#06c7aab8 .cell execution_count=11}\n``` {.julia .cell-code}\nx[\"Name\"] = \"Alex\";\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Alex\"\n```\n:::\n:::\n\n\n## Sets\n\nSets are collections without duplicates. The order of elements doesn't matter.\n\n::: {#162c7903 .cell execution_count=12}\n``` {.julia .cell-code}\nset1 = Set([9, 4, 8, 2, 7, 8])\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nSet{Int64} with 5 elements:\n  4\n  7\n  2\n  9\n  8\n```\n:::\n:::\n\n\n:::{.note}\n\nNotice how this is a set of 5 (and not 6) elements: the duplicated 8 didn't matter.\n\n:::\n\n::: {#bb2e6b4b .cell execution_count=13}\n``` {.julia .cell-code}\nset2 = Set([10, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nSet{Int64} with 3 elements:\n  2\n  10\n  3\n```\n:::\n:::\n\n\nYou can compare sets:\n\n::: {#61845af5 .cell execution_count=14}\n``` {.julia .cell-code}\n# The union is the set of elements that are in one OR the other set\nunion(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nSet{Int64} with 7 elements:\n  4\n  7\n  2\n  10\n  9\n  8\n  3\n```\n:::\n:::\n\n\n::: {#6dc63317 .cell execution_count=15}\n``` {.julia .cell-code}\n# The intersect is the set of elements that are in one AND the other set\nintersect(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nSet{Int64} with 1 element:\n  2\n```\n:::\n:::\n\n\n::: {#9d7c2f08 .cell execution_count=16}\n``` {.julia .cell-code}\n# The setdiff is the set of elements that are in the first set but not in the second\n# Note that the order matters here\nsetdiff(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nSet{Int64} with 4 elements:\n  4\n  7\n  9\n  8\n```\n:::\n:::\n\n\nSets can be heterogeneous:\n\n::: {#d2e9ff07 .cell execution_count=17}\n``` {.julia .cell-code}\nSet([\"test\", 9, :a])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nSet{Any} with 3 elements:\n  :a\n  \"test\"\n  9\n```\n:::\n:::\n\n\n## Arrays\n\n### Vectors\n\nUnidimensional arrays in Julia are called vectors.\n\n#### Vectors of one element\n\n::: {#c7379537 .cell execution_count=18}\n``` {.julia .cell-code}\n[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n1-element Vector{Int64}:\n 3\n```\n:::\n:::\n\n\n::: {#d2af62e0 .cell execution_count=19}\n``` {.julia .cell-code}\n[3.4]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n1-element Vector{Float64}:\n 3.4\n```\n:::\n:::\n\n\n::: {#29c26755 .cell execution_count=20}\n``` {.julia .cell-code}\n[\"Hello, World!\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n1-element Vector{String}:\n \"Hello, World!\"\n```\n:::\n:::\n\n\n#### Vectors of multiple elements\n\n::: {#616e2d1c .cell execution_count=21}\n``` {.julia .cell-code}\n[3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2-element Vector{Int64}:\n 3\n 4\n```\n:::\n:::\n\n\n### Two dimensional arrays\n\n::: {#b01a3bfb .cell execution_count=22}\n``` {.julia .cell-code}\n[3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n1×2 Matrix{Int64}:\n 3  4\n```\n:::\n:::\n\n\n::: {#bf2dfd94 .cell execution_count=23}\n``` {.julia .cell-code}\n[[1, 3] [1, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2×2 Matrix{Int64}:\n 1  1\n 3  2\n```\n:::\n:::\n\n\n### Syntax subtleties\n\nThese 3 syntaxes are equivalent:\n\n::: {#7bada974 .cell execution_count=24}\n``` {.julia .cell-code}\n[2 4 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {#b17cc337 .cell execution_count=25}\n``` {.julia .cell-code}\nhcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {#2202ec09 .cell execution_count=26}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\nThese 4 syntaxes are equivalent:\n\n::: {#b16cf0a9 .cell execution_count=27}\n``` {.julia .cell-code}\n[2\n 4\n 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {#d71c676a .cell execution_count=28}\n``` {.julia .cell-code}\n[2; 4; 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {#a28f51cc .cell execution_count=29}\n``` {.julia .cell-code}\nvcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {#c8018667 .cell execution_count=30}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\nElements separated by semi-colons or end of lines get expanded vertically. \\\nThose separated by commas do not get expanded. \\\nElements separated by spaces or tabs get expanded horizontally.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCompare the outputs of the following:\n\n:::\n\n::: {#78976071 .cell execution_count=31}\n``` {.julia .cell-code}\n[1:2; 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {#6c66a060 .cell execution_count=32}\n``` {.julia .cell-code}\n[1:2\n 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {#18acff9e .cell execution_count=33}\n``` {.julia .cell-code}\n[1:2, 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 3:4\n```\n:::\n:::\n\n\n::: {#48a58b40 .cell execution_count=34}\n``` {.julia .cell-code}\n[1:2 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n```\n:::\n:::\n\n\n### Arrays and types\n\nIn Julia, arrays can be heterogeneous:\n\n::: {#0e698274 .cell execution_count=35}\n``` {.julia .cell-code}\n[3, \"hello\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n2-element Vector{Any}:\n 3\n  \"hello\"\n```\n:::\n:::\n\n\nThis is possible because all elements of an array, no matter of what types, will always sit below the `Any` type in the type hierarchy.\n\n### Initializing arrays\n\nBelow are examples of some of the functions initializing arrays:\n\n::: {#723ef42e .cell execution_count=36}\n``` {.julia .cell-code}\nrand(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.676981  0.00192985  0.460161\n 0.579801  0.0571031   0.19217\n\n[:, :, 2] =\n 0.709137  0.355586  0.717515\n 0.334442  0.768498  0.93754\n\n[:, :, 3] =\n 0.110039  0.468733  0.764542\n 0.708841  0.418923  0.102156\n\n[:, :, 4] =\n 0.1735    0.92587   0.822419\n 0.122246  0.749059  0.52207\n```\n:::\n:::\n\n\n::: {#698104a1 .cell execution_count=37}\n``` {.julia .cell-code}\nrand(Int64, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 7539227344717627596  -3475288731017273925  3435963957489459227\n 7076298999511187079  -4056353322580659761  -837262113887699001\n\n[:, :, 2] =\n -7562670463192357073  -8927025020788172752   6417337822872556077\n  3692648043801976038   3471765935100455283  -6192652305627405865\n\n[:, :, 3] =\n  7031151667336399214   5088860813990033390   5115764253454872856\n -6119814429800991191  -8609024759557032284  -1204795858698859213\n\n[:, :, 4] =\n -2961801139235269924   5392657125003334687   1122551460163567839\n  1768937120468164288  -3560940733318201168  -6602997138296377453\n```\n:::\n:::\n\n\n::: {#3f3eb637 .cell execution_count=38}\n``` {.julia .cell-code}\nzeros(Int64, 2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n2×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  0  0  0  0\n```\n:::\n:::\n\n\n::: {#e5091dc4 .cell execution_count=39}\n``` {.julia .cell-code}\nones(2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n2×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n```\n:::\n:::\n\n\n::: {#315dfd3a .cell execution_count=40}\n``` {.julia .cell-code}\nreshape([1, 2, 4, 2], (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n```\n:::\n:::\n\n\n::: {#c0002347 .cell execution_count=41}\n``` {.julia .cell-code}\nfill(\"test\", (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n2×2 Matrix{String}:\n \"test\"  \"test\"\n \"test\"  \"test\"\n```\n:::\n:::\n\n\n### Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n::: {#58f276dc .cell execution_count=42}\n``` {.julia .cell-code}\na = [-3, 2, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n3-element Vector{Int64}:\n -3\n  2\n -5\n```\n:::\n:::\n\n\n```{.julia}\nabs(a)\n```\n\n```\nLoadError: MethodError: no method matching abs(::Vector{Int64})\n```\n\nThis doesn't work because the function `abs` only applies to single elements.\n\nBy broadcasting `abs`, you apply it to each element of `a`:\n\n::: {#f8e5be81 .cell execution_count=43}\n``` {.julia .cell-code}\nbroadcast(abs, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nThe dot notation is equivalent:\n\n::: {#98aeed02 .cell execution_count=44}\n``` {.julia .cell-code}\nabs.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nIt can also be applied to the pipe, to unary and binary operators, etc.\n\n::: {#ab65b7c4 .cell execution_count=45}\n``` {.julia .cell-code}\na .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to understand the difference between the following 2 expressions:\n\n:::\n\n::: {#f788ad20 .cell execution_count=46}\n``` {.julia .cell-code}\nabs.(a) == a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\ntrue\n```\n:::\n:::\n\n\n::: {#f7c37888 .cell execution_count=47}\n``` {.julia .cell-code}\nabs.(a) .== a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n3-element BitVector:\n 1\n 1\n 1\n```\n:::\n:::\n\n\n:::{.note}\n\nHint: 0/1 are a short-form notations for false/true in arrays of Booleans.\n\n:::\n\n### Comprehensions\n\nJulia has an array comprehension syntax similar to Python's:\n\n::: {#1f9f1e5b .cell execution_count=48}\n``` {.julia .cell-code}\n[ 3i + j for i=1:10, j=3 ]\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n10-element Vector{Int64}:\n  6\n  9\n 12\n 15\n 18\n 21\n 24\n 27\n 30\n 33\n```\n:::\n:::\n\n\n## Indexing\n\nAs in other mathematically oriented languages such as R, Julia starts indexing at `1`.\n\nIndexing is done with square brackets:\n\n::: {#be1512ae .cell execution_count=49}\n``` {.julia .cell-code}\na = [1 2; 3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n:::\n:::\n\n\n::: {#0dd8f6c0 .cell execution_count=50}\n``` {.julia .cell-code}\na[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n1\n```\n:::\n:::\n\n\n::: {#f496a484 .cell execution_count=51}\n``` {.julia .cell-code}\na[1, :]\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n2-element Vector{Int64}:\n 1\n 2\n```\n:::\n:::\n\n\n::: {#0641e11f .cell execution_count=52}\n``` {.julia .cell-code}\na[:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n2-element Vector{Int64}:\n 1\n 3\n```\n:::\n:::\n\n\n::: {#98430b13 .cell execution_count=53}\n``` {.julia .cell-code}\n# Here, we are indexing a tuple\n(2, 4, 1.0, \"test\")[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n4\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIndex the element on the 3^rd^ row and 2^nd^ column of `b`:\n\n::: {#adb8db7b .cell execution_count=54}\n``` {.julia .cell-code}\nb = [\"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"you got it\" \"wrong\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n3×3 Matrix{String}:\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"you got it\"  \"wrong\"\n```\n:::\n:::\n\n\n:::\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n```{.julia}\na = [1 2; 3 4]\na[1, 1]\na[1, :]\n```\n\nHow can I get the second column? \\\nHow can I get the tuple `(2, 4)`? (a tuple is a list of elements)\n\n:::\n\nAs in Python, by default, arrays are passed by sharing:\n\n::: {#6459a874 .cell execution_count=55}\n``` {.julia .cell-code}\na = [1, 2, 3];\na[1] = 0;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n3-element Vector{Int64}:\n 0\n 2\n 3\n```\n:::\n:::\n\n\nThis prevents the unwanted copying of arrays.\n\n",
    "supporting": [
      "intro_collections_files"
    ],
    "filters": [],
    "includes": {}
  }
}