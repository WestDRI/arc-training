{
  "hash": "078c3a077bb27a5ad64595bf1095824b",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Collections\naliases:\n  - collections.html\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nValues can be stored in collections. This workshop introduces tuples, dictionaries, sets, and arrays in Julia.\n\n:::\n\n## Tuples\n\nTuples are immutable, indexable, and possibly heterogeneous collections of elements. The order of elements matters.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n# Possibly heterogeneous (values can be of different types)\ntypeof((2, 'a', 1.0, \"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTuple{Int64, Char, Float64, String}\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n# Indexable (note that indexing in Julia starts with 1)\nx = (2, 'a', 1.0, \"test\");\nx[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1.0\n```\n:::\n:::\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# Immutable (they cannot be modified)\n# So this returns an error\nx[3] = 8\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching setindex!(::Tuple{Int64, Char, Float64, String}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\nStacktrace:\n [1] top-level scope\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">~/parvus/prog/mint/julia/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">intro_collections.qmd:32</span></pre>\n```\n:::\n\n:::\n:::\n\n\n\n#### Named tuples\n\nTuples can have named components:\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof((a=2, b='a', c=1.0, d=\"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n@NamedTuple{a::Int64, b::Char, c::Float64, d::String}\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nx = (a=2, b='a', c=1.0, d=\"test\");\nx.c\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1.0\n```\n:::\n:::\n\n\n\n## Dictionaries\n\nJulia also has dictionaries: associative collections of key/value pairs:\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nx = Dict(\"Name\"=>\"Roger\", \"Age\"=>52, \"Index\"=>0.3)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Roger\"\n```\n:::\n:::\n\n\n\n`\"Name\"`, `\"Age\"`, and `\"Index\"` are the keys; `\"Roger\"`, `52`, and `0.3` are the values.\n\nThe `=>` operator is the same as the `Pair` function:\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\np = \"foo\" => 7\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"foo\" => 7\n```\n:::\n:::\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nq = Pair(\"bar\", 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"bar\" => 8\n```\n:::\n:::\n\n\n\nDictionaries can be heterogeneous (as in this example) and the order doesn't matter. They are also indexable:\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nx[\"Name\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Roger\"\n```\n:::\n:::\n\n\n\nAnd mutable (they can be modified):\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nx[\"Name\"] = \"Alex\";\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Alex\"\n```\n:::\n:::\n\n\n\n## Sets\n\nSets are collections without duplicates. The order of elements doesn't matter.\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nset1 = Set([9, 4, 8, 2, 7, 8])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSet{Int64} with 5 elements:\n  4\n  7\n  2\n  9\n  8\n```\n:::\n:::\n\n\n\n:::{.note}\n\nNotice how this is a set of 5 (and not 6) elements: the duplicated 8 didn't matter.\n\n:::\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nset2 = Set([10, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSet{Int64} with 3 elements:\n  2\n  10\n  3\n```\n:::\n:::\n\n\n\nYou can compare sets:\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\n# The union is the set of elements that are in one OR the other set\nunion(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSet{Int64} with 7 elements:\n  4\n  7\n  2\n  10\n  9\n  8\n  3\n```\n:::\n:::\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\n# The intersect is the set of elements that are in one AND the other set\nintersect(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSet{Int64} with 1 element:\n  2\n```\n:::\n:::\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\n# The setdiff is the set of elements that are in the first set but not in the second\n# Note that the order matters here\nsetdiff(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSet{Int64} with 4 elements:\n  4\n  7\n  9\n  8\n```\n:::\n:::\n\n\n\nSets can be heterogeneous:\n\n::: {#32 .cell execution_count=1}\n``` {.julia .cell-code}\nSet([\"test\", 9, :a])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSet{Any} with 3 elements:\n  :a\n  \"test\"\n  9\n```\n:::\n:::\n\n\n\n## Arrays\n\n### Vectors\n\nUnidimensional arrays in Julia are called vectors.\n\n#### Vectors of one element\n\n::: {#34 .cell execution_count=1}\n``` {.julia .cell-code}\n[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1-element Vector{Int64}:\n 3\n```\n:::\n:::\n\n\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\n[3.4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1-element Vector{Float64}:\n 3.4\n```\n:::\n:::\n\n\n\n::: {#38 .cell execution_count=1}\n``` {.julia .cell-code}\n[\"Hello, World!\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1-element Vector{String}:\n \"Hello, World!\"\n```\n:::\n:::\n\n\n\n#### Vectors of multiple elements\n\n::: {#40 .cell execution_count=1}\n``` {.julia .cell-code}\n[3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 3\n 4\n```\n:::\n:::\n\n\n\n### Two dimensional arrays\n\n::: {#42 .cell execution_count=1}\n``` {.julia .cell-code}\n[3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1×2 Matrix{Int64}:\n 3  4\n```\n:::\n:::\n\n\n\n::: {#44 .cell execution_count=1}\n``` {.julia .cell-code}\n[[1, 3] [1, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×2 Matrix{Int64}:\n 1  1\n 3  2\n```\n:::\n:::\n\n\n\n### Syntax subtleties\n\nThese 3 syntaxes are equivalent:\n\n::: {#46 .cell execution_count=1}\n``` {.julia .cell-code}\n[2 4 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n\n::: {#48 .cell execution_count=1}\n``` {.julia .cell-code}\nhcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n\n::: {#50 .cell execution_count=1}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n\nThese 4 syntaxes are equivalent:\n\n::: {#52 .cell execution_count=1}\n``` {.julia .cell-code}\n[2\n 4\n 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n\n::: {#54 .cell execution_count=1}\n``` {.julia .cell-code}\n[2; 4; 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n\n::: {#56 .cell execution_count=1}\n``` {.julia .cell-code}\nvcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n\n::: {#58 .cell execution_count=1}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n\nElements separated by semi-colons or end of lines get expanded vertically. \\\nThose separated by commas do not get expanded. \\\nElements separated by spaces or tabs get expanded horizontally.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCompare the outputs of the following:\n\n:::\n\n::: {#60 .cell execution_count=1}\n``` {.julia .cell-code}\n[1:2; 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n\n::: {#62 .cell execution_count=1}\n``` {.julia .cell-code}\n[1:2\n 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n\n::: {#64 .cell execution_count=1}\n``` {.julia .cell-code}\n[1:2, 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 3:4\n```\n:::\n:::\n\n\n\n::: {#66 .cell execution_count=1}\n``` {.julia .cell-code}\n[1:2 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n```\n:::\n:::\n\n\n\n### Arrays and types\n\nIn Julia, arrays can be heterogeneous:\n\n::: {#68 .cell execution_count=1}\n``` {.julia .cell-code}\n[3, \"hello\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Any}:\n 3\n  \"hello\"\n```\n:::\n:::\n\n\n\nThis is possible because all elements of an array, no matter of what types, will always sit below the `Any` type in the type hierarchy.\n\n### Initializing arrays\n\nBelow are examples of some of the functions initializing arrays:\n\n::: {#70 .cell execution_count=1}\n``` {.julia .cell-code}\nrand(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.993828   0.882674  0.156826\n 0.0488372  0.384544  0.38646\n\n[:, :, 2] =\n 0.947572  0.211583   0.245329\n 0.200717  0.0671244  0.11207\n\n[:, :, 3] =\n 0.920057  0.535439  0.758574\n 0.633244  0.701944  0.922863\n\n[:, :, 4] =\n 0.0622371  0.996037  0.495487\n 0.623987   0.402097  0.226669\n```\n:::\n:::\n\n\n\n::: {#72 .cell execution_count=1}\n``` {.julia .cell-code}\nrand(Int64, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n -1659704258553532985  5092626041193358980  -6744239143480713967\n  5676627516220431085   859766954670435512   2040841354476197273\n\n[:, :, 2] =\n -8675906160027700335  -6349630634794011755  -735734371108161759\n   138637581457749019  -3183745125470321952  8635673206110177569\n\n[:, :, 3] =\n  -26801811691569741   7032665316102188392   372415012557512763\n 8384772822022222227  -8182155477413591973  7840102709525219400\n\n[:, :, 4] =\n  7791255455207374125  1527910740453680593  -8625969480346811118\n -2584660519127820262  4492350654429620582  -3802575830933417107\n```\n:::\n:::\n\n\n\n::: {#74 .cell execution_count=1}\n``` {.julia .cell-code}\nzeros(Int64, 2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  0  0  0  0\n```\n:::\n:::\n\n\n\n::: {#76 .cell execution_count=1}\n``` {.julia .cell-code}\nones(2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n```\n:::\n:::\n\n\n\n::: {#78 .cell execution_count=1}\n``` {.julia .cell-code}\nreshape([1, 2, 4, 2], (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n```\n:::\n:::\n\n\n\n::: {#80 .cell execution_count=1}\n``` {.julia .cell-code}\nfill(\"test\", (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×2 Matrix{String}:\n \"test\"  \"test\"\n \"test\"  \"test\"\n```\n:::\n:::\n\n\n\n### Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n::: {#82 .cell execution_count=1}\n``` {.julia .cell-code}\na = [-3, 2, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n -3\n  2\n -5\n```\n:::\n:::\n\n\n\n```{.julia}\nabs(a)\n```\n\n```\nLoadError: MethodError: no method matching abs(::Vector{Int64})\n```\n\nThis doesn't work because the function `abs` only applies to single elements.\n\nBy broadcasting `abs`, you apply it to each element of `a`:\n\n::: {#84 .cell execution_count=1}\n``` {.julia .cell-code}\nbroadcast(abs, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n\nThe dot notation is equivalent:\n\n::: {#86 .cell execution_count=1}\n``` {.julia .cell-code}\nabs.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n\nIt can also be applied to the pipe, to unary and binary operators, etc.\n\n::: {#88 .cell execution_count=1}\n``` {.julia .cell-code}\na .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to understand the difference between the following 2 expressions:\n\n:::\n\n::: {#90 .cell execution_count=1}\n``` {.julia .cell-code}\nabs.(a) == a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {#92 .cell execution_count=1}\n``` {.julia .cell-code}\nabs.(a) .== a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element BitVector:\n 1\n 1\n 1\n```\n:::\n:::\n\n\n\n:::{.note}\n\nHint: 0/1 are a short-form notations for false/true in arrays of Booleans.\n\n:::\n\n### Comprehensions\n\nJulia has an array comprehension syntax similar to Python's:\n\n::: {#94 .cell execution_count=1}\n``` {.julia .cell-code}\n[ 3i + j for i=1:10, j=3 ]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10-element Vector{Int64}:\n  6\n  9\n 12\n 15\n 18\n 21\n 24\n 27\n 30\n 33\n```\n:::\n:::\n\n\n\n## Indexing\n\nAs in other mathematically oriented languages such as R, Julia starts indexing at `1`.\n\nIndexing is done with square brackets:\n\n::: {#96 .cell execution_count=1}\n``` {.julia .cell-code}\na = [1 2; 3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n:::\n:::\n\n\n\n::: {#98 .cell execution_count=1}\n``` {.julia .cell-code}\na[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n::: {#100 .cell execution_count=1}\n``` {.julia .cell-code}\na[1, :]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 1\n 2\n```\n:::\n:::\n\n\n\n::: {#102 .cell execution_count=1}\n``` {.julia .cell-code}\na[:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 1\n 3\n```\n:::\n:::\n\n\n\n::: {#104 .cell execution_count=1}\n``` {.julia .cell-code}\n# Here, we are indexing a tuple\n(2, 4, 1.0, \"test\")[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4\n```\n:::\n:::\n\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIndex the element on the 3^rd^ row and 2^nd^ column of `b`:\n\n::: {#106 .cell execution_count=1}\n``` {.julia .cell-code}\nb = [\"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"you got it\" \"wrong\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3×3 Matrix{String}:\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"you got it\"  \"wrong\"\n```\n:::\n:::\n\n\n\n:::\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n```{.julia}\na = [1 2; 3 4]\na[1, 1]\na[1, :]\n```\n\nHow can I get the second column? \\\nHow can I get the tuple `(2, 4)`? (a tuple is a list of elements)\n\n:::\n\nAs in Python, by default, arrays are passed by sharing:\n\n::: {#108 .cell execution_count=1}\n``` {.julia .cell-code}\na = [1, 2, 3];\na[1] = 0;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 0\n 2\n 3\n```\n:::\n:::\n\n\n\nThis prevents the unwanted copying of arrays.\n\n",
    "supporting": [
      "intro_collections_files"
    ],
    "filters": [],
    "includes": {}
  }
}