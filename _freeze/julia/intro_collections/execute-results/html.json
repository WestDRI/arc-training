{
  "hash": "078c3a077bb27a5ad64595bf1095824b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Collections\naliases:\n  - collections.html\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nValues can be stored in collections. This workshop introduces tuples, dictionaries, sets, and arrays in Julia.\n\n:::\n\n## Tuples\n\nTuples are immutable, indexable, and possibly heterogeneous collections of elements. The order of elements matters.\n\n::: {#6efc3ef1 .cell execution_count=2}\n``` {.julia .cell-code}\n# Possibly heterogeneous (values can be of different types)\ntypeof((2, 'a', 1.0, \"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTuple{Int64, Char, Float64, String}\n```\n:::\n:::\n\n\n::: {#8087b362 .cell execution_count=3}\n``` {.julia .cell-code}\n# Indexable (note that indexing in Julia starts with 1)\nx = (2, 'a', 1.0, \"test\");\nx[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1.0\n```\n:::\n:::\n\n\n::: {#36714376 .cell execution_count=4}\n``` {.julia .cell-code}\n# Immutable (they cannot be modified)\n# So this returns an error\nx[3] = 8\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching setindex!(::Tuple{Int64, Char, Float64, String}, ::Int64, ::Int64)\nMethodError: no method matching setindex!(::Tuple{Int64, Char, Float64, String}, ::Int64, ::Int64)\n\nStacktrace:\n [1] top-level scope\n   @ In[4]:3\n```\n:::\n:::\n\n\n#### Named tuples\n\nTuples can have named components:\n\n::: {#8cb5354f .cell execution_count=5}\n``` {.julia .cell-code}\ntypeof((a=2, b='a', c=1.0, d=\"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n@NamedTuple{a::Int64, b::Char, c::Float64, d::String}\n```\n:::\n:::\n\n\n::: {#96249e24 .cell execution_count=6}\n``` {.julia .cell-code}\nx = (a=2, b='a', c=1.0, d=\"test\");\nx.c\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n1.0\n```\n:::\n:::\n\n\n## Dictionaries\n\nJulia also has dictionaries: associative collections of key/value pairs:\n\n::: {#34c6d1b1 .cell execution_count=7}\n``` {.julia .cell-code}\nx = Dict(\"Name\"=>\"Roger\", \"Age\"=>52, \"Index\"=>0.3)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Roger\"\n```\n:::\n:::\n\n\n`\"Name\"`, `\"Age\"`, and `\"Index\"` are the keys; `\"Roger\"`, `52`, and `0.3` are the values.\n\nThe `=>` operator is the same as the `Pair` function:\n\n::: {#62adf69a .cell execution_count=8}\n``` {.julia .cell-code}\np = \"foo\" => 7\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n\"foo\" => 7\n```\n:::\n:::\n\n\n::: {#03b872db .cell execution_count=9}\n``` {.julia .cell-code}\nq = Pair(\"bar\", 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n\"bar\" => 8\n```\n:::\n:::\n\n\nDictionaries can be heterogeneous (as in this example) and the order doesn't matter. They are also indexable:\n\n::: {#5b23dbd6 .cell execution_count=10}\n``` {.julia .cell-code}\nx[\"Name\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n\"Roger\"\n```\n:::\n:::\n\n\nAnd mutable (they can be modified):\n\n::: {#cbadbe6b .cell execution_count=11}\n``` {.julia .cell-code}\nx[\"Name\"] = \"Alex\";\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Alex\"\n```\n:::\n:::\n\n\n## Sets\n\nSets are collections without duplicates. The order of elements doesn't matter.\n\n::: {#d490f52c .cell execution_count=12}\n``` {.julia .cell-code}\nset1 = Set([9, 4, 8, 2, 7, 8])\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nSet{Int64} with 5 elements:\n  4\n  7\n  2\n  9\n  8\n```\n:::\n:::\n\n\n:::{.note}\n\nNotice how this is a set of 5 (and not 6) elements: the duplicated 8 didn't matter.\n\n:::\n\n::: {#f11bb0eb .cell execution_count=13}\n``` {.julia .cell-code}\nset2 = Set([10, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nSet{Int64} with 3 elements:\n  2\n  10\n  3\n```\n:::\n:::\n\n\nYou can compare sets:\n\n::: {#ec2b3dd8 .cell execution_count=14}\n``` {.julia .cell-code}\n# The union is the set of elements that are in one OR the other set\nunion(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nSet{Int64} with 7 elements:\n  4\n  7\n  2\n  10\n  9\n  8\n  3\n```\n:::\n:::\n\n\n::: {#107575cb .cell execution_count=15}\n``` {.julia .cell-code}\n# The intersect is the set of elements that are in one AND the other set\nintersect(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nSet{Int64} with 1 element:\n  2\n```\n:::\n:::\n\n\n::: {#59a24cd8 .cell execution_count=16}\n``` {.julia .cell-code}\n# The setdiff is the set of elements that are in the first set but not in the second\n# Note that the order matters here\nsetdiff(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nSet{Int64} with 4 elements:\n  4\n  7\n  9\n  8\n```\n:::\n:::\n\n\nSets can be heterogeneous:\n\n::: {#1e2d5865 .cell execution_count=17}\n``` {.julia .cell-code}\nSet([\"test\", 9, :a])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nSet{Any} with 3 elements:\n  :a\n  \"test\"\n  9\n```\n:::\n:::\n\n\n## Arrays\n\n### Vectors\n\nUnidimensional arrays in Julia are called vectors.\n\n#### Vectors of one element\n\n::: {#570552aa .cell execution_count=18}\n``` {.julia .cell-code}\n[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n1-element Vector{Int64}:\n 3\n```\n:::\n:::\n\n\n::: {#6ad96be2 .cell execution_count=19}\n``` {.julia .cell-code}\n[3.4]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n1-element Vector{Float64}:\n 3.4\n```\n:::\n:::\n\n\n::: {#8b6d739a .cell execution_count=20}\n``` {.julia .cell-code}\n[\"Hello, World!\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n1-element Vector{String}:\n \"Hello, World!\"\n```\n:::\n:::\n\n\n#### Vectors of multiple elements\n\n::: {#9a3ff9b7 .cell execution_count=21}\n``` {.julia .cell-code}\n[3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2-element Vector{Int64}:\n 3\n 4\n```\n:::\n:::\n\n\n### Two dimensional arrays\n\n::: {#b545c295 .cell execution_count=22}\n``` {.julia .cell-code}\n[3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n1×2 Matrix{Int64}:\n 3  4\n```\n:::\n:::\n\n\n::: {#c2d72ca8 .cell execution_count=23}\n``` {.julia .cell-code}\n[[1, 3] [1, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2×2 Matrix{Int64}:\n 1  1\n 3  2\n```\n:::\n:::\n\n\n### Syntax subtleties\n\nThese 3 syntaxes are equivalent:\n\n::: {#3ad206c6 .cell execution_count=24}\n``` {.julia .cell-code}\n[2 4 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {#ecd9adc8 .cell execution_count=25}\n``` {.julia .cell-code}\nhcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {#c94eba53 .cell execution_count=26}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\nThese 4 syntaxes are equivalent:\n\n::: {#99547673 .cell execution_count=27}\n``` {.julia .cell-code}\n[2\n 4\n 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {#5cc5f6b8 .cell execution_count=28}\n``` {.julia .cell-code}\n[2; 4; 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {#b1a3bbfd .cell execution_count=29}\n``` {.julia .cell-code}\nvcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {#9033fba3 .cell execution_count=30}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\nElements separated by semi-colons or end of lines get expanded vertically. \\\nThose separated by commas do not get expanded. \\\nElements separated by spaces or tabs get expanded horizontally.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCompare the outputs of the following:\n\n:::\n\n::: {#754ed6b9 .cell execution_count=31}\n``` {.julia .cell-code}\n[1:2; 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {#af11dfe5 .cell execution_count=32}\n``` {.julia .cell-code}\n[1:2\n 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {#3fc820b8 .cell execution_count=33}\n``` {.julia .cell-code}\n[1:2, 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 3:4\n```\n:::\n:::\n\n\n::: {#cf111292 .cell execution_count=34}\n``` {.julia .cell-code}\n[1:2 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n```\n:::\n:::\n\n\n### Arrays and types\n\nIn Julia, arrays can be heterogeneous:\n\n::: {#8def3e66 .cell execution_count=35}\n``` {.julia .cell-code}\n[3, \"hello\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n2-element Vector{Any}:\n 3\n  \"hello\"\n```\n:::\n:::\n\n\nThis is possible because all elements of an array, no matter of what types, will always sit below the `Any` type in the type hierarchy.\n\n### Initializing arrays\n\nBelow are examples of some of the functions initializing arrays:\n\n::: {#ba0cf759 .cell execution_count=36}\n``` {.julia .cell-code}\nrand(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.70497   0.452224  0.210217\n 0.152121  0.808499  0.748643\n\n[:, :, 2] =\n 0.964218  0.533504  0.295138\n 0.530122  0.705078  0.448783\n\n[:, :, 3] =\n 0.101024  0.702216  0.351094\n 0.451474  0.643441  0.193529\n\n[:, :, 4] =\n 0.365804  0.593161  0.213761\n 0.908817  0.669264  0.160509\n```\n:::\n:::\n\n\n::: {#cae06e19 .cell execution_count=37}\n``` {.julia .cell-code}\nrand(Int64, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n  -808940715765468093  -1584927078315600374  -5301199987516324173\n -6596392331988765638  -6192885842242193678   1889096344742778536\n\n[:, :, 2] =\n -1263311441971715837   -398863679696473412    425946792632171343\n -8887634749817674030  -6532441838130849674  -5790650878322099032\n\n[:, :, 3] =\n -3504949663976209361  -7056126120819890696   9014204101180695865\n  5444915959299197671   7453311557699154449  -7332672815187269775\n\n[:, :, 4] =\n -1027239353605623832  8546329529560148599  5006263260814316361\n  3614836023227257818  -380255779183739001  9031894209972587885\n```\n:::\n:::\n\n\n::: {#fd759546 .cell execution_count=38}\n``` {.julia .cell-code}\nzeros(Int64, 2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n2×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  0  0  0  0\n```\n:::\n:::\n\n\n::: {#a728c3a8 .cell execution_count=39}\n``` {.julia .cell-code}\nones(2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n2×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n```\n:::\n:::\n\n\n::: {#814e1a2f .cell execution_count=40}\n``` {.julia .cell-code}\nreshape([1, 2, 4, 2], (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n```\n:::\n:::\n\n\n::: {#e931c218 .cell execution_count=41}\n``` {.julia .cell-code}\nfill(\"test\", (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n2×2 Matrix{String}:\n \"test\"  \"test\"\n \"test\"  \"test\"\n```\n:::\n:::\n\n\n### Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n::: {#d2baf526 .cell execution_count=42}\n``` {.julia .cell-code}\na = [-3, 2, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n3-element Vector{Int64}:\n -3\n  2\n -5\n```\n:::\n:::\n\n\n```{.julia}\nabs(a)\n```\n\n```\nLoadError: MethodError: no method matching abs(::Vector{Int64})\n```\n\nThis doesn't work because the function `abs` only applies to single elements.\n\nBy broadcasting `abs`, you apply it to each element of `a`:\n\n::: {#afcc8dcf .cell execution_count=43}\n``` {.julia .cell-code}\nbroadcast(abs, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nThe dot notation is equivalent:\n\n::: {#3a790c05 .cell execution_count=44}\n``` {.julia .cell-code}\nabs.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nIt can also be applied to the pipe, to unary and binary operators, etc.\n\n::: {#d29e980c .cell execution_count=45}\n``` {.julia .cell-code}\na .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to understand the difference between the following 2 expressions:\n\n:::\n\n::: {#1a54b660 .cell execution_count=46}\n``` {.julia .cell-code}\nabs.(a) == a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\ntrue\n```\n:::\n:::\n\n\n::: {#056ceb49 .cell execution_count=47}\n``` {.julia .cell-code}\nabs.(a) .== a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n3-element BitVector:\n 1\n 1\n 1\n```\n:::\n:::\n\n\n:::{.note}\n\nHint: 0/1 are a short-form notations for false/true in arrays of Booleans.\n\n:::\n\n### Comprehensions\n\nJulia has an array comprehension syntax similar to Python's:\n\n::: {#66f8b8c4 .cell execution_count=48}\n``` {.julia .cell-code}\n[ 3i + j for i=1:10, j=3 ]\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n10-element Vector{Int64}:\n  6\n  9\n 12\n 15\n 18\n 21\n 24\n 27\n 30\n 33\n```\n:::\n:::\n\n\n## Indexing\n\nAs in other mathematically oriented languages such as R, Julia starts indexing at `1`.\n\nIndexing is done with square brackets:\n\n::: {#381917c3 .cell execution_count=49}\n``` {.julia .cell-code}\na = [1 2; 3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n:::\n:::\n\n\n::: {#f85e9372 .cell execution_count=50}\n``` {.julia .cell-code}\na[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n1\n```\n:::\n:::\n\n\n::: {#c4ecb0d0 .cell execution_count=51}\n``` {.julia .cell-code}\na[1, :]\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n2-element Vector{Int64}:\n 1\n 2\n```\n:::\n:::\n\n\n::: {#e53bfd64 .cell execution_count=52}\n``` {.julia .cell-code}\na[:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n2-element Vector{Int64}:\n 1\n 3\n```\n:::\n:::\n\n\n::: {#ec7d95ab .cell execution_count=53}\n``` {.julia .cell-code}\n# Here, we are indexing a tuple\n(2, 4, 1.0, \"test\")[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n4\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIndex the element on the 3^rd^ row and 2^nd^ column of `b`:\n\n::: {#530dee33 .cell execution_count=54}\n``` {.julia .cell-code}\nb = [\"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"you got it\" \"wrong\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n3×3 Matrix{String}:\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"you got it\"  \"wrong\"\n```\n:::\n:::\n\n\n:::\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n```{.julia}\na = [1 2; 3 4]\na[1, 1]\na[1, :]\n```\n\nHow can I get the second column? \\\nHow can I get the tuple `(2, 4)`? (a tuple is a list of elements)\n\n:::\n\nAs in Python, by default, arrays are passed by sharing:\n\n::: {#58dc470a .cell execution_count=55}\n``` {.julia .cell-code}\na = [1, 2, 3];\na[1] = 0;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n3-element Vector{Int64}:\n 0\n 2\n 3\n```\n:::\n:::\n\n\nThis prevents the unwanted copying of arrays.\n\n",
    "supporting": [
      "intro_collections_files"
    ],
    "filters": [],
    "includes": {}
  }
}