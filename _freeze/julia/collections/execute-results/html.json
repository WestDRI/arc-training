{
  "hash": "9efbbd9307b406b5f388b13f692126a8",
  "result": {
    "markdown": "---\ntitle: Collections\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nValues can be stored in collections. This workshop introduces tuples, dictionaries, sets, and arrays in Julia.\n\n:::\n\n## Tuples\n\nTuples are immutable, indexable, and possibly heterogeneous collections of elements. The order of elements matters.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n# Possibly heterogeneous (values can be of different types)\ntypeof((2, 'a', 1.0, \"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTuple{Int64, Char, Float64, String}\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# Indexable (note that indexing in Julia starts with 1)\nx = (2, 'a', 1.0, \"test\");\nx[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# Immutable (they cannot be modified)\n# So this returns an error\nx[3] = 8\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching setindex!(::Tuple{Int64, Char, Float64, String}, ::Int64, ::Int64)\n```\n:::\n:::\n\n\n#### Named tuples\n\nTuples can have named components:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\ntypeof((a=2, b='a', c=1.0, d=\"test\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nNamedTuple{(:a, :b, :c, :d), Tuple{Int64, Char, Float64, String}}\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nx = (a=2, b='a', c=1.0, d=\"test\");\nx.c\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n1.0\n```\n:::\n:::\n\n\n## Dictionaries\n\nJulia also has dictionaries: associative collections of key/value pairs:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nx = Dict(\"Name\"=>\"Roger\", \"Age\"=>52, \"Index\"=>0.3)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Roger\"\n```\n:::\n:::\n\n\n`\"Name\"`, `\"Age\"`, and `\"Index\"` are the keys; `\"Roger\"`, `52`, and `0.3` are the values.\n\nThe `=>` operator is the same as the `Pair` function:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\np = \"foo\" => 7\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n\"foo\" => 7\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nq = Pair(\"bar\", 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n\"bar\" => 8\n```\n:::\n:::\n\n\nDictionaries can be heterogeneous (as in this example) and the order doesn't matter. They are also indexable:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nx[\"Name\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n\"Roger\"\n```\n:::\n:::\n\n\nAnd mutable (they can be modified):\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nx[\"Name\"] = \"Alex\";\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nDict{String, Any} with 3 entries:\n  \"Index\" => 0.3\n  \"Age\"   => 52\n  \"Name\"  => \"Alex\"\n```\n:::\n:::\n\n\n## Sets\n\nSets are collections without duplicates. The order of elements doesn't matter.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nset1 = Set([9, 4, 8, 2, 7, 8])\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nSet{Int64} with 5 elements:\n  4\n  7\n  2\n  9\n  8\n```\n:::\n:::\n\n\n:::{.note}\n\nNotice how this is a set of 5 (and not 6) elements: the duplicated 8 didn't matter.\n\n:::\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nset2 = Set([10, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nSet{Int64} with 3 elements:\n  2\n  10\n  3\n```\n:::\n:::\n\n\nYou can compare sets:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\n# The union is the set of elements that are in one OR the other set\nunion(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nSet{Int64} with 7 elements:\n  4\n  7\n  2\n  10\n  9\n  8\n  3\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n# The intersect is the set of elements that are in one AND the other set\nintersect(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nSet{Int64} with 1 element:\n  2\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\n# The setdiff is the set of elements that are in the first set but not in the second\n# Note that the order matters here\nsetdiff(set1, set2)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nSet{Int64} with 4 elements:\n  4\n  7\n  9\n  8\n```\n:::\n:::\n\n\nSets can be heterogeneous:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nSet([\"test\", 9, :a])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nSet{Any} with 3 elements:\n  :a\n  \"test\"\n  9\n```\n:::\n:::\n\n\n## Arrays\n\n### Vectors\n\nUnidimensional arrays in Julia are called vectors.\n\n#### Vectors of one element\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\n[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n1-element Vector{Int64}:\n 3\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\n[3.4]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n1-element Vector{Float64}:\n 3.4\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\n[\"Hello, World!\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n1-element Vector{String}:\n \"Hello, World!\"\n```\n:::\n:::\n\n\n#### Vectors of multiple elements\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\n[3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2-element Vector{Int64}:\n 3\n 4\n```\n:::\n:::\n\n\n### Two dimensional arrays\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\n[3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n1×2 Matrix{Int64}:\n 3  4\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\n[[1, 3] [1, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2×2 Matrix{Int64}:\n 1  1\n 3  2\n```\n:::\n:::\n\n\n### Syntax subtleties\n\nThese 3 syntaxes are equivalent:\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\n[2 4 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nhcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\nThese 4 syntaxes are equivalent:\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\n[2\n 4\n 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\n[2; 4; 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nvcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\nElements separated by semi-colons or end of lines get expanded vertically. \\\nThose separated by commas do not get expanded. \\\nElements separated by spaces or tabs get expanded horizontally.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCompare the outputs of the following:\n\n:::\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\n[1:2; 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\n[1:2\n 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\n[1:2, 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 3:4\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.julia .cell-code}\n[1:2 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n```\n:::\n:::\n\n\n### Arrays and types\n\nIn Julia, arrays can be heterogeneous:\n\n::: {.cell execution_count=35}\n``` {.julia .cell-code}\n[3, \"hello\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n2-element Vector{Any}:\n 3\n  \"hello\"\n```\n:::\n:::\n\n\nThis is possible because all elements of an array, no matter of what types, will always sit below the `Any` type in the type hierarchy.\n\n### Initializing arrays\n\nBelow are examples of some of the functions initializing arrays:\n\n::: {.cell execution_count=36}\n``` {.julia .cell-code}\nrand(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.249345  0.00793018  0.663728\n 0.998355  0.875118    0.180779\n\n[:, :, 2] =\n 0.725175  0.571792  0.553964\n 0.643547  0.526554  0.616254\n\n[:, :, 3] =\n 0.880802  0.469397  0.605801\n 0.852361  0.171367  0.933747\n\n[:, :, 4] =\n 0.931301  0.0818818  0.19103\n 0.599897  0.319441   0.502756\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.julia .cell-code}\nrand(Int64, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 6702406326874167160  6165915128583659168  -1822472517612056062\n 4061234484289689003  9107607056473202841  -4090262653281353378\n\n[:, :, 2] =\n  306849253922920300  -489982795003361732   6038536963128450659\n 8681090713364005587  3246860892816278483  -6238819643508759403\n\n[:, :, 3] =\n 4975057269811224295  2077113908701551085  8803631195298248178\n 2551198027353364335  2959640821649949603   -19796369515897464\n\n[:, :, 4] =\n -4777841673592406946  -7705733057140688475  -1925641677052166951\n -7859106818494873853   4034476672513770221  -3919420842749775402\n```\n:::\n:::\n\n\n::: {.cell execution_count=38}\n``` {.julia .cell-code}\nzeros(Int64, 2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n2×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  0  0  0  0\n```\n:::\n:::\n\n\n::: {.cell execution_count=39}\n``` {.julia .cell-code}\nones(2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n2×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=40}\n``` {.julia .cell-code}\nreshape([1, 2, 4, 2], (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n```\n:::\n:::\n\n\n::: {.cell execution_count=41}\n``` {.julia .cell-code}\nfill(\"test\", (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n2×2 Matrix{String}:\n \"test\"  \"test\"\n \"test\"  \"test\"\n```\n:::\n:::\n\n\n### Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n::: {.cell execution_count=42}\n``` {.julia .cell-code}\na = [-3, 2, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n3-element Vector{Int64}:\n -3\n  2\n -5\n```\n:::\n:::\n\n\n```{.julia}\nabs(a)\n```\n\n```\nLoadError: MethodError: no method matching abs(::Vector{Int64})\n```\n\nThis doesn't work because the function `abs` only applies to single elements.\n\nBy broadcasting `abs`, you apply it to each element of `a`:\n\n::: {.cell execution_count=43}\n``` {.julia .cell-code}\nbroadcast(abs, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nThe dot notation is equivalent:\n\n::: {.cell execution_count=44}\n``` {.julia .cell-code}\nabs.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nIt can also be applied to the pipe, to unary and binary operators, etc.\n\n::: {.cell execution_count=45}\n``` {.julia .cell-code}\na .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to understand the difference between the following 2 expressions:\n\n:::\n\n::: {.cell execution_count=46}\n``` {.julia .cell-code}\nabs.(a) == a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\ntrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=47}\n``` {.julia .cell-code}\nabs.(a) .== a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n3-element BitVector:\n 1\n 1\n 1\n```\n:::\n:::\n\n\n:::{.note}\n\nHint: 0/1 are a short-form notations for false/true in arrays of Booleans.\n\n:::\n\n### Comprehensions\n\nJulia has an array comprehension syntax similar to Python's:\n\n::: {.cell execution_count=48}\n``` {.julia .cell-code}\n[ 3i + j for i=1:10, j=3 ]\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n10-element Vector{Int64}:\n  6\n  9\n 12\n 15\n 18\n 21\n 24\n 27\n 30\n 33\n```\n:::\n:::\n\n\n## Indexing\n\nAs in other mathematically oriented languages such as R, Julia starts indexing at `1`.\n\nIndexing is done with square brackets:\n\n::: {.cell execution_count=49}\n``` {.julia .cell-code}\na = [1 2; 3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n:::\n:::\n\n\n::: {.cell execution_count=50}\n``` {.julia .cell-code}\na[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=51}\n``` {.julia .cell-code}\na[1, :]\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n2-element Vector{Int64}:\n 1\n 2\n```\n:::\n:::\n\n\n::: {.cell execution_count=52}\n``` {.julia .cell-code}\na[:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n2-element Vector{Int64}:\n 1\n 3\n```\n:::\n:::\n\n\n::: {.cell execution_count=53}\n``` {.julia .cell-code}\n# Here, we are indexing a tuple\n(2, 4, 1.0, \"test\")[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n4\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIndex the element on the 3^rd^ row and 2^nd^ column of `b`:\n\n::: {.cell execution_count=54}\n``` {.julia .cell-code}\nb = [\"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"you got it\" \"wrong\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n3×3 Matrix{String}:\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"you got it\"  \"wrong\"\n```\n:::\n:::\n\n\n:::\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n```{.julia}\na = [1 2; 3 4]\na[1, 1]\na[1, :]\n```\n\nHow can I get the second column? \\\nHow can I get the tuple `(2, 4)`? (a tuple is a list of elements)\n\n:::\n\nAs in Python, by default, arrays are passed by sharing:\n\n::: {.cell execution_count=55}\n``` {.julia .cell-code}\na = [1, 2, 3];\na[1] = 0;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n3-element Vector{Int64}:\n 0\n 2\n 3\n```\n:::\n:::\n\n\nThis prevents the unwanted copying of arrays.\n\n",
    "supporting": [
      "collections_files"
    ],
    "filters": [],
    "includes": {}
  }
}