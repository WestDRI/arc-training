{
  "hash": "839049953bde58bd45e610bf39bf5d79",
  "result": {
    "markdown": "---\ntitle: Arrays\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nThis workshop introduces Julia arrays: mutable and indexable collections of elements.\n\n:::\n\n## Vectors\n\nUnidimensional arrays in Julia are called vectors.\n\n### Vectors of one element\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n1-element Vector{Int64}:\n 3\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n[3.4]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1-element Vector{Float64}:\n 3.4\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n[\"Hello, World!\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n1-element Vector{String}:\n \"Hello, World!\"\n```\n:::\n:::\n\n\n### Vectors of multiple elements\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n[3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2-element Vector{Int64}:\n 3\n 4\n```\n:::\n:::\n\n\n## Two dimensional arrays\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n[3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n1×2 Matrix{Int64}:\n 3  4\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n[[1, 3] [1, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n2×2 Matrix{Int64}:\n 1  1\n 3  2\n```\n:::\n:::\n\n\n## Syntax subtleties\n\nThese 3 syntaxes are equivalent:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n[2 4 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nhcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n1×3 Matrix{Int64}:\n 2  4  8\n```\n:::\n:::\n\n\nThese 4 syntaxes are equivalent:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n[2\n 4\n 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n[2; 4; 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nvcat(2, 4, 8)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\ncat(2, 4, 8, dims=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n3-element Vector{Int64}:\n 2\n 4\n 8\n```\n:::\n:::\n\n\nElements separated by semi-colons or end of lines get expanded vertically. \\\nThose separated by commas do not get expanded. \\\nElements separated by spaces or tabs get expanded horizontally.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCompare the outputs of the following:\n\n:::\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n[1:2; 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\n[1:2\n 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\n[1:2, 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 3:4\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\n[1:2 3:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n```\n:::\n:::\n\n\n## Arrays and types\n\nIn Julia, arrays can be heterogeneous:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\n[3, \"hello\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n2-element Vector{Any}:\n 3\n  \"hello\"\n```\n:::\n:::\n\n\nThis is possible because all elements of an array, no matter of what types, will always sit below the `Any` type in the type hierarchy.\n\n## Initializing arrays\n\nBelow are examples of some of the functions initializing arrays:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nrand(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.863369  0.327718  0.272598\n 0.334487  0.274108  0.317215\n\n[:, :, 2] =\n 0.469302   0.884763  0.553609\n 0.0414517  0.87403   0.800876\n\n[:, :, 3] =\n 0.422044  0.374106  0.490072\n 0.956738  0.825053  0.602975\n\n[:, :, 4] =\n 0.839572  0.1706   0.404888\n 0.505377  0.55513  0.0825834\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nrand(Int64, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n    21143369700211586  -2329079667173651890   7365187029239377606\n -2293714951741695278  -2264303625730527137  -7583222958097786137\n\n[:, :, 2] =\n  8760060201699106450  -5209953350204847879  -7664256500448510874\n -4527684092756876495   5424840409867350226  -5439844872381796074\n\n[:, :, 3] =\n 1533046943657187678   4186894401338737193   6379091287087052247\n 8602369898477301137  -1073792973173210604  -1861655349107679040\n\n[:, :, 4] =\n -7967679201380380811  -5662542817100888336  -5878650758951309431\n  7826454313566020366   7278397184662418508  -4521183819994098803\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nzeros(Int64, 2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n2×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  0  0  0  0\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nones(2, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nreshape([1, 2, 4, 2], (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nfill(\"test\", (2, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n2×2 Matrix{String}:\n \"test\"  \"test\"\n \"test\"  \"test\"\n```\n:::\n:::\n\n\n## Indexing\n\nAs in other mathematically oriented languages such as R, Julia starts indexing at `1`.\n\nIndexing is done with square brackets:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\na = [1 2; 3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\na[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\na[1, :]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n2-element Vector{Int64}:\n 1\n 2\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\na[:, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n2-element Vector{Int64}:\n 1\n 3\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIndex the element on the 3^rd^ row and 2^nd^ column of `b`:\n\n:::\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nb = [\"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"wrong\" \"wrong\"; \"wrong\" \"you got it\" \"wrong\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3×3 Matrix{String}:\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"wrong\"       \"wrong\"\n \"wrong\"  \"you got it\"  \"wrong\"\n```\n:::\n:::\n\n\nAs in Python, by default, arrays are passed by sharing:\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\na = [1, 2, 3];\na[1] = 0;\na\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n3-element Vector{Int64}:\n 0\n 2\n 3\n```\n:::\n:::\n\n\nThis prevents the unwanted copying of arrays.\n\n## Broadcasting\n\nTo apply a function to each element of a collection rather than to the collection as a whole, Julia uses broadcasting.\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\na = [-3, 2, -5]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n3-element Vector{Int64}:\n -3\n  2\n -5\n```\n:::\n:::\n\n\n```{.julia}\nabs(a)\n```\n\n```\nLoadError: MethodError: no method matching abs(::Vector{Int64})\n```\n\nThis doesn't work because the function `abs` only applies to single elements.\n\nBy broadcasting `abs`, you apply it to each element of `a`:\n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\nbroadcast(abs, a)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nThe dot notation is equivalent:\n\n::: {.cell execution_count=34}\n``` {.julia .cell-code}\nabs.(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\nIt can also be applied to the pipe, to unary and binary operators, etc.\n\n::: {.cell execution_count=35}\n``` {.julia .cell-code}\na .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n3-element Vector{Int64}:\n 3\n 2\n 5\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to understand the difference between the following 2 expressions:\n\n:::\n\n::: {.cell execution_count=36}\n``` {.julia .cell-code}\nabs.(a) == a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\ntrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.julia .cell-code}\nabs.(a) .== a .|> abs\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n3-element BitVector:\n 1\n 1\n 1\n```\n:::\n:::\n\n\n:::{.note}\n\nHint: 0/1 are a short-form notations for false/true in arrays of Booleans.\n\n:::\n\n## Comprehensions\n\nJulia has an array comprehension syntax similar to Python's:\n\n::: {.cell execution_count=38}\n``` {.julia .cell-code}\n[ 3i + j for i=1:10, j=3 ]\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n10-element Vector{Int64}:\n  6\n  9\n 12\n 15\n 18\n 21\n 24\n 27\n 30\n 33\n```\n:::\n:::\n\n\n",
    "supporting": [
      "arrays_files"
    ],
    "filters": [],
    "includes": {}
  }
}