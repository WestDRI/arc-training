{
  "hash": "2c1ffb773dbdfa4abbe2848d6abf2057",
  "result": {
    "markdown": "---\ntitle: 'Working with tabular data:'\nsubtitle: An example with Covid-19\nauthor: Marie-Hélène Burle\n---\n\n:::{.box}\n\n*Requirements:*\n\n**1 - The current [Julia stable release](https://julialang.org/downloads/)** \\\nInstallation instructions can be found [here](https://julialang.org/downloads/platform/).\n\n**2 - The packages: [CSV](https://github.com/JuliaData/CSV.jl), [DataFrames](https://github.com/JuliaData/DataFrames.jl), [TimeSeries](https://github.com/JuliaStats/TimeSeries.jl), [Plots](https://github.com/JuliaPlots/Plots.jl)** \\\nPackages can be installed with `] add <package>`.\n\n**3 - Covid-19 data from the [Johns Hopkins University CSSE repository](https://github.com/CSSEGISandData/COVID-19)** \\\nClone (`git clone <repo url>`) or download and unzip the repository.\n\n:::\n\n## Load packages\n\n```{.julia}\nusing CSV\nusing DataFrames\nusing Dates          # From the standard Julia library\nusing TimeSeries\nusing NamedArrays\nusing Plots\n```\n\n:::{.note}\n\nWe will use the [GR framework](https://gr-framework.org/) as a backend for Plots.\n\n:::\n\n## Data until March 22, 2020\n\n![](https://imgs.xkcd.com/comics/coronavirus_charts.png){fig-alt=\"noshadow\"}\n\n:::{.caption}\n\nfrom [xkcd.com](https://xkcd.com/)\n\n:::\n\nThe files in the [Johns Hopkins University CSSE repository](https://github.com/CSSEGISandData/COVID-19) have changed over time.\\\nIn this workshop, we will use 2 sets of files:\n\n- a first set from January 22, 2020 until March 22, 2020\n- a second set from January 22, 2020 to the present\n\nBoth sets contain data on confirmed and dead cases for world countries and in some cases their subregions (provinces, states, etc. which I will globally here call \"provinces\").\n\nThe first set also contains numbers of recovered cases which allow to calculate numbers of currently ill persons (of course, keep in mind that all these data represent various degrees of underestimation and are flawed in many ways, amongst which are varying levels of testing efforts both geographically and over time, under-reporting, etc).\n\nThe second set does not contain recovered cases (many overwhelmed countries stopped monitoring this at some point).\n\nWe will play with the first set together and you will then try to play with the second set on your own.\n\n### Load the data\n\n*If you did not clone or download and unzip the Covid-19 data repository in your working directory, adapt the path consequently.*\n\n```{.julia}\n#= create a variable with the path we are interested in;\nthis makes the code below a bit shorter =#\ndir = \"COVID-19/csse_covid_19_data/csse_covid_19_time_series\"\n\n# create a list of the full paths of all the files in dir\nlist = joinpath.(relpath(dir), readdir(dir))\n\n#= read in the 3 csv files with confirmed, dead, and recovered numbers\ncorresponding to the first set of data (until March 22, 2020) =#\ndat = DataFrame.(CSV.File.(list[collect(2:4)]))\n```\n\nWe now have a one-dimensional array of 3 DataFrames called `dat`.\n\n### Transform data into long format\n\n```{.julia}\n# rename some variables to easier names\nDataFrames.rename!.(dat, Dict.(1 => Symbol(\"province\"),\n                               2 => Symbol(\"country\")))\n\n# create a one-dimensional array of strings\nvar = [\"total\", \"dead\", \"recovered\"]\n\n#= transform the data into long format in a vectorized fashion\nusing both our one-dimensional arrays of 3 elements =#\ndatlong = map((x, y) -> stack(x, Not(collect(1:4)),\n                              variable_name = Symbol(\"date\"),\n                              value_name = Symbol(\"$y\")),\n              dat, var)\n```\n\nWe now have a one-dimensional array of 3 DataFrames in long format called `datlong`.\n\n```{.julia}\n# join all elements of this array into a single DataFrame\nall = join(datlong[1], datlong[2], datlong[3],\n           on = [:date, :country, :province, :Lat, :Long])\n\n# get rid of \"Lat\" and \"Long\" and re-order the columns\nselect!(all, [4, 3, 1, 2, 7, 8])\n\n#= turn the year from 2 digits to 4 digits using regular expression\n(in a vectorised fashion by braodcasting with the dot notation);\nthen turn these values into strings, and finally into dates =#\nall.date = Date.(replace.(string.(all[:, 3]),\n                          r\"(.*)(..)$\" => s\"\\g<1>20\\2\"), \"m/dd/yy\");\n\n#= replace the missing values by the string \"NA\"\n(these are not real missing values, but rather non applicable ones) =#\nreplace!(all.province, missing => \"NA\");\n```\n\nWe now have a single DataFrame called `all`, in long format, with the variables `confirmed`, `dead`, `recovered`, and `ill`.\n\nCalculate the number of currently ill individuals (again, in a vectorized fashion, by broadcasting with the dot notation):\n\n```{.julia}\nall.current = all.total .- all.dead .- all.recovered;\n```\n\n### World summary\n\nTo make a single plot with world totals of confirmed, dead, recovered, and ill cases, we want the sums of these variables for each day. We do this by grouping the data by date:\n\n```{.julia}\nworld = by(all, :date,\n           total = :total => sum,\n           dead = :dead => sum,\n           recovered = :recovered => sum,\n           current = :current => sum)\n```\n\nNow we can plot our new variable `world`.\n\nAs our data is a time series, we need to transform it to a TimeArray thanks to the `TimeArray()` function from the TimeSeries package.\n\n```{.julia}\nplot(TimeArray(world, timestamp = :date),\n     title = \"World\",\n     legend = :outertopright,\n     widen = :false)\n```\n\n![](img/world.png){title=\"Global confirmed, dead, recovered, and current up to March 22, 2020\"}\n[Data until March 22, 2020]{.caption}\n\n### Countries/provinces summaries\n\nNow, we want to group the data by country:\n\n```{.julia}\ncountries = groupby(all, :country)\n```\n\nWe also need to know how the authors of the dataset decided to label the various countries and their subregions.\n\nFor example, if you want to see what the data looks like for France, Canada, and India, you can run:\n\n```{.julia}\ncountries[findall(x -> \"France\" in x, keys(countries))]\ncountries[findall(x -> \"Canada\" in x, keys(countries))]\ncountries[findall(x -> \"India\" in x, keys(countries))]\n```\n\nThen you need to subset the data for the countries or provinces you are interested in.\n\nHere are some examples:\n\n```{.julia}\n# countries for which there are data for several provinces\ncanada = all[all[:, :country] .== \"Canada\", :]\nus = all[all[:, :country] .== \"US\", :]\nchina = all[all[:, :country] .== \"China\", :]\n\n# countries with no province data\nskorea = all[all[:, :country] .== \"Korea, South\", :]\ntaiwan = all[all[:, :country] .== \"Taiwan*\", :]\nsingapore = all[all[:, :country] .== \"Singapore\", :]\nitaly = all[all[:, :country] .== \"Italy\", :]\nspain = all[all[:, :country] .== \"Spain\", :]\n\n#= countries wich have subregions spread widely in the world;\nhere, I took the arbitrary decision to only look at the main subregions =#\nfrance = all[all[:, :province] .== \"France\", :]\nuk = all[all[:, :province] .== \"United Kingdom\", :]\n\n# provinces\nbc = all[all[:, :province] .== \"British Columbia\", :]\nny = all[all[:, :province] .== \"New York\", :]\n```\n\nCalculate the totals for Canada, US, and China which all have data for subregions:\n\n```{.julia}\ncanada, us, china = by.([canada, us, china], :date,\n                        total = :total => sum,\n                        dead = :dead => sum,\n                        recovered = :recovered => sum,\n                        current = :current => sum)\n```\n\n```{.julia}\nloclist1 = [canada, us, china]\nloctitles1 = [\"Canada\", \"US\", \"China\"]\n\npcanada, pus, pchina =\n    map((x, y) -> plot(TimeArray(x, timestamp = :date),\n                       title = \"$y\", legend = :outertopright,\n                       widen = :false, dpi = :300),\n        loclist1, loctitles1)\n```\n\n```{.julia}\nloclist2 = [france, bc, ny, taiwan, skorea, singapore, spain, italy, uk]\nloctitles2 = [\"France\", \"BC\", \"NY\", \"Taiwan\", \"South Korea\",\n              \"Singapore\", \"Spain\", \"Italy\", \"UK\"]\n\npfrance, pbc, pny, ptaiwan, pskorea,\npsingapore, pspain, pitaly, puk =\n    map((x, y) -> plot(TimeArray(select(x, Not([:country, :province])),\n                                 timestamp = :date),\n                       title = \"$y\", legend = :outertopright,\n                       widen = :false, dpi = :300),\n        loclist2, loctitles2)\n```\n\nNow, let's plot a few countries/provinces:\n\n#### North America\n\n```{.julia}\nplot(pcanada, pbc, pus, pny,\n     legend = false, titlefontsize = 7, tickfontsize = 6)\n```\n\n![](img/northamerica.png){title=\"Confirmed, dead, recovered, and current in some North American countries/provinces until March 22, 2020\"}\n[Data until March 22, 2020]{.caption}\n\n#### Asia\n\n```{.julia}\nplot(pchina, ptaiwan, pskorea, psingapore,\n     legend = false, titlefontsize = 7, tickfontsize = 6)\n```\n\n![](img/asia.png){title=\"Confirmed, dead, recovered, and current in some Asian countries until March 22, 2020\"}\n[Data until March 22, 2020]{.caption}\n\n#### Europe\n\n```{.julia}\nplot(pfrance, pspain, pitaly, puk,\n     legend = false, titlefontsize = 7, tickfontsize = 6)\n```\n\n![](img/europe.png){title=\"Confirmed, dead, recovered, and current in some European countries until March 22, 2020\"}\n[Data until March 22, 2020]{.caption}\n\n## Data up to the present\n\n### Summary graphs\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWrite the code to create an up-to-date graph for the world using the files:<br>\n`time_series_covid19_confirmed_global.csv` and `time_series_covid19_deaths_global.csv`.\n\n:::\n\nHere is the result:\n\n![](img/world1.png){title=\"Global confirmed and dead\"}\n[Data until March 25, 2020]{.caption}\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCreate up-to-date graphs for the countries and/or provinces of your choice.\n\n:::\n\nHere are a few possible results:\n\n![](img/4countries.png){title=\"Confirmed and dead for Italy, Spain, the US, and Canada\"}\n[Data until March 25, 2020]{.caption}\n\n### Countries comparison\n\nOur side by side graphs don't make comparisons very easy since they vary greatly in their axes scales.\n\nOf course, we could constrain them to have the same axes, but then, why not plot multiple countries or provinces in the same graph?\n\n```{.julia}\ncanada[!, :loc] .= \"Canada\";\nchina[!, :loc] .= \"China\";\n\nall = join(all, canada, china, on = [:date, :total, :dead, :loc],\n           kind = :outer)\n\nconfirmed = unstack(all[:, collect(3:5)], :loc, :total)\n\nconf_sel = select(confirmed,\n                  [:date, :Italy, :Spain, :China, :Iran,\n                   :France, :US, Symbol(\"South Korea\"), :Canada])\n\nplot(TimeArray(conf_sel, timestamp = :date),\n     title = \"Confirmed across a few countries\",\n     legend = :outertopright, widen = :false)\n```\n\n![](img/confirmed.png){title=\"Number of confirmed cases in a few countries\"}\n[Data until March 25, 2020]{.caption}\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWrite the code to make a similar graph with the number of deaths in a few countries of your choice.\n\n:::\n\nHere is a possible result:\n\n![](img/dead.png){title=\"Number of deaths in a few countries\"}\n[Data until March 25, 2020]{.caption}\n\n",
    "supporting": [
      "tabular_files"
    ],
    "filters": [],
    "includes": {}
  }
}