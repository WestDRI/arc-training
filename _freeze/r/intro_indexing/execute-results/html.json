{
  "hash": "d0e1eeb6474f4d3217a7a653c23bfb39",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Indexing\naliases:\n  - indexing.html\nauthor: Marie-Hélène Burle\n---\n\n\n:::{.def}\n\nThis section covers indexing from the various data structures.\n\n:::\n\n## Indexing atomic vectors\n\n:::{.example}\n\nHere is an example with an atomic vector of size one:\n\n:::\n\nIndexing in R starts at `1` and is done with square brackets next to the element to index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\nWhat happens if we index out of range?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n:::{.example}\n\nExample for an atomic vector with multiple elements:\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2, 4, 1)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 1\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  1 NA\n```\n\n\n:::\n:::\n\n\n### Modifying mutable objects\n\nIndexing also allows to modify some of the values of mutable objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 1\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2] <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 0 1\n```\n\n\n:::\n:::\n\n\n### Copy-on-modify\n\nNot all languages behave the same when you assign the same mutable object to several variables, then modify one of them.\n\n#### In Python: no copy-on-modify\n\n:::{.note}\n\nDon't try to run this code in R. This is for information only.\n\n:::\n\n```{.python filename=\"Python\"}\na = [1, 2, 3]\nb = a\nb\n```\n\n```\n[1, 2, 3]\n```\n\n```{.python filename=\"Python\"}\na[0] = 4           # In Python, indexing starts at 0\na\n```\n\n```\n[4, 2, 3]\n```\n\n```{.python filename=\"Python\"}\nb\n```\n\n```\n[4, 2, 3]\n```\n\nModifying `a` also modifies `b`: this is because no copy is made when you modify `a`. If you want to keep `b` unchanged, you need to assign an explicit copy of `a` to it with `b = copy.copy(a)`.\n\n#### In R: copy-on-modify\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, 3)\nb <- a\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\na[1] <- 4          # In R, indexing starts at 1\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\nHere, the default is to create a new copy in memory when `a` is transformed so that `b` remains unchanged.\n\n## Indexing matrices and arrays\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:12, nrow = 3, ncol = 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- array(as.double(1:24), c(3, 2, 4))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   13   16\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   19   22\n[2,]   20   23\n[3,]   21   24\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2, 1, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n## Indexing lists\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(2L, 3:8, c(2, 1), FALSE, \"string\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3 4 5 6 7 8\n\n[[3]]\n[1] 2 1\n\n[[4]]\n[1] FALSE\n\n[[5]]\n[1] \"string\"\n```\n\n\n:::\n:::\n\n\nIndexing a list returns a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nTo extract elements of a list, double square brackets are required:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to extract the number `7` from this list.\n\n:::\n\n<!-- ```{r} -->\n<!-- x[[2]][5] -->\n<!-- ``` -->\n\n## Indexing data frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(\n  country = c(\"Canada\", \"USA\", \"Mexico\"),\n  var = c(2.9, 3.1, 4.5)\n)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  country var\n1  Canada 2.9\n2     USA 3.1\n3  Mexico 4.5\n```\n\n\n:::\n:::\n\n\nIndexing dataframes can be done by using indices, as we saw for matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"USA\"\n```\n\n\n:::\n:::\n\n\nIt can also be done using column names thanks to the `$` symbol (a column is a vector, so indexing from a column is the same as indexing from a vector):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$country[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"USA\"\n```\n\n\n:::\n:::\n\n\nA data frame is actually a list of vectors representing the various columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nIndexing a column can thus also be done by indexing the element of the list with double square brackets (although this is a slower method).\n\nWe get the same result with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"USA\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}