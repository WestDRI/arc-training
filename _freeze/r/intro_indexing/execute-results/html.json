{
  "hash": "29b386dc6b728cbc6d2d70c008155c12",
  "result": {
    "markdown": "---\ntitle: Indexing\naliases:\n  - indexing.html\nauthor: Marie-Hélène Burle\n---\n\n\n:::{.def}\n\nThis section covers indexing from the various data structures.\n\n:::\n\n## Indexing atomic vectors\n\n:::{.example}\n\nHere is an example with an atomic vector of size one:\n\n:::\n\nIndexing in R starts at `1` and is done with square brackets next to the element to index:\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-1_724f6a7a6a60ce53df2624db58eb402a'}\n\n```{.r .cell-code}\nx <- 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nWhat happens if we index out of range?\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-2_ae634e24d7cdde390ed56f5e362056ce'}\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n:::{.example}\n\nExample for an atomic vector with multiple elements:\n\n:::\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-3_47ad83fd0b1ec4727a7f121fef05ee59'}\n\n```{.r .cell-code}\nx <- c(2, 4, 1)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 1\n```\n:::\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  1 NA\n```\n:::\n:::\n\n\n### Modifying mutable objects\n\nIndexing also allows to modify some of the values of mutable objects:\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-4_d90e8245fdd93bcc052cfc504affbf0b'}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 1\n```\n:::\n\n```{.r .cell-code}\nx[2] <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 0 1\n```\n:::\n:::\n\n\n### Copy-on-modify\n\nNot all languages behave the same when you assign the same mutable object to several variables, then modify one of them.\n\n#### In Python: no copy-on-modify\n\n:::{.note}\n\nDon't try to run this code in R. This is for information only.\n\n:::\n\n```{.python filename=\"Python\"}\na = [1, 2, 3]\nb = a\nb\n```\n\n```\n[1, 2, 3]\n```\n\n```{.python filename=\"Python\"}\na[0] = 4           # In Python, indexing starts at 0\na\n```\n\n```\n[4, 2, 3]\n```\n\n```{.python filename=\"Python\"}\nb\n```\n\n```\n[4, 2, 3]\n```\n\nModifying `a` also modifies `b`: this is because no copy is made when you modify `a`. If you want to keep `b` unchanged, you need to assign an explicit copy of `a` to it with `b = copy.copy(a)`.\n\n#### In R: copy-on-modify\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-5_92fb5c62c4747d8fddc5ae7b95f52dbc'}\n\n```{.r .cell-code}\na <- c(1, 2, 3)\nb <- a\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\na[1] <- 4          # In R, indexing starts at 1\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 2 3\n```\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nHere, the default is to create a new copy in memory when `a` is transformed so that `b` remains unchanged.\n\n## Indexing matrices and arrays\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-6_6eb673fa192da9caa4ce8d5d2d54ae07'}\n\n```{.r .cell-code}\nx <- matrix(1:12, nrow = 3, ncol = 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n\n```{.r .cell-code}\nx[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\nx <- array(as.double(1:24), c(3, 2, 4))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   13   16\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   19   22\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\nx[2, 1, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n:::\n\n\n## Indexing lists\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-7_f67fb1030de7491b88e311d31da1b440'}\n\n```{.r .cell-code}\nx <- list(2L, 3:8, c(2, 1), FALSE, \"string\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3 4 5 6 7 8\n\n[[3]]\n[1] 2 1\n\n[[4]]\n[1] FALSE\n\n[[5]]\n[1] \"string\"\n```\n:::\n:::\n\n\nIndexing a list returns a list:\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-8_48c2e99ead4f3b0b48b3f462080a9ec8'}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nTo extract elements of a list, double square brackets are required:\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-9_2ac7397795c7bc3ce1149d942c5b82ac'}\n\n```{.r .cell-code}\nx[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to extract the number `7` from this list.\n\n:::\n\n<!-- ```{r} -->\n<!-- x[[2]][5] -->\n<!-- ``` -->\n\n## Indexing data frames\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-10_abd90dc67a936abbc2be17c09405892a'}\n\n```{.r .cell-code}\nx <- data.frame(\n  country = c(\"Canada\", \"USA\", \"Mexico\"),\n  var = c(2.9, 3.1, 4.5)\n)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country var\n1  Canada 2.9\n2     USA 3.1\n3  Mexico 4.5\n```\n:::\n:::\n\n\nA data frame is a list of atomic vectors representing the various columns:\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-11_4ea142d62ac9c91f295e281129792be0'}\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country\n1  Canada\n2     USA\n3  Mexico\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Canada\" \"USA\"    \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nIndexing dataframes can also be done using the column names:\n\n\n::: {.cell hash='intro_indexing_cache/html/unnamed-chunk-12_3299c7fdba0e4392d2d3d44f08482ab7'}\n\n```{.r .cell-code}\nx$country\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Canada\" \"USA\"    \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\nidentical(x[[1]], x$country)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}