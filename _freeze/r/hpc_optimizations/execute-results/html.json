{
  "hash": "71b04e89e816fc7875be3359c0ff28d7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Optimizations\naliases:\n  - optimizations.html\nauthor: Marie-Hélène Burle\n---\n\n\n\n\n:::{.def}\n\nA lot of hardware is not the answer to poorly written code. Before considering parallelization, you should think about ways to optimize your code sequentially.\n\nWhy?\n\n- not all code can be parallelized,\n- parallelization is costly (overhead of parallelization and, if you use a supercomputer, waiting time to access an Alliance cluster or money spent on a commercial cloud),\n- the optimization of the sequential code will also benefit the parallel code.\n\nIn many cases, writing better code will save you more computing time than parallelization.\n\nIn this section, we will cover several principles by playing with the programmatic implementation of the [fizz buzz](https://en.wikipedia.org/wiki/Fizz_buzz#:~:text=Fizz%20buzz%20is%20a%20group,with%20the%20word%20%22fizzbuzz%22) game.\n\n:::\n\n## Toy example\n\n[Fizz buzz](https://en.wikipedia.org/wiki/Fizz_buzz#:~:text=Fizz%20buzz%20is%20a%20group,with%20the%20word%20%22fizzbuzz%22) is a children game to practice divisions. Players take turn counting out loud while replacing:\n\n- any number divisible by 3 with the word \"Fizz\",\n- any number divisible by 5 with the word \"Buzz\",\n- any number divisible by both 3 and 5 with the word \"FizzBuzz\".\n\nLet's write functions that output series from `1` to `n` following these rules and time them to draw general principles about code efficiency.\n\n## Setup\n\nFirst of all, we need to load the necessary modules:\n\n```{.bash}\nmodule load StdEnv/2023 gcc/13.3 r/4.4.0\n```\n\nThen we need to launch a job. There are 2 options:\n\n### Interactive job\n\nIf there are few of us, we will use an interactive session with one CPU each. To launch it, run the following (in the Bash terminal, not in R):\n\n```{.bash}\nsalloc --time=2:00:00 --mem-per-cpu=3500M\n```\n\nWe can then launch R:\n\n```{.bash}\nR\n```\n\nNow, we load the benchmarking package that we will use throughout this section:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bench)\n```\n:::\n\n\n\n\n### Batch jobs\n\nIf there are more of us than there are CPUs in the cluster, we will run batch jobs. In this Case:\n\n- Create an R script called `optim.R` with the code to run (you can reuse the same script for all sections on this page by editing it). Don't forget to load the package `bench` in your script.\n- Create a bash script called `optim.sh` with the following:\n\n```{.bash filename=\"optim.sh\"}\n#!/bin/bash\n#SBATCH --time=15\n#SBATCH --mem-per-cpu=3500M\n\nmodule load StdEnv/2023 gcc/13.3 r/4.4.0\nRscript optim.R\n```\n\n- Run the jobs with:\n\n```sh\nsbatch optim.sh\n```\n\n## Optimizations\n\n### Proper memory pre-allocation\n\nIn order to store the results of a loop, we need to create an object and assign to it the result of the loop at each iteration. In this first function, we create an empty object `z` of class integer and of length `0` for that purpose:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(n) {\n  z <- integer()\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\n\n\nThe second function is similar, but this time, we initialize `z` with its final length. This means that we are pre-allocating memory for the full vector before we run the loop instead of growing the vector at each iteration:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function(n) {\n  z <- integer(n)\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\n\n\nLet's make sure that our functions work by testing it on a short series:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nf2(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n:::\n\n\n\n\nShort series are good to get a feel for what our functions return, but they would be inadequate for benchmarking because the functions would run too fast and the timing differences would be too small. Always make sure that your function runs are long enough when you benchmark.\n\nLet's pick a bigger value for `n`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1e5\n```\n:::\n\n\n\n\nNow, we can benchmark our functions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f1(n), f2(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f1(n)         306ms    311ms      3.22   16.55MB     11.3\n2 f2(n)         214ms    219ms      4.58    1.15MB     16.8\n```\n\n\n:::\n:::\n\n\n\n\n`f2()` is consistently faster, although not by much (speedup of 1.4). In many cases, the difference you will find will be a lot greater.\n\nIn the cluster, because memory is allocated outside of R (by Slurm), it is not tracked by `mark()` (see [documentation](https://mpn.metworx.com/packages/bench/1.1.1/reference/summary.bench_mark.html#value)).\n\nThe output you can see on this site was obtained on my laptop. It shows that a properly written function with pre-allocated memory uses 14 times less memory.\n\nNow, notice how our function actually returns a character and not an integer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(f2(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nSo let's create the object `z`, which will hold the results of our loop, directly of the proper type:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf3 <- function(n) {\n  z <- character(n)\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\n\n\nAnd now for the benchmark against `f2()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f2(n), f3(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f2(n)         214ms    219ms      4.56    1.23MB     15.2\n2 f3(n)         217ms    219ms      4.51   863.8KB     16.5\n```\n\n\n:::\n:::\n\n\n\n\nYou can see that there is no difference in timing, but that `f3()` is still slightly better because it uses a little less memory. This shows that type matters, but **the most important thing you want to worry about in memory pre-allocation is the final length of your objects**.\n\n### No, loops are not a big 'no no'\n\nBy now, you might be thinking: \"Wait... aren't loops a big 'no no' in R? I've always been told that they are slow and that one should always use functional programming! We are talking about optimization in this course and we are using loops?!?\"\n\nThere are a lot of misconceptions around R loops. They can be very slow if you don't pre-allocate memory. Otherwise they are almost always faster than functions (the `apply()` family or the [tidyverse](https://www.tidyverse.org/) equivalent of the `purrr::map()` family). You can choose to use a functional programming approach for style and readability, but not for speed.\n\nLet's test it.\n\nFirst we create a function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf4 <- function(n) {\n  if(n %% 3 == 0 && n %% 5 == 0) {\n    \"FizzBuzz\"\n  } else if(n %% 3 == 0) {\n    \"Fizz\"\n  } else if(n %% 5 == 0) {\n    \"Buzz\"\n  } else {\n    n\n  }\n}\n```\n:::\n\n\n\n\nThen we have to pass our function through `sapply()`.\n\nLet's make sure that the code works:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:20, f4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n:::\n\n\n\n\nNow, we compare the timing with that of `f3()` (our fastest function so far):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f3(n), sapply(1:n, f4))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f3(n)              262ms    267ms      3.75   781.3KB     16.9\n2 sapply(1:n, f4)    355ms    372ms      2.68    3.29MB     12.1\n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, the loop is faster (speed up of 1.4). On my laptop, it also used 4 times less memory.\n\n### Avoid unnecessary operations\n\n#### Example 1\n\nCalling `z` as the last command in our function is the same as calling `return(z)`.\n\nFrom the R documentation:\n\n> If the end of a function is reached without calling return, the value of the last evaluated expression is returned.\n\nNow, what about using `print()` instead?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf5 <- function(n) {\n  z <- character(n)\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  print(z)\n}\n```\n:::\n\n\n\n\nLet's test that it works:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf5(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n:::\n\n\n\n\nNow, let's benchmark it against `f3()` (still our fastest function so far):\n\n```{.r}\nmark(f3(n), f5(n))\n```\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"     \"Fizz\"     \"22\"       \"23\"       \"Fizz\"    \n[25] \"Buzz\"     \"26\"       \"Fizz\"     \"28\"       \"29\"       \"FizzBuzz\"\n[31] \"31\"       \"32\"       \"Fizz\"     \"34\"       \"Buzz\"     \"Fizz\"    \n[37] \"37\"       \"38\"       \"Fizz\"     \"Buzz\"     \"41\"       \"Fizz\"\n...\n\n# A tibble: 2 × 13\n  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  <bch:expr> <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>\n1 f3(n)         116ms  120ms      7.45        NA    26.1      4    14      537ms\n2 f5(n)         925ms  925ms      1.08        NA     3.24     1     3      925ms\n# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>\nWarning message:\nSome expressions had a GC in every iteration; so filtering is disabled.\n```\n\n`f5()` is 7.7 times slower.\n\nWhat happened?\n\n`print()` returns its argument, but it additionally prints it to the standard output. This is why the `mark()` function printed the output of `f5()` before printing the timings.\n\nAs you can see, printing takes a long time.\n\nIf you are evaluating `f3()` on its own (e.g. `f3(20)`), the returned result will also be printed to standard output and both functions will be equivalent. However, if you are using the function in another context, printing becomes an unnecessary and timely operation and `f5()` would be a very bad option. `f5()` is thus not a good function.\n\nHere is an example in which `f5()` would perform a totally unnecessary operation that `f3()` avoids:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- f3(20)\n```\n:::\n\n\n\n\n:::{.note}\n\nNo unnecessary printing.\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- f5(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n:::\n\n\n\n\n:::{.note}\n\nUnnecessary printing.\n\n:::\n\nEven worse would be to use:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf6 <- function(n) {\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      print(\"FizzBuzz\")\n    } else if(i %% 3 == 0) {\n      print(\"Fizz\")\n    } else if(i %% 5 == 0) {\n      print(\"Buzz\")\n    } else {\n      print(i)\n    }\n  }\n}\n```\n:::\n\n\n\n\nLet's test it:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf6(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] \"Fizz\"\n[1] 4\n[1] \"Buzz\"\n[1] \"Fizz\"\n[1] 7\n[1] 8\n[1] \"Fizz\"\n[1] \"Buzz\"\n[1] 11\n[1] \"Fizz\"\n[1] 13\n[1] 14\n[1] \"FizzBuzz\"\n[1] 16\n[1] 17\n[1] \"Fizz\"\n[1] 19\n[1] \"Buzz\"\n```\n\n\n:::\n:::\n\n\n\n\nThe values are correct, although the output is of a different type (`NULL` instead of a `character` since our function didn't return anything and the values got printed as a side effect of the for loop).\n\nBenchmark against `f3()`:\n\n```{.r}\nmark(f3(n), f6(n), check = F)\n```\n\n```\n# A tibble: 2 × 13\n  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  <bch:expr> <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>\n1 f3(n)         105ms  108ms     9.10         NA    30.9      5    17      549ms\n2 f6(n)            6s     6s     0.167        NA     3.34     1    20         6s\n# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>\nWarning message:\nSome expressions had a GC in every iteration; so filtering is disabled.\n```\n\n:::{.note}\n\nWe need to disable the check here because the results of the two functions are not the same.\n\n:::\n\nHere the difference in timing is a factor of 55.5 due to all those printing calls.\n\n#### Example 2\n\nOne modulo operation and equality test can be removed by replacing `i %% 3 == 0 && i %% 5 == 0` by `i %% 15 == 0`. We now have three modulo operations and equality tests per iteration instead of four. This gives us a little speedup:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf7 <- function(n) {\n  z <- character(n)\n  for(i in 1:n) {\n    if(i %% 15 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\n\n\nThe benchmark with our fastest function `f3()` gives:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f3(n), f7(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f3(n)         326ms    330ms      3.03     781KB     12.1\n2 f7(n)         311ms    311ms      3.22     852KB     11.3\n```\n\n\n:::\n:::\n\n\n\n\nBut we can remove an additional modulo operation and equality test at each iteration by assigning `i %% 3 == 0` and `i %% 5 == 0` to variables:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf8 <- function(n) {\n  z <- character(n)\n  for(i in 1:n) {\n    div3 <- (i %% 3 == 0)\n    div5 <- (i %% 5 == 0)\n    if(div3 && div5) {\n      z[i] <- \"FizzBuzz\"\n    } else if(div3) {\n      z[i] <- \"Fizz\"\n    } else if(div5) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\n\n\nNow we only have two modulo operations and equality tests per iteration and we get another little speedup when we benchmark it against `f7()`, our new best function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f7(n), f8(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f7(n)         183ms    186ms      5.36     781KB     19.7\n2 f8(n)         173ms    175ms      5.72     856KB     17.2\n```\n\n\n:::\n:::\n\n\n\n\n#### Example 3\n\nWe can assign `1:n` to `z` instead of initializing it as an empty vector, thus rendering the assignment of `i` to `z[i]` in the last else statement unnecessary:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf9 <- function(n) {\n  z <- 1:n\n  for(i in z) {\n    div3 <- (i %% 3 == 0)\n    div5 <- (i %% 5 == 0)\n    if(div3 && div5) {\n      z[i] <- \"FizzBuzz\"\n    } else if(div3) {\n      z[i] <- \"Fizz\"\n    } else if(div5) {\n      z[i] <- \"Buzz\"\n    } \n  }\n  z\n}\n```\n:::\n\n\n\n\nThis function works:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf9(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n:::\n\n\n\n\nand we get a little more speedup when compared to `f8()`—our current best function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f8(n), f9(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f8(n)         180ms    182ms      5.37   781.3KB     17.9\n2 f9(n)         130ms    134ms      7.47    1.15MB     18.7\n```\n\n\n:::\n:::\n\n\n\n\n### Vectorize whenever possible\n\nWe can actually get rid of the loop and use a vectorized approach instead, utilizing what really constitutes the strength of the R language. The following is pure R style at its best:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf10 <- function(n) {\n  z <- 1:n\n  div3 <- (z %% 3 == 0)\n  div5 <- (z %% 5 == 0)\n  z[div3] <- \"Fizz\"\n  z[div5] <- \"Buzz\"\n  z[(div3 & div5)] <- \"FizzBuzz\"\n  z\n}\n```\n:::\n\n\n\n\nThis still give us the same result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf10(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n\n\n:::\n:::\n\n\n\n\nNow for the benchmark with `f9()` (our best function up to this point):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f9(n), f10(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f9(n)       114.6ms  117.8ms      8.11    1.21MB    17.8 \n2 f10(n)       30.2ms   33.9ms     29.2     5.62MB     1.94\n```\n\n\n:::\n:::\n\n\n\n\nThe speedup of 3.5 shows the importance of using vectorization whenever possible.\n\n### Replace costly operations where possible\n\nSometimes, it isn't obvious that one method will be faster than another. Benchmarking alternative expressions can teach you which ones are faster.\n\nFor instance, it is much faster to index a column from a dataframe by its name (e.g. `dataframe$column1`) than by using list indexing (e.g. `dataframe[[1]]`). Until you test it, there is nothing obvious about this because it has to do with how R processes the data under the hood.\n\n### Use faster packages\n\nTo achieve the best performance, you should look for efficient packages and learn them.\n\nPackages exist which bring much more efficiency than can be achieved with base R or the tidyverse. In the case of data frames for example, there is [data.table](https://cran.r-project.org/web/packages/data.table/index.html).\n\n### Conclusion\n\nStarting from our first function `f1()`, we have gained a speedup of 6, simply by writing better code and without using parallelization and additional hardware:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmark(f1(n), f10(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f1(n)         279ms  289.6ms      3.45   16.63MB    13.8 \n2 f10(n)       34.7ms   36.6ms     26.9     5.57MB     1.92\n```\n\n\n:::\n:::\n\n\n\n\nIf we used a silly function such as `f6()` as our starting function, the speedup would be 333.\n\n:::{.emph}\n\nBefore thinking about running R in parallel or throwing GPUs at your problem, hoping that these would solve the slowness of your code, identify the bottlenecks and rewrite the slow sections more efficiently.\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}