{
  "hash": "784c5daccd944a9a97de0aaa0acf016a",
  "result": {
    "markdown": "---\ntitle: Optimizations\nauthor: Marie-Hélène Burle\n---\n\n\n:::{.def}\n\nA lot of hardware is not the answer to poorly written code. Before considering parallelization, you should think about ways to optimize your code sequentially.\n\nWhy?\n\n- Not all code can be parallelized.\n- Parallelization is costly (waiting time to access a cluster or money).\n- The optimization of the sequential code will also benefit the parallel code.\n\nIn many cases, writing better code will save you more computing time than parallelization.\n\nIn this section, we will cover several principles by playing with the programmatic implementation of the [fizz buzz](https://en.wikipedia.org/wiki/Fizz_buzz#:~:text=Fizz%20buzz%20is%20a%20group,with%20the%20word%20%22fizzbuzz%22) game.\n\n:::\n\n## Toy example\n\n[Fizz buzz](https://en.wikipedia.org/wiki/Fizz_buzz#:~:text=Fizz%20buzz%20is%20a%20group,with%20the%20word%20%22fizzbuzz%22) is a children game to practice divisions. Players take turn counting out loud while replacing:\n\n- any number divisible by 3 with the word \"Fizz\",\n- any number divisible by 5 with the word \"Buzz\",\n- any number divisible by both 3 and 5 with the word \"FizzBuzz\".\n\nLet's write functions to solve the game and time them to draw some general principles about more efficient code.\n\nWe will use `bench::mark()` to benchmark our solutions. Let's load it:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-1_7d3d7e25a28318a54726d84c6d19c3d5'}\n\n```{.r .cell-code}\nlibrary(bench)\n```\n:::\n\n\n## Pre-allocate memory\n\nIn this first function, we create an empty object `z` of class integer and of length `0` that will hold the result of a loop, then we run the loop and at each iteration, we add a new value to `z`:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-2_91f5cc0c98bf3b469cd09e08c8617b23'}\n\n```{.r .cell-code}\nf1 <- function(n) {\n  z <- integer()\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\nThe second function is very similar, but this time, we create an empty object `z` of class integer and of length matching the final length `z` will have after running the loop. This means that we are pre-allocating memory for the full vector before we run the loop instead of growing the vector at each iteration:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-3_dfd80df804d5c0fdede977a3bbcd7ad1'}\n\n```{.r .cell-code}\nf2 <- function(n) {\n  z <- integer(n)\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n```\n:::\n\n\nLet's make sure that our functions work by testing it on a small number:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-4_a56b508527d3e60776d18cfe86202c69'}\n\n```{.r .cell-code}\nf1(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n:::\n\n```{.r .cell-code}\nf2(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n:::\n:::\n\n\nNow, let's benchmark them for a large number:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-5_10273f39f05d623925cfe3f06f50a499'}\n\n```{.r .cell-code}\nn <- 1e5\nmark(f1(n), f2(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f1(n)         136ms    137ms      7.18   16.55MB     25.1\n2 f2(n)         124ms    126ms      7.89    1.15MB     31.6\n```\n:::\n:::\n\n\n`f2()` is consistently faster. While in this example the difference is very slight, pre-allocating the object that will hold the result of a loop before running the loop can make a big difference.\n\nAlso, note the difference in memory allocation.\n\n## Aren't loops a big 'no no' in R?\n\nBy now, you might be thinking: \"Wait... aren't loops a big 'no no' in R? I've always been told that they are slow and that one should always use functional programming! We are talking about optimization in this course and we are using loops?!?\"\n\nThere are a lot of misconceptions around R loops. They can be very slow if you don't pre-allocate memory. Otherwise they are almost always faster than functions (the `apply()` family or the [tidyverse](https://www.tidyverse.org/) equivalent of the `purrr::map()` family). You can choose to use a functional programming approach for style and readability, but not for speed.\n\nLet's test it.\n\nFirst we create a function:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-6_8a2e78af0c2994dedf9a473f82a000da'}\n\n```{.r .cell-code}\nfb <- function(n) {\n  if(n %% 3 == 0 && n %% 5 == 0) {\n    \"FizzBuzz\"\n  } else if(n %% 3 == 0) {\n    \"Fizz\"\n  } else if(n %% 5 == 0) {\n    \"Buzz\"\n  } else {\n    n\n  }\n}\n```\n:::\n\n\nThen we pass it through `sapply()`. We can test that it works on a small number:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-7_4008756055ac10f680d258d99c458f80'}\n\n```{.r .cell-code}\nsapply(1:20, fb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n:::\n:::\n\n\nFinally, we compare the timing with that of `f2()`:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-8_44ae1e210fb605ed6b5532087a0bfa0b'}\n\n```{.r .cell-code}\nmark(f2(n), sapply(1:n, fb))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f2(n)              140ms    143ms      6.95    1.15MB     31.3\n2 sapply(1:n, fb)    172ms    190ms      5.34    3.29MB     28.5\n```\n:::\n:::\n\n\nAs you can see, the loop is faster.\n\n## Avoid unnecessary operations\n\n### Example 1\n\nCalling `z` as the last command in our function is the same as calling `return(z)`.\n\nFrom the R documentation:\n\n> If the end of a function is reached without calling return, the value of the last evaluated expression is returned.\n\nNow, what about using `print()` instead?\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-9_c36d2dbec45b286f352837837371d578'}\n\n```{.r .cell-code}\nf3 <- function(n) {\n  z <- integer(n)\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  print(z)\n}\n```\n:::\n\n\nLet's benchmark it against `f2()`:\n\n```{.r}\nmark(f2(n), f3(n))\n```\n\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"     \"Fizz\"     \"22\"       \"23\"       \"Fizz\"    \n[25] \"Buzz\"     \"26\"       \"Fizz\"     \"28\"       \"29\"       \"FizzBuzz\"\n[31] \"31\"       \"32\"       \"Fizz\"     \"34\"       \"Buzz\"     \"Fizz\"    \n[37] \"37\"       \"38\"       \"Fizz\"     \"Buzz\"     \"41\"       \"Fizz\"\n...\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f2(1e+05)  151.88ms 157.65ms     6.30     1.25MB     29.9\n2 f3(1e+05)     3.25s    3.25s     0.308    1.04GB     26.8\n```\n\nWhat happened?\n\n`print()` returns its argument, but it additionally prints it to the standard output. This is why the `mark()` function printed the output of `f3()` before printing the timings.\n\nAs you can see, printing takes a long time.\n\n:::{.note}\n\nThe code in this website is run by Quarto. Since, by default, RStudio will only print the first 1,000 results, the timing you will get for `f3()` in RStudio will be much less bad as it won't include the time it takes to print the remaining 99,000 results.\n\n:::\n\nIf you are evaluating `f2()` on its own (e.g. `f2(20)`), the returned result will also be printed to standard output and both functions will be equivalent. However, if you are using the function in another context, printing becomes an unnecessary and timely operation and `f3()` would be a very bad option. `f3()` is thus not a good function.\n\nHere is an example in which `f3()` would perform a totally unnecessary operation that `f2()` avoids:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-10_334075eab3ec43e32a157ca471281631'}\n\n```{.r .cell-code}\na <- f2(20)\n```\n:::\n\n\n:::{.note}\n\nNo unnecessary printing.\n\n:::\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-11_92f79001dcaa7af5a9dff485f070c0c5'}\n\n```{.r .cell-code}\na <- f3(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n:::\n:::\n\n\n:::{.note}\n\nUnnecessary printing.\n\n:::\n\nFor 1e5, the difference in timing between running an unnecessary printing vs not is a factor of 21!\n\nEven worse would be to use:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-12_569bd10d56aa2e9bebd8164ef43e3b50'}\n\n```{.r .cell-code}\nf4 <- function(n) {\n  for(i in 1:n) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      print(\"FizzBuzz\")\n    } else if(i %% 3 == 0) {\n      print(\"Fizz\")\n    } else if(i %% 5 == 0) {\n      print(\"Buzz\")\n    } else {\n      print(i)\n    }\n  }\n}\n```\n:::\n\n\nHere the difference in timing is a factor of 50...\n\n### Example 2\n\nOne modulo operation and equality test can be removed by replacing `i %% 3 == 0 && i %% 5 == 0` by `i %% 15 == 0`. The difference isn't huge, but there is a slight speedup:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-13_93ae8d2dbb81024237d170e3d7185344'}\n\n```{.r .cell-code}\nf5 <- function(n) {\n  z <- integer(n)\n  for(i in 1:n) {\n    if(i %% 15 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- i\n    }\n  }\n  z\n}\n\nmark(f2(n), f5(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f2(n)         124ms    128ms      7.78    1.24MB     31.1\n2 f5(n)         114ms    118ms      8.44    1.22MB     30.4\n```\n:::\n:::\n\n\n### Example 3\n\nLouis Arsenault-Mahjoubi—who attended this workshop—found ways to get rid of several operations and get a speedup of 1.7 over `f2()`.\n\nFirst, we can assign `1:n` to `z` instead of pre-allocating memory with an empty vector, thus rendering the assignment of `i` to `z[i]` unnecessary in the last else statement:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-14_147b0ac0bcad190ae74d0123e4e5caae'}\n\n```{.r .cell-code}\nf_louis1 <- function(n) {\n  z <- 1:n\n  for(i in z) {\n    if(i %% 3 == 0 && i %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(i %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(i %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } \n  }\n  z\n}\n```\n:::\n\n\nThis function works:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-15_96220332925ba26af103adf6cd74a16c'}\n\n```{.r .cell-code}\nf_louis1(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n:::\n:::\n\n\n... and is faster (speedup of 1.3):\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-16_7c858291f03eb7830c46bca6642ebbfd'}\n\n```{.r .cell-code}\nmark(f5(n), f_louis1(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f5(n)        119.1ms    122ms      8.23    1.15MB     34.6\n2 f_louis1(n)   86.5ms   89.3ms     10.3     1.23MB     37.7\n```\n:::\n:::\n\n\nThen, we can prevent the repetitions of the modulo operations and equality tests by saving them to variables:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-17_26e594fcce990f5de86bb37269f1bba7'}\n\n```{.r .cell-code}\nf_louis2 <- function(n) {\n  z <- 1:n\n  for(i in z) {\n    div3 <- (i %% 3 == 0)\n    div5 <- (i %% 5 == 0)\n    if(div3 && div5) {\n      z[i] <- \"FizzBuzz\"\n    } else if(div3) {\n      z[i] <- \"Fizz\"\n    } else if(div5) {\n      z[i] <- \"Buzz\"\n    } \n  }\n  z\n}\n```\n:::\n\n\nThis gets us an even greater speedup of 1.7:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-18_323fef55d6a4f9960104778d1732c7f1'}\n\n```{.r .cell-code}\nmark(f5(n), f_louis2(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f5(n)        110.1ms    120ms      8.30    1.15MB     36.5\n2 f_louis2(n)   62.7ms   64.3ms     15.6     1.22MB     39.0\n```\n:::\n:::\n\n\nBut it gets even better: we can actually get rid of the for loop!\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-19_bb37617707429e504933c04049da431c'}\n\n```{.r .cell-code}\nf_louis3 <- function(n) {\n  z <- 1:n\n  div3 <- (z %% 3 == 0)\n  div5 <- (z %% 5 == 0)\n  z[which(div3)] <- \"Fizz\"\n  z[which(div5)] <- \"Buzz\"\n  z[which(div3 & div5)] <- \"FizzBuzz\"\n  z\n}\n```\n:::\n\n\nNow we get a speedup of 5.5 compared to our best `f2` function:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-20_814e8233dd74a73deccc55d8b6799f48'}\n\n```{.r .cell-code}\nmark(f5(n), f_louis3(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f5(n)          108ms  108.3ms      9.10    1.15MB    40.0 \n2 f_louis3(n)     18ms   18.7ms     51.5      5.2MB     5.94\n```\n:::\n:::\n\n\nYou can ensure that we still get the same result:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-21_e9a8c0b8e99368786059653f90fc7ec0'}\n\n```{.r .cell-code}\nf_louis3(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"        \"2\"        \"Fizz\"     \"4\"        \"Buzz\"     \"Fizz\"    \n [7] \"7\"        \"8\"        \"Fizz\"     \"Buzz\"     \"11\"       \"Fizz\"    \n[13] \"13\"       \"14\"       \"FizzBuzz\" \"16\"       \"17\"       \"Fizz\"    \n[19] \"19\"       \"Buzz\"    \n```\n:::\n:::\n\n\n## Replace costly operations where possible\n\nNow imagine that we have a dataframe called `dat` with a first column called `datvar` filled with integers.\n\nWe want to write a function that will accept our dataframe as argument and play the fizz buzz game on the column `datvar`.\n\nOne could imagine the following function:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-22_266524c649ee011585bff5686f4b5e90'}\n\n```{.r .cell-code}\nf6 <- function(dat) {\n  z <- integer(length(dat[[1]]))\n  for(i in seq_along(dat[[1]])) {\n    if(dat[[1]][i] %% 3 == 0 && dat[[1]][i] %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(dat[[1]][i] %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(dat[[1]][i] %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- dat[[1]][i]\n    }\n  }\n  z\n}\n```\n:::\n\n\nIndexing a column from a dataframe in this fashion is a very costly operation. It is much more efficient to index with the name of the column:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-23_7ee6cb81cbd7e88266e8646b446aea25'}\n\n```{.r .cell-code}\nf7 <- function(dat) {\n  z <- integer(length(dat$datvar))\n  for(i in seq_along(dat$datvar)) {\n    if(dat$datvar[i] %% 3 == 0 && dat$datvar[i] %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(dat$datvar[i] %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(dat$datvar[i] %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- dat$datvar[i]\n    }\n  }\n  z\n}\n```\n:::\n\nNow, let's create a random dataframe to benchmark `f6()` and `f7()`:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-24_e9e09ea08a6fa6d64f7016e0a2eb7c3a'}\n\n```{.r .cell-code}\nset.seed(123)\ndat <- data.frame(datvar = round(runif(n, 1, n)))\nmark(f6(dat), f7(dat))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f6(dat)       1.58s    1.58s     0.631    1.26MB     34.1\n2 f7(dat)    326.31ms 326.54ms     3.06     1.26MB     30.6\n```\n:::\n:::\n\n\n## Avoid repetitions of costly operations\n\nThis made a big difference (speedup of 5), but notice that we are indexing the column 6 times in our function. Let's remove the repetition of this operation:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-25_eb3a329b17f09205ee5612ead1597d9f'}\n\n```{.r .cell-code}\nf8 <- function(dat) {\n  var <- dat$datvar\n  z <- integer(length(var))\n  for(i in seq_along(var)) {\n    if(var[i] %% 3 == 0 && var[i] %% 5 == 0) {\n      z[i] <- \"FizzBuzz\"\n    } else if(var[i] %% 3 == 0) {\n      z[i] <- \"Fizz\"\n    } else if(var[i] %% 5 == 0) {\n      z[i] <- \"Buzz\"\n    } else {\n      z[i] <- var[i]\n    }\n  }\n  z\n}\n```\n:::\n\n\nLet's benchmark all 3 versions:\n\n\n::: {.cell hash='optimizations_cache/html/unnamed-chunk-26_96c6b58544b85497b661d2c24e89fc18'}\n\n```{.r .cell-code}\nmark(f6(dat), f7(dat), f8(dat))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 f6(dat)       1.56s    1.56s     0.641    1.15MB     34.6\n2 f7(dat)    313.32ms 316.31ms     3.16     1.15MB     31.6\n3 f8(dat)    123.59ms  127.1ms     7.14     1.25MB     21.4\n```\n:::\n:::\n\n\n`f8()` gave us another speedup of almost 3 over `f7()`. `f8()` runs 14 times faster than our initial function!\n\n:::{.note}\n\nIndexing from a vector isn't costly. There is thus no advantage at removing the repetition of that operation.\n\n:::\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nShow that this last statement is true.\n\n:::\n\n<!-- ```{r} -->\n<!-- f9 <- function(dat) { -->\n<!--   var <- dat$datvar -->\n<!--   z <- integer(length(var)) -->\n<!--   for(i in seq_along(var)) { -->\n<!--     num <- var[i] -->\n<!--     if(num %% 3 == 0 && num %% 5 == 0) { -->\n<!--       z[i] <- \"FizzBuzz\" -->\n<!--     } else if(num %% 3 == 0) { -->\n<!--       z[i] <- \"Fizz\" -->\n<!--     } else if(num %% 5 == 0) { -->\n<!--       z[i] <- \"Buzz\" -->\n<!--     } else { -->\n<!--       z[i] <- i -->\n<!--     } -->\n<!--   } -->\n<!--   z -->\n<!-- } -->\n\n<!-- mark(f8(dat), f9(dat)) -->\n<!-- ``` -->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}