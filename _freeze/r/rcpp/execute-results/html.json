{
  "hash": "e41a5714bfa6d42c80623d418789a368",
  "result": {
    "markdown": "---\ntitle: Writing C++ in R with Rcpp\nauthor: Marie-Hélène Burle\n---\n\n\n:::{.def}\n\nSometimes, parallelization is not an option, either because the code is hard to parallelize or because of lack of hardware. In such cases, one way to increase speed is to replace slow R code with C++. The package [Rcpp](https://cran.r-project.org/web/packages/Rcpp/index.html) makes this particularly easy by creating mappings between both languages.\n\n:::\n\n## Back to Fibonacci\n\nDo you remember [the Fibonacci numbers](memory.html#caching-in-memory)? Here was a naive implementation in R:\n\n\n::: {.cell hash='rcpp_cache/html/unnamed-chunk-1_2b754509bfb0ac5e9f1284005eea1e8c'}\n\n```{.r .cell-code}\nfib <- function(n) {\n  if(n == 0) return(0)\n  if(n == 1) return(1)\n  Recall(n - 1) + Recall(n - 2)\n}\n```\n:::\n\n\nThis function gives the n^th^ number in the sequence.\n\n:::{.example}\n\nExample:\n\n:::\n\n\n::: {.cell hash='rcpp_cache/html/unnamed-chunk-2_be1f47b8a4d51ec96ee1c20eaaab3621'}\n\n```{.r .cell-code}\nfib(30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 832040\n```\n:::\n:::\n\n\n## Rcpp\n\nLet's translate this function in C++ *within R!*\n\nFirst we need to load the [Rcpp package](https://cran.r-project.org/web/packages/Rcpp/index.html):\n\n\n::: {.cell hash='rcpp_cache/html/unnamed-chunk-3_0ffabe3f707663f548fc176671f64441'}\n\n```{.r .cell-code}\nlibrary(Rcpp)\n```\n:::\n\n\nWe then use the function `cppFunction()` to assign to an R function a function written in C++:\n\n\n::: {.cell hash='rcpp_cache/html/unnamed-chunk-4_6aa2020a01e70614ab83191d32800fcb'}\n\n```{.r .cell-code}\nfibRcpp <- cppFunction( '\nint fibonacci(const int x) {\n   if (x == 0) return(0);\n   if (x == 1) return(1);\n   return (fibonacci(x - 1)) + fibonacci(x - 2);\n}\n' )\n```\n:::\n\n\nWe can call our function as any R function:\n\n```{.r}\nfibRcpp(30)\n```\n\n```\n[1] 832040\n```\n\nWe can compare both functions:\n\n```{.r}\nlibrary(bench)\n\nn <- 30\nmark(fib(n), fibRcpp(n))\n```\n\n```\n# A tibble: 2 × 13\n  expression      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>\n1 fib(n)        1.66s    1.66s     0.601    44.7KB     22.8     1    38\n2 fibRcpp(n)   1.08ms   1.08ms   901.       2.49KB      0     451     0\n  total_time result    memory                 time            \n    <bch:tm> <list>    <list>                 <list>          \n1      1.66s <dbl [1]> <Rprofmem [6,778 × 3]> <bench_tm [1]>  \n2   500.37ms <int [1]> <Rprofmem [1 × 3]>     <bench_tm [451]>\n  gc                \n  <list>            \n1 <tibble [1 × 3]>  \n2 <tibble [451 × 3]>\nWarning message:\nSome expressions had a GC in every iteration; so filtering is disabled.\n```\n\nThe speedup is 1,537, which is amazing.\n\nIn this particular example, [we saw that memoisation gives an even more incredible speedup (35,000!)](memory.html#caching-in-memory), but while memoisation will only work in very specific situations (e.g. recursive function calls), using C++ code is a general method to provide speedup. It is particularly useful when:\n\n- there are large numbers of function calls (R is particularly slow with function calls),\n- you need data structures that are missing in R,\n- you want to create efficient packages (fast R packages are written in C++ and many use Rcpp).\n\n:::{.note}\n\nIn this example, we declared the C++ function directly in R. It is possible to use source files instead.\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}