{
  "hash": "f0cdf236413f48315c8bc9359c2cc5ea",
  "result": {
    "markdown": "---\ntitle: Indexing\nauthor: Marie-Hélène Burle\n---\n\n\n:::{.def}\n\nThis section covers indexing from the various data structures.\n\n:::\n\n## Indexing atomic vectors\n\n:::{.example}\n\nHere is an example with an atomic vector of size one:\n\n:::\n\nIndexing in R starts at `1` and is done with square brackets next to the element to index:\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-1_10a2d1a6fcc674a164feb5abd3910c86'}\n\n```{.r .cell-code}\nx <- 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nWhat happens if we index out of range?\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-2_9d0e7162b7c61696f68a06408d1a1805'}\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n:::{.example}\n\nExample for an atomic vector with multiple elements:\n\n:::\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-3_635dac00a6db048e837c232bef669d9d'}\n\n```{.r .cell-code}\nx <- c(2, 4, 1)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 1\n```\n:::\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  1 NA\n```\n:::\n:::\n\n\n### Modifying mutable objects\n\nIndexing also allows to modify some of the values of mutable objects:\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-4_c9be29c9565bf52f7be27c1c1fffead2'}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 1\n```\n:::\n\n```{.r .cell-code}\nx[2] <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 0 1\n```\n:::\n:::\n\n\n### Copy-on-modify\n\nNot all languages behave the same when you assign the same mutable object to several variables, then modify one of them.\n\n#### In Python: no copy-on-modify\n\n:::{.note}\n\nDon't try to run this code in R. This is for information only.\n\n:::\n\n```{.python filename=\"Python\"}\na = [1, 2, 3]\nb = a\nb\n```\n\n```\n[1, 2, 3]\n```\n\n```{.python filename=\"Python\"}\na[0] = 4           # In Python, indexing starts at 0\na\n```\n\n```\n[4, 2, 3]\n```\n\n```{.python filename=\"Python\"}\nb\n```\n\n```\n[4, 2, 3]\n```\n\nModifying `a` also modifies `b`: this is because no copy is made when you modify `a`. If you want to keep `b` unchanged, you need to assign an explicit copy of `a` to it with `b = copy.copy(a)`.\n\n#### In R: copy-on-modify\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-5_6b4f559326f89b26a35677d6306cc35d'}\n\n```{.r .cell-code}\na <- c(1, 2, 3)\nb <- a\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\na[1] <- 4          # In R, indexing starts at 1\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 2 3\n```\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nHere, the default is to create a new copy in memory when `a` is transformed so that `b` remains unchanged.\n\n## Indexing matrices and arrays\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-6_013e16e04e6f1460b3192f3b58458ac5'}\n\n```{.r .cell-code}\nx <- matrix(1:12, nrow = 3, ncol = 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n\n```{.r .cell-code}\nx[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\nx <- array(as.double(1:24), c(3, 2, 4))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   13   16\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   19   22\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\nx[2, 1, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n:::\n\n\n## Indexing lists\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-7_8bc3778bf1d15887e4da1287aef65aaa'}\n\n```{.r .cell-code}\nx <- list(2L, 3:8, c(2, 1), FALSE, \"string\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3 4 5 6 7 8\n\n[[3]]\n[1] 2 1\n\n[[4]]\n[1] FALSE\n\n[[5]]\n[1] \"string\"\n```\n:::\n:::\n\n\nIndexing a list returns a list:\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-8_f87676b36206e9861b37b1a2845ef85e'}\n\n```{.r .cell-code}\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nTo extract elements of a list, double square brackets are required:\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-9_959f9e8263d11f32770de7b5083fd8e9'}\n\n```{.r .cell-code}\nx[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nTry to extract the number `7` from this list.\n\n:::\n\n<!-- ```{r} -->\n<!-- x[[2]][5] -->\n<!-- ``` -->\n\n## Indexing data frames\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-10_da0195e361f881c32738126e4c459640'}\n\n```{.r .cell-code}\nx <- data.frame(\n  country = c(\"Canada\", \"USA\", \"Mexico\"),\n  var = c(2.9, 3.1, 4.5)\n)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country var\n1  Canada 2.9\n2     USA 3.1\n3  Mexico 4.5\n```\n:::\n:::\n\n\nA data frame is a list of atomic vectors representing the various columns:\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-11_9c9d28e2d78699a048a8fe1e7af79416'}\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country\n1  Canada\n2     USA\n3  Mexico\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Canada\" \"USA\"    \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nIndexing dataframes can also be done using the column names:\n\n\n::: {.cell hash='indexing_cache/html/unnamed-chunk-12_75fdb46c6af1348a85f2acf6771d864a'}\n\n```{.r .cell-code}\nx$country\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Canada\" \"USA\"    \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\nidentical(x[[1]], x$country)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}