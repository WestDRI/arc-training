{
  "hash": "caab40a709bc688ac4d016bd7d98daae",
  "result": {
    "markdown": "---\ntitle: Memory management\nauthor: Marie-Hélène Burle\n---\n\n\n:::{.def}\n\nMemory can be a limiting factor and releasing it when not needed can be critical to avoid [out of memory](https://en.wikipedia.org/wiki/Out_of_memory) states. On the other hand, [memoisation](https://en.wikipedia.org/wiki/Memoization) is an optimization technique which stores the results of heavy computations for re-use at the cost of increasing memory usage.\n\nMemory and speed are thus linked in a trade-off.\n\n:::\n\n## Releasing memory\n\nIt is best to avoid creating very large intermediate objects (e.g. with nested functions or functions chained with the [magrittr](https://cran.r-project.org/web/packages/magrittr/index.html#:~:text=magrittr%3A%20A%20Forward-Pipe%20Operator,of%20right-hand%20side%20expressions.) pipe), but if you must, remove them from the global environment with `rm()` when you don't need them anymore. Once all the pointers to an object in memory are deleted, the garbage collector will clear its value and release the memory it used.\n\nAnother way to release the memory used by heavy intermediate objects is with functions: if you create those objects in the local environment of a function (instead of directly in the global environment), they will be cleared from memory as soon as the function has finished running.\n\nNote that in the case of a very large function, it might still be beneficial to run `rm()` inside the function to clear the memory for other processes coming next within that function. But this is a pretty rare case.\n\n## Caching in memory\n\n[Memoisation](https://en.wikipedia.org/wiki/Memoization) is a technique by which the results of heavy computations are stored in memory to avoid have to re-calculate them. This can be convenient in a variety of settings (e.g. to reduce calls to an API), but mostly, it can greatly improve the efficiency of some code such as recursive function calls.\n\nLet's consider the calculation of the [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number) as an example. Those numbers form a sequence starting with `0` and `1`[^1], after which each number is the sum of the previous two.\n\n[^1]: Alternative versions have the sequence start with `1, 1` or with `1, 2`.\n\nHere is a function that would return the n^th^ Fibonacci number[^2]:\n\n[^2]: There are more efficient ways to calculate the Fibonacci numbers, but this inefficient function is a great example to show the advantage of memoisation.\n\n```{.r}\nfib <- function(n) {\n  if(n == 0) {\n    return(0)\n  } else if(n == 1) {\n    return(1)\n  } else {\n    Recall(n - 1) + Recall(n - 2)\n  }\n}\n```\n\nIt can be written more tersely as:\n\n\n::: {.cell hash='memory_cache/html/unnamed-chunk-1_168e77b79d6e86369ea78c634d9eaff5'}\n\n```{.r .cell-code}\nfib <- function(n) {\n  if(n == 0) return(0)\n  if(n == 1) return(1)\n  Recall(n - 1) + Recall(n - 2)\n}\n```\n:::\n\n\n:::{.note}\n\n`Recall()` is a placeholder for the name of the recursive function. We could have used `fib()` instead, but `Recall()` is more robust as it allows for function renaming.\n\n:::\n\nMemoisation is very useful here because, for each Fibonacci number, we need to calculate the two preceding Fibonacci numbers and to calculate each of those we need to calculate the two Fibonacci numbers preceding that one and to calculate... etc. That is a large number of calculations, but, thanks to caching, we don't have to calculate any one of them more than once.\n\nThe packages [R.cache](https://cran.r-project.org/web/packages/R.cache/index.html) and [memoise](https://cran.r-project.org/web/packages/memoise/index.html) both allow for memoisation with an incredibly simple syntax.\n\nApplying the latter to our function gives us:\n\n\n::: {.cell hash='memory_cache/html/unnamed-chunk-2_19ded8733dfc04ee29b9b7d44497d980'}\n\n```{.r .cell-code}\nlibrary(memoise)\n\nfibmem <- memoise(function(n) {\n  if(n == 0) return(0)\n  if(n == 1) return(1)\n  fibmem(n - 1) + fib(n - 2)\n})\n```\n:::\n\n\nWe can do some benchmarking to see the speedup for the 30^th^ Fibonacci number:\n\n\n::: {.cell hash='memory_cache/html/unnamed-chunk-3_026ce4e421ca6a24630586d946d65106'}\n\n```{.r .cell-code}\nlibrary(bench)\n\nn <- 30\nmark(fib(n), fibmem(n))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 fib(n)        1.52s    1.52s     0.656   41.93KB     24.9\n2 fibmem(n)   42.55µs  45.59µs 20899.       1.07MB     16.7\n```\n:::\n:::\n\n\nThe speedup is over 35,000!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}