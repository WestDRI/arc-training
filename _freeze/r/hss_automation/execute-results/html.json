{
  "hash": "52c5019b694b5d0bb83d47cbeaa4c698",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Automation\nauthor: Marie-Hélène Burle\nresources:\n  - \"hss_data/arc1.csv\"\n  - \"hss_data/arc2.csv\"\n  - \"hss_data/arc3.csv\"\n  - \"hss_data/arc4.csv\"\n  - \"hss_data/arc5.csv\"\n---\n\n\n:::{.def}\n\nOne of the strengths of programming is the ability to automate tasks.\n\nIn this section, we will see how a loop can automate the creation of file names.\n\n:::\n\nLet's say that we now want to import data from 5 files arc1.csv, ..., arc5.csv and create 5 data frames with their data.\n\n<!-- We will need the `readr` package for this of course: -->\n\n<!-- ```{r} -->\n<!-- library(readr) -->\n<!-- ``` -->\n\nWe need a character vector with the file names.\n\nWe could create it this way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- c(\n  \"https://mint.westdri.ca/r/hss_data/arc1.csv\",\n  \"https://mint.westdri.ca/r/hss_data/arc2.csv\",\n  \"https://mint.westdri.ca/r/hss_data/arc3.csv\",\n  \"https://mint.westdri.ca/r/hss_data/arc4.csv\",\n  \"https://mint.westdri.ca/r/hss_data/arc5.csv\"\n)\n```\n:::\n\n\nIt works of course:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://mint.westdri.ca/r/hss_data/arc1.csv\"\n[2] \"https://mint.westdri.ca/r/hss_data/arc2.csv\"\n[3] \"https://mint.westdri.ca/r/hss_data/arc3.csv\"\n[4] \"https://mint.westdri.ca/r/hss_data/arc4.csv\"\n[5] \"https://mint.westdri.ca/r/hss_data/arc5.csv\"\n```\n\n\n:::\n:::\n\n\nBut if we had 50 files instead of 5, it would be quite a tedium! And if we had 500 files, it would be unrealistic. A better approach is to write a loop.\n\nIn order to store the results of a loop, we need to create an empty object and assign to it the result of the loop at each iteration. It is very important to pre-allocate memory: by creating an empty object of the final size, the necessary memory to hold this object is requested once (then the object gets filled in while the loop runs). Without this, more memory would have to be allocated at each iteration of the loop and this is highly inefficient.\n\nSo let's create an empty vector of length 5 and of type character:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- character(5)\n```\n:::\n\n\nNow we can fill in our vector with the proper values with the loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  files[i] <- paste0(\n    \"https://mint.westdri.ca/r/hss_data/arc\",\n    i,\n    \".csv\"\n  )\n}\n```\n:::\n\n\nThis gives us the same result, but the big difference is that it is scalable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://mint.westdri.ca/r/hss_data/arc1.csv\"\n[2] \"https://mint.westdri.ca/r/hss_data/arc2.csv\"\n[3] \"https://mint.westdri.ca/r/hss_data/arc3.csv\"\n[4] \"https://mint.westdri.ca/r/hss_data/arc4.csv\"\n[5] \"https://mint.westdri.ca/r/hss_data/arc5.csv\"\n```\n\n\n:::\n:::\n\n\n:::{.note}\n\nIf you had all the files in one directory, an alternative approach would be to create a list of all the names matching a regular expression.\n\nIn our case, we would use:\n\n```{.r}\nfiles <- list.files(pattern=\"^arc\\\\d+\\\\.csv$\")\n```\n\n:::\n\n<!-- https://stackoverflow.com/questions/11433432/how-to-import-multiple-csv-files-at-once -->\n\n<!-- ## Automate file reading -->\n\n<!-- Now we can use this vector to read in all our files: -->\n\n<!-- ```{r} -->\n<!-- for (i in files) { -->\n<!--   arc[i] <- read_csv( -->\n<!--     i, -->\n<!--     na = c(\"N/A\", \"n/a\"), -->\n<!--     col_types = cols(Date = col_date(\"%d/%m/%Y\")) -->\n<!--   ) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- library(readr) -->\n<!-- library(lubridate) -->\n<!-- ``` -->\n\n<!-- ```{.r} -->\n<!-- arc1 <- read_csv( -->\n<!--   \"https://mint.westdri.ca/r/hss_data/arc1.csv\", -->\n<!--   na = c(\"N/A\", \"n/a\"), -->\n<!--   col_types = cols(Date = col_date(\"%d/%m/%Y\")) -->\n<!-- ) -->\n\n<!-- arc1 <- arc1 |> -->\n<!--   rename( -->\n<!--     Artifacts = `Number of artifacts`, -->\n<!--     PI = `Name of PI` -->\n<!-- ) -->\n\n<!-- write_csv(arc1, \"arc1_clean.csv\") -->\n<!-- ``` -->\n\n<!-- First, we need a character vector with the file names. -->\n\n<!-- We could create it this way: -->\n\n<!-- ```{r} -->\n<!-- files <- c( -->\n<!--   \"https://mint.westdri.ca/r/hss_data/arc1.csv\", -->\n<!--   \"https://mint.westdri.ca/r/hss_data/arc2.csv\", -->\n<!--   \"https://mint.westdri.ca/r/hss_data/arc3.csv\", -->\n<!--   \"https://mint.westdri.ca/r/hss_data/arc4.csv\", -->\n<!--   \"https://mint.westdri.ca/r/hss_data/arc5.csv\" -->\n<!-- ) -->\n\n<!-- files -->\n<!-- ``` -->\n\n<!-- But if we had 200 files instead of 5, it would be quite a tedium! A better approach is to write a loop: -->\n\n<!-- ```{r} -->\n<!-- files <- character(5) -->\n\n<!-- for (i in 1:5) { -->\n<!--   files[i] <- paste0(\"https://mint.westdri.ca/r/hss_data/arc\", i, \".csv\") -->\n<!-- } -->\n\n<!-- files -->\n<!-- ``` -->\n\n<!-- This gives us the same result, but it is scalable. -->\n\n<!-- Then we need to create the names of the files we will save our data frames to: -->\n\n<!-- ```{r} -->\n<!-- files_clean <- character(5) -->\n\n<!-- for (i in 1:5) { -->\n<!--   files_clean[i] <- paste0(\"arc\", i, \"_clean.csv\") -->\n<!-- } -->\n\n<!-- files_clean -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- tib <- tibble( -->\n<!--   a = character(), -->\n<!--   b = ymd(), -->\n<!--   c = double(), -->\n<!--   d = character(), -->\n<!--   e = character() -->\n<!--   ) -->\n\n<!-- arc <- rep(list(tib), 5) -->\n\n<!-- files_clean <- character(5) -->\n\n<!-- for (i in files) { -->\n<!--   arc[i] <- read_csv( -->\n<!--     i, -->\n<!--     na = c(\"N/A\", \"n/a\"), -->\n<!--     col_types = cols(Date = col_date(\"%d/%m/%Y\")) -->\n<!--   ) -->\n\n<!--   arc[i] <- arc[i] |> -->\n<!--     rename( -->\n<!--       Artifacts = `Number of artifacts`, -->\n<!--       PI = `Name of PI` -->\n<!--     ) -->\n\n<!-- files_clean[i] <- paste0(\"arc\", i, \"_clean.csv\") -->\n\n<!-- write_csv(arc[i], files_clean[i]) -->\n<!-- } -->\n<!-- ``` -->\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}