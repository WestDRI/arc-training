{
  "hash": "99ca959575ac05c6682d3d8277c9d29c",
  "result": {
    "markdown": "---\ntitle: \"R: the basics\"\nauthor: Marie-Hélène Burle\n---\n\n\n## Help and documentation\n\nFor some general documentation on R, you can run:\n\n```{.r}\nhelp.start()\n```\n\nTo get help on a function (e.g. `sum`), you can run:\n\n```{.r}\nhelp(sum)\n```\n\nDepending on your settings, this will open a documentation for `sum` in a pager or in your browser.\n\n## R settings\n\nSettings are saved in a `.Rprofile` file. You can edit the file directly in any text editor or from within R.\n\nList all options:\n\n```{.r}\noptions()\n```\n\nReturn the value of a particular option:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-1_2866b2dd0f6d8c68c68c452b2be6d09a'}\n\n```{.r .cell-code}\ngetOption(\"help_type\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"html\"\n```\n:::\n:::\n\n\nSet an option:\n\n```{.r}\noptions(help_type = \"html\")\n```\n\n## Assignment\n\nR can accept the equal sign (`=`) for assignments, but it is more idiomatic to use the assignment sign (`<-`) whenever you bind a name to a value and to use the equal sign everywhere else.\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-2_b0f5386f936166396df776c1813527a9'}\n\n```{.r .cell-code}\na <- 3\n```\n:::\n\n\nOnce you have bound a name to a value, you can recall the value with that name:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-3_784c12277db0260bd67605c9215d49d8'}\n\n```{.r .cell-code}\na  # Note that you do not need to use a print() function in R\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nYou can remove an object from the environment by deleting its name:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-4_6e88cec4fbfd6ab417f67833f6baa83e'}\n\n```{.r .cell-code}\nrm(a)\na\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'a' not found\n```\n:::\n:::\n\n\nThe garbage collector will take care of deleting the object itself from memory.\n\n## Comments\n\nAnything to the left of `#` is a comment and is ignored by R:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-5_5ea92a8859c4ee8df1d0b6b4c9480cd4'}\n\n```{.r .cell-code}\n# This is an inline comment\n\na <- 3  # This is also a comment\n```\n:::\n\n\n## Data types and structures\n\n| Dimension | Homogeneous   | Heterogeneous  |\n|-----------|---------------|----------------|\n| 1 d       | Atomic vector | List           |\n| 2 d       | Matrix        | Data frame     |\n| 3 d       | Array         |                |\n\n### Atomic vectors\n\n#### With a single element\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-6_d3e21c323d13f8c7eac3f65d5c729e93'}\n\n```{.r .cell-code}\na <- 2\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nstr(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num 2\n```\n:::\n\n```{.r .cell-code}\nlength(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ndim(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nThe `dim` attribute of a vector doesn't exist (hence the `NULL`). This makes vectors different from one-dimensional arrays which have a `dim` of `1`.\n\nYou might have noticed that `2` is a double (double precision floating point number, equivalent of \"float\" in other languages). In R, this is the default, even if you don't type `2.0`. This prevents the kind of weirdness you can find in, for instance, Python.\n\nIn Python:\n\n```{.python}\n>>> 2 == 2.0\nTrue\n>>> type(2) == type(2.0)\nFalse\n>>> type(2)\n<class 'int'>\n>>> type(2.0)\n<class 'float'>\n```\n\nIn R:\n\n```{.r}\n> 2 == 2.0\n[1] TRUE\n> typeof(2) == typeof(2.0)\n[1] TRUE\n> typeof(2)\n[1] \"double\"\n> typeof(2.0)\n[1] \"double\"\n```\n\nIf you want to define an integer variable, you use:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-7_6ad868dc7c7284bb243acd8b2b512c42'}\n\n```{.r .cell-code}\nb <- 2L\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nmode(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nstr(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int 2\n```\n:::\n:::\n\n\nThere are six vector types:\n\n- logical\n- integer\n- double\n- character\n- complex\n- raw\n\n#### With multiple elements\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-8_0405fcdf4007f86d3d56c6c6e8478354'}\n\n```{.r .cell-code}\nc <- c(2, 4, 1)\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nmode(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nstr(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 2 4 1\n```\n:::\n:::\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-9_11a3be8aaa9d2ed01ea95a8f14239a57'}\n\n```{.r .cell-code}\nd <- c(TRUE, TRUE, NA, FALSE)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE    NA FALSE\n```\n:::\n\n```{.r .cell-code}\ntypeof(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nstr(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n logi [1:4] TRUE TRUE NA FALSE\n```\n:::\n:::\n\n\n:::{.note}\n\n`NA` (\"Not Available\") is a logical constant of length one. It is an indicator for a missing value.\n\n:::\n\nVectors are homogeneous, so all elements need to be of the same type.\n\nIf you use elements of different types, R will convert some of them to ensure that they become of the same type:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-10_a03b1f76887e7cf4308a76c92404fffb'}\n\n```{.r .cell-code}\ne <- c(\"This is a string\", 3, \"test\")\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This is a string\" \"3\"                \"test\"            \n```\n:::\n\n```{.r .cell-code}\ntypeof(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nstr(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:3] \"This is a string\" \"3\" \"test\"\n```\n:::\n:::\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-11_73db784f0b287d70f2f70a55f098cb43'}\n\n```{.r .cell-code}\nf <- c(TRUE, 3, FALSE)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 0\n```\n:::\n\n```{.r .cell-code}\ntypeof(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nstr(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 1 3 0\n```\n:::\n:::\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-12_6e0d6ee7fb739f2ab6e7f4eebbf1dc21'}\n\n```{.r .cell-code}\ng <- c(2L, 3, 4L)\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4\n```\n:::\n\n```{.r .cell-code}\ntypeof(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nstr(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 2 3 4\n```\n:::\n:::\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-13_5c4a34c5d8f791f93c3c97cfb87e1374'}\n\n```{.r .cell-code}\nh <- c(\"string\", TRUE, 2L, 3.1)\nh\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"string\" \"TRUE\"   \"2\"      \"3.1\"   \n```\n:::\n\n```{.r .cell-code}\ntypeof(h)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nstr(h)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:4] \"string\" \"TRUE\" \"2\" \"3.1\"\n```\n:::\n:::\n\n\nThe binary operator `:` is equivalent to the `seq()` function and generates a regular sequence of integers:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-14_8c0ae1f6ee2933067cdce840b01c1fc5'}\n\n```{.r .cell-code}\ni <- 1:5\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\ntypeof(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nstr(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:5] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nidentical(2:8, seq(2, 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Matrices\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-15_4eb057b87182c37d11f508c98e74ca67'}\n\n```{.r .cell-code}\nj <- matrix(1:12, nrow = 3, ncol = 4)\nj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n\n```{.r .cell-code}\ntypeof(j)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nstr(j)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ...\n```\n:::\n\n```{.r .cell-code}\nlength(j)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n\n```{.r .cell-code}\ndim(j)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4\n```\n:::\n:::\n\n\nThe default is `byrow = FALSE`. If you want the matrix to be filled in by row, you need to set this argument to `TRUE`:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-16_2a40769ddae4d0c7fcce3637e104503c'}\n\n```{.r .cell-code}\nk <- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)\nk\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n```\n:::\n:::\n\n\n### Arrays\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-17_26b35ff027386919d0b1ff9b4bdd6085'}\n\n```{.r .cell-code}\nl <- array(as.double(1:24), c(3, 2, 4))\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   13   16\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   19   22\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\ntypeof(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nstr(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3, 1:2, 1:4] 1 2 3 4 5 6 7 8 9 10 ...\n```\n:::\n\n```{.r .cell-code}\nlength(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n\n```{.r .cell-code}\ndim(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2 4\n```\n:::\n:::\n\n\n### Lists\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-18_c1bd995856a2f28aba75ac39f1958b0c'}\n\n```{.r .cell-code}\nm <- list(2, 3)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ntypeof(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nstr(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : num 2\n $ : num 3\n```\n:::\n\n```{.r .cell-code}\nlength(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nAs with atomic vectors, lists do not have a `dim` attribute. Lists are in fact a different type of vectors.\n\nLists can be heterogeneous:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-19_624f464d0d7388c301d3f321eb28a7b1'}\n\n```{.r .cell-code}\nn <- list(2L, 3, c(2, 1), FALSE, \"string\")\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 2 1\n\n[[4]]\n[1] FALSE\n\n[[5]]\n[1] \"string\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nstr(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 5\n $ : int 2\n $ : num 3\n $ : num [1:2] 2 1\n $ : logi FALSE\n $ : chr \"string\"\n```\n:::\n\n```{.r .cell-code}\nlength(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n### Data frames\n\nData frames contain tabular data. Under the hood, a data frame is a list of vectors.\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-20_f1d95d7f054a8b4256c6fc2766719267'}\n\n```{.r .cell-code}\no <- data.frame(\n  country = c(\"Canada\", \"USA\", \"Mexico\"),\n  var = c(2.9, 3.1, 4.5)\n)\no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country var\n1  Canada 2.9\n2     USA 3.1\n3  Mexico 4.5\n```\n:::\n\n```{.r .cell-code}\ntypeof(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nstr(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3 obs. of  2 variables:\n $ country: chr  \"Canada\" \"USA\" \"Mexico\"\n $ var    : num  2.9 3.1 4.5\n```\n:::\n\n```{.r .cell-code}\nlength(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ndim(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2\n```\n:::\n:::\n\n\n## Indexing\n\nIndexing in R starts at `1`.\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-21_47c8b198aefe70ae10aba7f18909c893'}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\na[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\na[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 1\n```\n:::\n\n```{.r .cell-code}\nc[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nc[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  1 NA\n```\n:::\n\n```{.r .cell-code}\nj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n\n```{.r .cell-code}\nj[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n\n, , 3\n\n     [,1] [,2]\n[1,]   13   16\n[2,]   14   17\n[3,]   15   18\n\n, , 4\n\n     [,1] [,2]\n[1,]   19   22\n[2,]   20   23\n[3,]   21   24\n```\n:::\n\n```{.r .cell-code}\nl[2, 1, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n\n```{.r .cell-code}\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 2 1\n\n[[4]]\n[1] FALSE\n\n[[5]]\n[1] \"string\"\n```\n:::\n\n```{.r .cell-code}\nn[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(n[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nn[3][1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\nn[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1\n```\n:::\n\n```{.r .cell-code}\ntypeof(n[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nn[[3]][1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country var\n1  Canada 2.9\n2     USA 3.1\n3  Mexico 4.5\n```\n:::\n\n```{.r .cell-code}\no[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country\n1  Canada\n2     USA\n3  Mexico\n```\n:::\n\n```{.r .cell-code}\ntypeof(o[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nstr(o[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3 obs. of  1 variable:\n $ country: chr  \"Canada\" \"USA\" \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\no[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Canada\" \"USA\"    \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(o[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\no$country\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Canada\" \"USA\"    \"Mexico\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(o$country)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n## Copy-on-modify\n\nWhile some languages (e.g. Python) do not make a copy if you modify a mutable object, R does.\n\nLet's have a look at Python:\n\n```{.python}\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b\n[1, 2, 3]\n>>> a[0] = 4\n>>> a\n[4, 2, 3]\n>>> b\n[4, 2, 3]\n```\n\nModifying `a` also modifies `b`. If you want to keep `b` unchanged, you need to explicitly make a copy of `a`.\n\nNow, let's see what happens in R:\n\n```{.r}\n> a <- c(1, 2, 3)\n> b <- a\n> b\n[1] 1 2 3\n> a[1] <- 4\n> a\n[1] 4 2 3\n> b\n[1] 1 2 3\n```\n\nHere, the default is to create a new copy in memory when `a` is transformed so that `b` remains unchanged. This is more intuitive, but more memory intensive.\n\n## Function definition\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-22_ff83c4a558a5adc830cb2995078d560a'}\n\n```{.r .cell-code}\ncompare <- function(x, y) {\n  x == y\n}\n```\n:::\n\n\nWe can now use our function:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-23_59b3d7edb0d33dea224a62d050b258e1'}\n\n```{.r .cell-code}\ncompare(2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nNote that the result of the last statement is printed automatically:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-24_84cf329fe10e29843b13633c86e96f88'}\n\n```{.r .cell-code}\ntest <- function(x, y) {\n  x\n  y\n}\ntest(2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nIf you want to return other results, you need to explicitly use the `print()` function:\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-25_144fcae1a940de73b458c2e8f2639286'}\n\n```{.r .cell-code}\ntest <- function(x, y) {\n  print(x)\n  y\n}\ntest(2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n## Control flow\n\n### Conditionals\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-26_9b84d162e6400b2a789ad460906d06ab'}\n\n```{.r .cell-code}\ntest_sign <- function(x) {\n  if (x > 0) {\n    \"x is positif\"\n  } else if (x < 0) {\n    \"x is negatif\"\n  } else {\n    \"x is equal to zero\"\n  }\n}\n```\n:::\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-27_ef531253db7eeabef9332d8f5ae05a60'}\n\n```{.r .cell-code}\ntest_sign(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is positif\"\n```\n:::\n\n```{.r .cell-code}\ntest_sign(-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is negatif\"\n```\n:::\n\n```{.r .cell-code}\ntest_sign(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to zero\"\n```\n:::\n:::\n\n\n### Loops\n\n\n::: {.cell hash='basics_cache/html/unnamed-chunk-28_04d7aaad939796f0b60f13c8de74cbec'}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n```\n:::\n:::\n\n\nNotice that here we need to use the `print()` function.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}