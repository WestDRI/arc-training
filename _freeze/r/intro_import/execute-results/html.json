{
  "hash": "64a58937c6e1e8073427a47388dbcb52",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data import and export\nauthor: Marie-Hélène Burle\nresources: \"hss_data/arc1.csv\"\n---\n\n\n\n:::{.def}\n\nSo far, we have used a well-formatted dataset. In the real world, things are often not this nice and tidy...\n\nIn this section, we will learn how to handle real data.\n\n:::\n\n## Reading in data\n\nThe [readr](https://readr.tidyverse.org/) package from the [tidyverse](https://www.tidyverse.org/) provides a number of functions to read in text files with tabular data (e.g. comma-separated values (CSV) or tab-separated values (TSV) files).\n\nLet's load it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n```\n:::\n\n\n\nThe `read_csv()` function allows to read in CSV files that are either stored locally or from a URL.\n\nLet's use it to load a CSV file with mock archaeological data which is at the URL https://mint.westdri.ca/r/hss_data/arc1.csv:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1 <- read_csv(\"https://mint.westdri.ca/r/hss_data/arc1.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 6 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): Site, Date, Number of artifacts, Name of PI, Comments\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n:::{.note}\n\nIf the file was in your machine, you would provide its path instead of the URL.\n\n:::\n\nHere is our data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Site  Date      `Number of artifacts` `Name of PI`\n  <chr> <chr>     <chr>                 <chr>       \n1 E1    13/2/2001 4                     John Doe    \n2 E1    14/2/2001 3                     John Doe    \n3 A2    26/3/2003 N/A                   Paul Smith  \n4 B18   4/5/2006  5                     Paul Smith  \n5 B7    4/5/2006  5                     n/a         \n6 B3    4/5/2006  5                     P. Smith    \n  Comments                          \n  <chr>                             \n1 <NA>                              \n2 <NA>                              \n3 Artifacts still need to be counted\n4 <NA>                              \n5 <NA>                              \n6 <NA>                              \n```\n\n\n:::\n:::\n\n\n\n## Improper NA\n\nIn R, missing values are represented by `NA` (not available). It is a constant that R understands and can deal with, so it is important that all missing values are represented properly.\n\nWhen you enter data (say in an Excel file or CSV file), leave an empty cell for missing values: R will then transform them automatically into `NA`.\n\nBecause this data was not entered properly, we have to fix our missing values. One way to go about this is to replace the characters representing missing values in the file (`\"N/A\"` and `\"n/a\"`) by `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(arc1) <- arc1 == \"N/A\"\nis.na(arc1) <- arc1 == \"n/a\"\narc1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Site  Date      `Number of artifacts` `Name of PI`\n  <chr> <chr>     <chr>                 <chr>       \n1 E1    13/2/2001 4                     John Doe    \n2 E1    14/2/2001 3                     John Doe    \n3 A2    26/3/2003 <NA>                  Paul Smith  \n4 B18   4/5/2006  5                     Paul Smith  \n5 B7    4/5/2006  5                     <NA>        \n6 B3    4/5/2006  5                     P. Smith    \n  Comments                          \n  <chr>                             \n1 <NA>                              \n2 <NA>                              \n3 Artifacts still need to be counted\n4 <NA>                              \n5 <NA>                              \n6 <NA>                              \n```\n\n\n:::\n:::\n\n\n\nNow, we have another problem to fix: `readr` is very good at guessing the types of the various variables. Unfortunately, the character `\"N/A\"` in the `Number of artifacts` column prevented it to guess the type properly: it should be a double (a numerical value) and not a character. We can fix this too:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1$`Number of artifacts` <- as.double(arc1$`Number of artifacts`)\narc1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Site  Date      `Number of artifacts` `Name of PI`\n  <chr> <chr>                     <dbl> <chr>       \n1 E1    13/2/2001                     4 John Doe    \n2 E1    14/2/2001                     3 John Doe    \n3 A2    26/3/2003                    NA Paul Smith  \n4 B18   4/5/2006                      5 Paul Smith  \n5 B7    4/5/2006                      5 <NA>        \n6 B3    4/5/2006                      5 P. Smith    \n  Comments                          \n  <chr>                             \n1 <NA>                              \n2 <NA>                              \n3 Artifacts still need to be counted\n4 <NA>                              \n5 <NA>                              \n6 <NA>                              \n```\n\n\n:::\n:::\n\n\n\nAlternatively, it is simpler to have `read_csv()` properly recognize the missing values. This can be done thanks to the `na` argument:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1 <- read_csv(\n  \"https://mint.westdri.ca/r/hss_data/arc1.csv\",\n  na = c(\"N/A\", \"n/a\")\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 6 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): Site, Date, Name of PI, Comments\ndbl (1): Number of artifacts\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\narc1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Site  Date      `Number of artifacts` `Name of PI`\n  <chr> <chr>                     <dbl> <chr>       \n1 E1    13/2/2001                     4 John Doe    \n2 E1    14/2/2001                     3 John Doe    \n3 A2    26/3/2003                    NA Paul Smith  \n4 B18   4/5/2006                      5 Paul Smith  \n5 B7    4/5/2006                      5 <NA>        \n6 B3    4/5/2006                      5 P. Smith    \n  Comments                            \n  <chr>                               \n1 \"\"                                  \n2 \"\"                                  \n3 \"Artifacts still need to be counted\"\n4 \"\"                                  \n5 \"\"                                  \n6 \"\"                                  \n```\n\n\n:::\n:::\n\n\n\nA benefit of this approach is that `read_csv()` now automatically detects the proper data type of `Number of artifacts` (since there is no more confusing character in what is otherwise a column of doubles).\n\n## Dealing with dates\n\nThere is another problem in our data frame: the `Date` variable should be of the `date` type, but `read_csv()` failed to recognize the values as dates and processed them as characters. This is because it is not entered in our data following the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format which is YYYY-MM-DD. When you enter data, make sure to follow this format as it will make things work automatically. In our case, we have to convert the date.\n\nThe tidyverse package dealing with date is [lubridate](https://lubridate.tidyverse.org/). Let's load it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n:::\n\n\n\n`lubridate` comes with many functions that can convert dates and times from many format to the ISO format. Since our date have the day, then the month, then the year, the function we need is `dmy()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1$Date <- dmy(arc1$Date)\n```\n:::\n\n\n\nAlternatively, `read_csv()` will understand dates in a non ISO format, provided you give it the right information. This can be done with the `col_types` argument and the `col_date()` function to which the parameters corresponding to your date format are passed.\n\nHere are the parameters to use:\n\n|       | Format           | Example  | Parameter |\n|-------|------------------|----------|-----------|\n| Year  | 4 digits         | 2024     | `%Y`      |\n|       | 2 digits         | 24       | `%y`      |\n| Month | Decimal          | 2        | `%m`      |\n|       | Abbreviated name | Feb      | `%b`      |\n|       | Full name        | February | `%B`      |\n| Day   | Decimal          | 8        | `%d`      |\n\nIn our case, the date looks like `\"%d/%m/%Y\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1 <- read_csv(\n  \"https://mint.westdri.ca/r/hss_data/arc1.csv\",\n  na = c(\"N/A\", \"n/a\"),\n  col_types = cols(Date = col_date(\"%d/%m/%Y\"))\n)\narc1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Site  Date       `Number of artifacts` `Name of PI`\n  <chr> <date>                     <dbl> <chr>       \n1 E1    2001-02-13                     4 John Doe    \n2 E1    2001-02-14                     3 John Doe    \n3 A2    2003-03-26                    NA Paul Smith  \n4 B18   2006-05-04                     5 Paul Smith  \n5 B7    2006-05-04                     5 <NA>        \n6 B3    2006-05-04                     5 P. Smith    \n  Comments                            \n  <chr>                               \n1 \"\"                                  \n2 \"\"                                  \n3 \"Artifacts still need to be counted\"\n4 \"\"                                  \n5 \"\"                                  \n6 \"\"                                  \n```\n\n\n:::\n:::\n\n\n\n## Renaming variables\n\nVariable names cannot contain spaces. Since our data did have spaces in some of the names and since those names were not quoted, R added backticks ``` to be able to make use of them. This makes for rather awkward variables. Let's rename them.\n\nWe could use the camel or snake case, but we can also just simplify the names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1 <- arc1 |>\n  rename(\n    Artifacts = `Number of artifacts`,\n    PI = `Name of PI`\n  )\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in rename(arc1, Artifacts = `Number of artifacts`, PI = `Name of PI`): could not find function \"rename\"\n```\n\n\n:::\n:::\n\n\n\n## Fixing inconsistencies\n\nThere is still another problem in our data: `Paul Smith` and `P. Smith` are—as far as R is concerned—2 different values. The number of PIs in our data should be two, but R currently interprets it as being three:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::n_distinct(arc1$PI, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `PI`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n:::{.note}\n\nWe remove the missing values so that they don't get counted as an additional PI (although, more PIs could have been involved in the data collection: dealing with missing values programmatically is easy once they are properly formatted, but what to do with them methodologically depends on the situation and is part of the research question).\n\n:::\n\nThis can be a problem for future analysis, so let's fix it. There are many ways to go about this, but the simplest is to use regular expressions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1$PI <- gsub(\"P\\\\.\", \"Paul\", arc1$PI)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Unknown or uninitialised column: `PI`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `$<-`:\n! Assigned data `gsub(\"P\\\\\\\\.\", \"Paul\", arc1$PI)` must be compatible\n  with existing data.\n✖ Existing data has 6 rows.\n✖ Assigned data has 0 rows.\nℹ Only vectors of size 1 are recycled.\nCaused by error in `vectbl_recycle_rhs_rows()`:\n! Can't recycle input of size 0 to size 6.\n```\n\n\n:::\n:::\n\n\n\nOur data is finally well formatted and can be used for plotting, analyses, etc.:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narc1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  Site  Date       `Number of artifacts` `Name of PI`\n  <chr> <date>                     <dbl> <chr>       \n1 E1    2001-02-13                     4 John Doe    \n2 E1    2001-02-14                     3 John Doe    \n3 A2    2003-03-26                    NA Paul Smith  \n4 B18   2006-05-04                     5 Paul Smith  \n5 B7    2006-05-04                     5 <NA>        \n6 B3    2006-05-04                     5 P. Smith    \n  Comments                            \n  <chr>                               \n1 \"\"                                  \n2 \"\"                                  \n3 \"Artifacts still need to be counted\"\n4 \"\"                                  \n5 \"\"                                  \n6 \"\"                                  \n```\n\n\n:::\n:::\n\n\n\n## Writing data to file\n\nNow that we have a properly formatted data frame, we could, if we needed to, export it to a new file. `readr` also has functions to write to text files.\n\nLet's save our data frame as a new CSV file (make sure to give it a different name from the original file):\n\n```{.r}\nwrite_csv(arc1, \"arc1_clean.csv\")\n```\n\n<!-- ```{r} -->\n<!-- library(readr) -->\n\n<!-- crew <- read_csv(\"http://www.whalingmuseum.org/online_exhibits/crewlist/crewlist.csv\") -->\n\n<!-- crew -->\n<!-- str(crew) -->\n<!-- ``` -->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}