{
  "hash": "d675fa9e11edfcaf76d3e167da620a01",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Control flow\naliases:\n  - control_flow.html\nauthor:\n  - Marie-Hélène Burle\n  - Alex Razoumov\n---\n\n::: {.cell}\n\n:::\n\n:::{.def}\n\nBy default, scripts get executed linearly from top to bottom. Often however, you want to control what gets executed when.\n\nThis section covers various ways to control the flow of execution through a script.\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n\n## Data for this section (same data as previous section)\n\nFor this section, we will play with files created by [The Carpentries](https://carpentries.org/).\n\nYou can download them into a zip file called `data.zip` with:\n\n```{.bash}\ncurl --output data.zip https://mint.westdri.ca/bash/data.zip\n```\n\nYou can then unzip that file with:\n\n```{.bash}\nunzip data.zip\n```\n\nYou should now have a `data` directory.\n\n`cd` into it:\n\n```{.bash}\ncd data\n```\n\n:::\n\n## Normal execution of commands\n\nCommands get executed from top to bottom and from left to right. Different commands are separated by a line break and/or a semi-colon.\n\n:::{.example}\n\nExample:\n\n:::\n\nLook at the following commands:\n\n```{.bash}\nunzip bash.zip\nrm bash.zip\n```\n\nThis is equivalent to:\n\n```{.bash}\nunzip bash.zip;\nrm bash.zip\n```\n\nand to:\n\n```{.bash}\nunzip bash.zip; rm bash.zip\n```\n\nThis is what we did to get the data for the past few sessions.\n\nIn all three cases, both commands will try to run. Now, if for some reason, the unzipping fails, the zip file still gets deleted. That's a bummer.\n\n## Conditional on previous command\n\n### Execution conditional on success\n\nCommands can be limited to running only if the previous command ran successfully thanks to the double-ampersand (`&&`).\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\nunzip bash.zip &&\n\trm bash.zip\n```\n\nThis is equivalent to:\n\n```{.bash}\nunzip bash.zip && rm bash.zip\n```\n\nIf the unzipping works (if it returns a zero [exit status](https://en.wikipedia.org/wiki/Exit_status)), then the Zip file gets deleted. If however, the unzipping fails (if it returns a non-zero exit status), the script aborts and we haven't lost our Zip file.\n\n### Execution conditional on failure\n\nThe opposite of `&&` is `||`: the second command only gets executed if the first one failed.\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\nunzip bash.zip || echo \"Unzipping failed\"\n```\n\nThis can also be written as:\n\n```{.bash}\nunzip bash.zip ||\n\techo \"Unzipping failed\"\n```\n\n## Conditional executions\n\nCommands can be executed or not depending on some conditions. To achieve this, we first need to have expressions that define these conditions.\n\n### Predicates\n\nPredicates are expressions that, when evaluated, return either true or false.\n\nHere are examples of predicates:\n\n`[ $var == 'text' ]` checks whether `var` is equal to `'text'`.\n\n`[ $var == number ]` checks whether `var` is equal to `number`.\n\n`[ -e name ]` checks whether `name` exists.\n\n`[ -d name ]` checks whether `name` is a directory.\n\n`[ -f name ]` checks whether `name` is a file.\n\n[Make sure to have spaces around each bracket.]{.emph}\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n- Create a directory `d1` and a file `f1`.\n\n<!-- ```{.bash} -->\n<!-- mkdir d1 -->\n<!-- touch f1 -->\n<!-- ``` -->\n\n- Write the predicates that test whether:\n\n- `d1` exists,\n- `d1` is a file,\n- `d1` is a directory,\n- `f1` is a file,\n- `f1` is a directory.\n\n:::\n\n### If statements\n\n#### Syntax\n\nIn its simplest form, `if` statements look like:\n\n```{.bash}\nif [ predicate ]\nthen\n\tcommand1\n\tcommand2\n\t...\nfi\n```\n\n:::{.notenoit}\n\nThis can also be written as:\n\n```{.bash}\nif [ predicate ]; then command1; command2; ...; fi\n```\n\n:::\n\nIf the condition is true, the commands are executed, if the condition is false, nothing happens.\n\n#### Examples\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=f1\n\nif [ -e $var ]\nthen\n\techo \"$var exists\"\nfi\n```\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=f2\n\nif [ -e $var ]\nthen\n\techo \"$var exists\"\nfi\n```\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWrite a conditional expression that prints \"d1 is a directory\" if `d1` is a directory and test it.\n\n:::\n\n### If else statements\n\n#### Syntax\n\nIf you want a different set of commands to be executed when the condition is false, you add an `else` statement:\n\n```{.bash}\nif [ predicate ]\nthen\n\tcommand1\n\tcommand2\n\t...\nelse\n\tcommand3\n\tcommand4\n\t...\nfi\n```\n\n#### Examples\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=f1\n\nif [ -e $var ]\nthen\n\techo \"$var exists\"\nelse\n\techo \"$var does not exist\"\nfi\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nf1 does not exist\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=f2\n\nif [ -e $var ]\nthen\n\techo \"$var exists\"\nelse\n\techo \"$var does not exist\"\nfi\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nf2 does not exist\n```\n\n\n:::\n:::\n\n\n### If elif else statements\n\nOf course, you can have multiple conditions defining trees of `if` statements. In that case, you use `elif` (any number of times):\n\n#### Syntax\n\n```{.bash}\nif [ predicate1 ]\nthen\n\tcommand1\n\tcommand2\n\t...\nelif [ predicate2 ]\nthen\n\tcommand3\n\tcommand4\n\t...\nelse\n\tcommand5\n\tcommand6\n\t...\nfi\n```\n\n#### Examples\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=4\n\nif (( $var < 0 ))\nthen\n\techo \"$var is negative\"\nelif (( $var > 0 ))\nthen\n\techo \"$var is positive\"\nelse\n\techo \"$var is equal to zero\"\nfi\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 is positive\n```\n\n\n:::\n:::\n\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nPlay with the value of `var` to test our if elif else statement.\n\n:::\n\n## Conditionally repeated executions\n\nCommands can be executed as long as a condition returns `True` thanks to *while loops*.\n\n### Syntax\n\nThe syntax of a while loop in Bash is:\n\n```{.bash}\nwhile [ predicate ]\ndo\n\tcommand1\n\tcommand2\n\t...\ndone\n```\n\n### Example\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=0\n\nwhile (($var<10))\ndo\n    echo \"$var\"\n\t((var++))\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n\n:::\n:::\n\n\nBe careful that while loops can lead to infinite loops. Such loops need to be manually interrupted (by pressing `<Ctrl+C>`).\n\n:::{.example}\n\nExample of infinite loop:\n\n:::\n\n```{.bash}\nvar=1\n\nwhile (($var>0))\ndo\n\techo \"$var (Press <Ctrl+C> to stop)\"\n\t((var++))\n\tsleep 1\ndone\n```\n\n## Executions repeated over a collection\n\nCommands can be repeated for each element of a list thanks to *for loops*.\n\n### Collections\n\nFor loops run a set of commands for each item of a collection. How do you create those collections?\n\n#### Listing items one by one\n\nThe least efficient method is to list all the items one by one:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor i in file1 file2 file3\ndo\n\techo $i\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1\nfile2\nfile3\n```\n\n\n:::\n:::\n\n\n#### Wildcards\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls *.pdb\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nls: cannot access '*.pdb': No such file or directory\n```\n\n\n:::\n:::\n\n\n#### Brace expansion\n\nCollections can also be created with brace expansion.\n\n:::{.example}\n\nExamples:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1,2,5}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 5\n```\n\n\n:::\n:::\n\n\n:::{.note}\n\nMake sure not to add a space after the commas.\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {list,of,strings}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist of strings\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {file1,file2}.sh\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1.sh file2.sh\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls {ethane,methane,pentane}.pdb\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nls: cannot access 'ethane.pdb': No such file or directory\nls: cannot access 'methane.pdb': No such file or directory\nls: cannot access 'pentane.pdb': No such file or directory\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1..5}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {01..10}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n01 02 03 04 05 06 07 08 09 10\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {r..v}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nr s t u v\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {v..r}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nv u t s r\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {a..e}{1..3}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\na1 a2 a3 b1 b2 b3 c1 c2 c3 d1 d2 d3 e1 e2 e3\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {a..c}{a..c}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\naa ab ac ba bb bc ca cb cc\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1..5}.txt\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.txt 2.txt 3.txt 4.txt 5.txt\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho file{3..6}.sh\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile3.sh file4.sh file5.sh file6.sh\n```\n\n\n:::\n:::\n\n\n#### Sequences\n\nCollections can also be sequences:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nseq 1 2 10\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n3\n5\n7\n9\n```\n\n\n:::\n:::\n\n\n:::{.note}\n\nHere, `1` is the start of the sequence, `10` is the end, and `2` is the step.\n\n:::\n\n### For loops\n\n#### Syntax\n\nThe general structure of a for loop is as follows:\n\n```{.bash}\nfor iterable in collection\ndo\n\tcommand1\n\tcommand2\n\t...\ndone\n```\n\n#### Examples\n\nThe `molecules` directory contains a number of `.pdb` files. We want to rename them by prepending \"gas_\" to their current names.\n\nWe can do this by creating a collection with a wildcard and applying the command to each element of the collection with a for loop:\n\n```{.bash}\nfor file in *.pdb\ndo\n\tmv $file gas_$file\ndone\n```\n\n:::{.notenoit}\n\nThis can also be written as:\n\n```{.bash}\nfor file in *.pdb; do mv $file gas_$file; done\n```\n\n:::\n\nHere is a for loop using a collection created by a sequence:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor i in $(seq 1 2 10)\ndo\n\techo file$i.txt\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1.txt\nfile3.txt\nfile5.txt\nfile7.txt\nfile9.txt\n```\n\n\n:::\n:::\n\n\n<!-- :::{.exo} -->\n\n<!-- :::{.yourturn} -->\n\n<!-- Your turn: -->\n\n<!-- ::: -->\n\n<!-- Using what we learnt in the [string manipulation](https://mint.westdri.ca/bash/variables.html#string-manipulation) section, how could you remove the `gas_` prefix to all these files? -->\n\n<!-- ::: -->\n\n<!-- for ((i=1; i<=5; i++)) do echo $i; done   # can use C-style loops -->\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIn a directory the command `ls` returns:\n\n```\nfructose.dat  glucose.dat  sucrose.dat  maltose.txt\n```\n\nWhat would be the output of the following loop?\n\n```{.bash}\nfor datafile in *.dat\ndo\n  cat $datafile >> sugar.dat\ndone\n```\n\n1. All of the text from `fructose.dat`, `glucose.dat` and `sucrose.dat` would be concatenated and saved to a file called `sugar.dat`.\n\n2. The text from `sucrose.dat` will be saved to a file called `sugar.dat`.\n\n3. All of the text from `fructose.dat`, `glucose.dat`, `sucrose.dat`, and `maltose.txt` would be concatenated and saved to a file called `sugar.dat`.\n\n4. All of the text from `fructose.dat`, `glucose.dat` and `sucrose.dat` will be printed to the screen and saved into a file called `sugar.dat`.\n\n:::\n\n<!-- Write a loop that concatenates all .pdb files in `data-shell/molecules` subdirectory into one file called `allmolecules.txt`, prepending each fragment with the name of the corresponding .pdb file, and separating different files with an empty line. Run the loop, make sure it works, bring it up with the &nbsp;**↑**&nbsp; key and paste into the chat. -->\n\n<!-- What will the loop `for i in hello 1 2 * bye; do echo $i; done` print? Try answering without running the loop. -->\n\n<!-- Create a loop that writes into 10 files `chapter01.md`, `chapter02.md`, ..., `chapter10.md`. Each file should contain -->\n<!-- chapter-specific lines, e.g. `chapter05.md` will contain exactly these lines: -->\n\n*[Here](https://youtu.be/cCunoOIksAE) is a video of a previous version of this workshop.*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}