{
  "hash": "861fc4882ed53027b9d872d8859ec992",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Variables\naliases:\n  - variables.html\nauthor:\n  - Marie-Hélène Burle\n  - Alex Razoumov\n---\n\n::: {.cell}\n\n:::\n\n\n:::{.def}\n\nYou can assign values to names. These names and the values they hold are called \"variables\".\n\nVariables are a convenient way to reuse values.\n\n:::\n\n## Declaring variables\n\nYou declare a variable (i.e. a name that holds a value) with the `=` sign:\n\n```{.bash}\nvar=value\n```\n\n:::{.note}\n\nMake sure not to put spaces around the equal sign.\n\n:::\n\n:::{.example}\n\nExample:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=5\n```\n:::\n\n\nYou can delete a variable with the `unset` command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nunset var\n```\n:::\n\n\n## Expanding variables\n\nTo expand a variable (to access its value), you need to prepend its name with `$`.\n\n:::{.example}\n\nThis is not what we want:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=value\necho var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nvar\n```\n\n\n:::\n:::\n\n\n:::{.example}\n\nThis however works:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=value\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nvalue\n```\n\n\n:::\n:::\n\n\n## Quotes\n\n### When declaring\n\nQuotes are necessary for values containing special characters such as spaces.\n\n:::{.example}\n\nThis doesn't work:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=string with spaces\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbash: line 1: with: command not found\n```\n\n\n:::\n:::\n\n\n:::{.example}\n\nThis works:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=\"string with spaces\"\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstring with spaces\n```\n\n\n:::\n:::\n\n\n:::{.example}\n\nThis also works:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar='string with spaces'\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstring with spaces\n```\n\n\n:::\n:::\n\n\nWhen declaring variables, single and double quotes are equivalent. Which one should you use then? Use the one that is most convenient.\n\n:::{.example}\n\nThis is not good:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar='that's a string with spaces'\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbash: -c: line 1: unexpected EOF while looking for matching `''\n```\n\n\n:::\n:::\n\n\n:::{.example}\n\nThis works well:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=\"that's a string with spaces\"\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nthat's a string with spaces\n```\n\n\n:::\n:::\n\n\n:::{.note}\n\nAlternatively, single quotes can be escaped, but it is a little crazy: the first `'` ends the first string, then the apostrophe needs to be escaped (`\\'`), finally, the third `'` starts the second string.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar='that'\\''s a string with spaces'\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nthat's a string with spaces\n```\n\n\n:::\n:::\n\n\n:::\n\n:::{.example}\n\nConversely, this is not good:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=\"he said: \"string with spaces\"\"\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbash: line 1: with: command not found\n```\n\n\n:::\n:::\n\n\n:::{.example}\n\nWhile this works:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar='he said: \"string with spaces\"'\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nhe said: \"string with spaces\"\n```\n\n\n:::\n:::\n\n\n:::{.note}\n\nDouble quotes as well can be escaped (simply by prepending them with `\\`):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=\"he said: \\\"string with spaces\\\"\"\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nhe said: \"string with spaces\"\n```\n\n\n:::\n:::\n\n\n:::\n\n### When expanding\n\nWhile not necessary in many situations, it is safer to expand variables in double quotes, in case the expansion leads to problematic special characters. In the example above, this was not problematic and using `$var` or `\"$var\"` both work.\n\nIn the following example however, it is problematic:\n\n```{.bash}\nvar=\"string with spaces\"\ntouch $var\n```\n\nThis creates 3 files called `string`, `with`, and `spaces`. Probably not what you wanted...\n\nThe following creates a single file called `string with spaces`:\n\n```{.bash}\nvar=\"string with spaces\"\ntouch \"$var\"\n```\n\n:::{.note}\n\nTo be safe, it is thus a good habit to quote expanded variables.\n\n:::\n\nIt is important to note however that [single quotes don't expand variables]{.emph} (only double quotes do).\n\nThe following would thus create a file called `$var`:\n\n```{.bash}\nvar=\"string with spaces\"\ntouch '$var'\n```\n\n## Exporting variables\n\nUsing `export` ensures that all inherited processes of the current shell also have access to this variable:\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\nvar=3\nzsh\t      \t  # Launch Zsh (another shell)\necho $var\n```\n\nThis returns nothing: `var` is not defined in the Zsh process.\n\n```{.bash}\nexport var=3\nzsh\necho $var\n```\n\nThis returns `3`: `var` got exported into the Zsh process.\n\n## String manipulation\n\n### Getting a subset\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=\"hello\"\necho ${var:2}      # Print from character 2\necho ${var:2:1}    # Print 1 character from character 2\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nllo\nl\n```\n\n\n:::\n:::\n\n\n:::{.note}\n\nBash indexes from 0.\n\n:::\n\n### Search and replace\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=\"hello\"\necho ${var/l/L}    # Replace the first match of l by L\necho ${var//l/L}   # Replace all matches of l by L\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nheLlo\nheLLo\n```\n\n\n:::\n:::\n\n\n### String concatenation\n\nIf you want to concatenate the expanded variable with another string, you need to use curly braces or quotes.\n\n:::{.example}\n\nThis does not return anything because there is no variable called `varshine`:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=sun\necho $varshine\n```\n:::\n\n\n:::{.example}\n\nThese two syntaxes do work:\n\n:::\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvar=sun\necho ${var}shine\necho \"$var\"shine\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsunshine\nsunshine\n```\n\n\n:::\n:::\n\n\n## Environment variables\n\n[Environment variables](https://en.wikipedia.org/wiki/Environment_variable) help control the behaviour of processes on a machine. You can think of them as customizations of your system.\n\nMany are set automatically.\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\necho $HOME\n```\n\n```\n/home/user09\n```\n\nThere are many other environment variables (e.g. `PATH`, `PWD`, `PS1`). To see the list, you can run `printenv` or `env`.\n\nIf you want to add new environment variables, you can add them to your `~/.bashrc` file which is sourced each time you start a new shell.\n\n*[Here](https://youtu.be/nNf4Xb56yEs) is a video of a previous version of this workshop.*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}