{
  "hash": "e0130376f9eb7e468936c9932ce8deb4",
  "result": {
    "markdown": "---\ntitle: Writing scripts\nauthor: Marie-Hélène Burle\n---\n\n::: {.cell hash='script_cache/html/unnamed-chunk-1_75e3802920c0a4c5b4bf6e65b0786d72'}\n\n:::\n\n\n:::{.def}\n\nThere are series of commands that you need to run regularly. Instead of having to type them each time, you can write them in a text file (called a script) with a `.sh` extension and execute that file whenever you want to run that set of commands. This is a great way to automate work.\n\nThis section covers scripts syntax and execution.\n\n:::\n\n:::{.callout-accordion collapse=\"true\"}\n\n## ***Data for this section***\n\nFor this section, we will play with files created by [The Carpentries](https://carpentries.org/).\n\nYou can download them into a zip file called `bash.zip` with:\n\n```{.bash}\nwget http://bit.ly/bashfile -O bash.zip\n```\n\nYou can then unzip that file with:\n\n```{.bash}\nunzip bash.zip\n```\n\nFinally, you can delete the zip file:\n\n```{.bash}\nrm bash.zip\n```\n\nYou should now have a `data-shell` directory with a `molecules` subdirectory.\n\n`cd` into it:\n\n```{.bash}\ncd data-shell/molecules\n```\n\n:::\n\n## Writing and executing scripts\n\n### Scripts as arguments to `bash`\n\nA shell script is simply a text file. You can create it with a text editor such as [nano](https://en.wikipedia.org/wiki/GNU_nano) which is installed on most systems.\n\nLet's try to create one that we will call `test.sh`:\n\n```{.bash}\nnano test.sh\n```\n\nIn the file, write the command: `echo This is my first script`.\n\nTo distinguish between commands run in the terminal and commands written in a file, I will display the content of files this way:\n\n```{.bash filename=\"<file name>\"}\n<commands>\n```\n\nSo this is the content of our `test.sh` file:\n\n```{.bash filename=\"test.sh\"}\necho This is my first script\n```\n\nNow, how do we run this?\n\nWe simply pass it as an argument to the `bash` command:\n\n```{.bash}\nbash test.sh\n```\n\n```\nThis is my first script\n```\n\nAnd it worked!\n\n### Shebang\n\nThere is another way to write and execute scripts: we can use a [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).\n\nA shebang consists of the characters `#!` followed by the path of an executable. Here, the executable we want is `bash` and its path is `/bin/bash`.\n\nSo our script becomes:\n\n```{.bash filename=\"test.sh\"}\n#!/bin/bash\n\necho This is my first script.\n```\n\nNow, the cool thing about this is that we don't need to pass the script as an argument of the `bash` command anymore since the information that this should be executed by Bash is already written in the shebang. Instead, we can execute it with `./test.sh`.\n\nBut there is a little twist:\n\n```{.bash}\n./test.sh\n```\n\n```\nbash: ./test.sh: Permission denied\n```\n\nWe first need to make the file executable by changing its permissions.\n\n### Unix permissions\n\nUnix systems such as Linux use [POSIX permissions](https://en.wikipedia.org/wiki/File-system_permissions#POSIX_permissions).\n\nTo add an executable permission to a file, you need to run:\n\n```{.bash}\nchmod u+x test.sh\n```\n\nNow that our script is executable, we can run:\n\n```{.bash}\n./test.sh\n```\n\n```\nThis is my first script\n```\n\n<!-- ```{.bash} -->\n<!-- echo Looking into file octane.pdb -->\n<!-- head -15 octane.pdb | tail -5       # what does it do? -->\n<!-- bash process.sh   # the script ran! -->\n<!-- ``` -->\n\n<!-- ```{.bash} -->\n<!-- #!/bin/bash -->\n<!-- echo Looking into file octane.pdb -->\n<!-- head -15 octane.pdb | tail -5       # what does it do? -->\n<!-- bash process.sh   # the script ran! -->\n<!-- ``` -->\n\n<!-- Alternatively, you can change file permissions: -->\n\n<!-- ```{.bash} -->\n<!-- chmod u+x process.sh -->\n<!-- ./process.sh -->\n<!-- ``` -->\n\n<!-- Let's pass an arbitrary file to it: -->\n\n<!-- ```{.bash} -->\n<!-- nano process.sh -->\n<!-- \t#!/bin/bash -->\n<!-- \techo Looking into file $1       # $1 means the first argument to the script -->\n<!--     head -15 $1 | tail -5 -->\n<!-- ./process cubane.pdb -->\n<!-- ./process propane.pdb -->\n<!-- ``` -->\n\n<!-- * head -15 \"$1\" | tail -5     # placing in double-quotes lets us pass filenames with spaces -->\n<!-- * head $2 $1 | tail $3        # what will this do? -->\n<!-- * $# holds the number of command-line arguments -->\n<!-- * $@ means all command-lines arguments to the script (words in a string) -->\n\n<!-- > **Quiz 11:** script.sh in molecules Users/nelle/molecules. -->\n\n<!-- > **Exercise:** write a script that takes any number of filenames, e.g., \"scriptName.sh cubane.pdb -->\n<!-- > propane.pdb\", for each file prints the number of lines and its first five lines, and separates the -->\n<!-- > output from different files by an empty line. -->\n\n<!-- In the `molecules` directory (download link mentioned <a href=\"../bash/bash-04-tar-gzip\" target=\"_blank\">here</a>), -->\n<!-- create a shell script called `scan.sh` containing the following: -->\n<!-- ```{.bash} -->\n<!-- #!/bin/bash -->\n<!-- head -n $2 $1 -->\n<!-- tail -n $3 $1 -->\n<!-- ``` -->\n<!-- While you are in that current directory, you type the following command (with space between two 1s): -->\n<!-- ```{.bash} -->\n<!-- ./scan.sh  '*.pdb'  1  1 -->\n<!-- ``` -->\n<!-- What output would you expect to see? -->\n<!-- 1. All of the lines between the first and the last lines of each file ending in `.pdb` in the current directory -->\n<!-- 2. The first and the last line of each file ending in `.pdb` in the current directory -->\n<!-- 3. The first and the last line of each file in the current directory -->\n<!-- 4. An error because of the quotes around `*.pdb` -->\n\n*[Here](https://youtu.be/UGZI6_HDyDc) and [here](https://youtu.be/rNnrcqkhXQo) are two videos of a previous version of this workshop.*\n\n## Scripts vs functions\n\nScripts and functions play similar roles and they both can take command-line arguments.\n\nA *script* is a file sitting at a given path whereas a *function* is defined in your environment. Therefore, you need to prepend a script's path to its name to run it, while you can call a function by its name without the need for a path.\n\n## Scripts in other languages\n\nAs a side note, it is possible to incorporate scripts in other languages into your bash code.\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\nfunction test() {\n    randomFile=${RANDOM}${RANDOM}.py\n    cat << EOF > $randomFile\n#!/usr/bin/python3\nprint(\"do something in Python\")\nEOF\n    chmod u+x $randomFile\n    ./$randomFile\n    /bin/rm $randomFile\n}\n```\n\n:::{.note}\n\n`EOF` is a random delimiter string and `<<` tells Bash to wait for that delimiter to end the input.\n\nHere is an example of this syntax:\n\n```{.bash}\ncat << the_end\nThis text\nwill be printed\nin the terminal.\nthe_end\n```\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}