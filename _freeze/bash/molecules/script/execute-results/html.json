{
  "hash": "d2ded65a4ba4bf83eae4122e96a0951e",
  "result": {
    "markdown": "---\ntitle: Writing scripts\nauthor:\n  - Marie-Hélène Burle\n  - Alex Razoumov\n---\n\n::: {.cell hash='script_cache/html/unnamed-chunk-1_75e3802920c0a4c5b4bf6e65b0786d72'}\n\n:::\n\n\n:::{.def}\n\nThere are series of commands that you need to run regularly. Instead of having to type them each time, you can write them in a text file (called a script) with a `.sh` extension and execute that file whenever you want to run that set of commands. This is a great way to automate work.\n\nThis section covers scripts syntax and execution.\n\n:::\n\n:::{.callout-accordion collapse=\"true\"}\n\n## ***Data for this section***\n\nFor this section, we will be using data put together by [The Carpentries](https://carpentries.org/). You can download it by clicking [here](http://bit.ly/bashfile).\n\nThis will download a zip filed called `bfiles.zip`. Unzip it to your home directory. You should now see a `data-shell` directory. In it is a subdirectory called `molecules`.\n\nThis is what we will use for now, so `cd` into it:\n\n```{.bash}\ncd data-shell/molecules\n```\n\n:::\n\n## Writing and executing scripts\n\n### Scripts as arguments to `bash`\n\nA shell script is simply a text file. You can create it with a text editor such as [nano](https://en.wikipedia.org/wiki/GNU_nano) which is installed on most systems.\n\nLet's try to create one that we will call `test.sh`:\n\n```{.bash}\nnano test.sh\n```\n\nIn the file, write the command: `echo This is my first script`.\n\nTo distinguish between commands run in the terminal and commands written in a file, I will display the content of files this way:\n\n```{.bash filename=\"<file name>\"}\n<commands>\n```\n\nSo this is the content of our `test.sh` file:\n\n```{.bash filename=\"test.sh\"}\necho This is my first script\n```\n\nNow, how do we run this?\n\nWe simply pass it as an argument to the `bash` command:\n\n```{.bash}\nbash test.sh\n```\n\n```\nThis is my first script\n```\n\nAnd it worked!\n\n### Shebang\n\nThere is another way to write and execute scripts: we can use a [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).\n\nA shebang consists of the characters `#!` followed by the path of an executable. Here, the executable we want is `bash` and its path is `/bin/bash`.\n\nSo our script becomes:\n\n```{.bash filename=\"test.sh\"}\n#!/bin/bash\n\necho This is my first script.\n```\n\nNow, the cool thing about this is that we don't need to pass the script as an argument of the `bash` command anymore since the information that this should be executed by Bash is already written in the shebang. Instead, we can execute it with `./test.sh`.\n\nBut there is a little twist:\n\n```{.bash}\n./test.sh\n```\n\n```\nbash: ./test.sh: Permission denied\n```\n\nWe first need to make the file executable by changing its permissions.\n\n### Unix permissions\n\nUnix systems such as Linux use [POSIX permissions](https://en.wikipedia.org/wiki/File-system_permissions#POSIX_permissions).\n\nTo add an executable permission to a file, you need to run:\n\n```{.bash}\nchmod u+x test.sh\n```\n\nNow that our script is executable, we can run:\n\n```{.bash}\n./test.sh\n```\n\n```\nThis is my first script\n```\n\n<!-- ```{.bash} -->\n<!-- echo Looking into file octane.pdb -->\n<!-- head -15 octane.pdb | tail -5       # what does it do? -->\n<!-- bash process.sh   # the script ran! -->\n<!-- ``` -->\n\n<!-- ```{.bash} -->\n<!-- #!/bin/bash -->\n<!-- echo Looking into file octane.pdb -->\n<!-- head -15 octane.pdb | tail -5       # what does it do? -->\n<!-- bash process.sh   # the script ran! -->\n<!-- ``` -->\n\n<!-- Alternatively, you can change file permissions: -->\n\n<!-- ```{.bash} -->\n<!-- chmod u+x process.sh -->\n<!-- ./process.sh -->\n<!-- ``` -->\n\n<!-- Let's pass an arbitrary file to it: -->\n\n<!-- ```{.bash} -->\n<!-- nano process.sh -->\n<!-- \t#!/bin/bash -->\n<!-- \techo Looking into file $1       # $1 means the first argument to the script -->\n<!--     head -15 $1 | tail -5 -->\n<!-- ./process cubane.pdb -->\n<!-- ./process propane.pdb -->\n<!-- ``` -->\n\n<!-- * head -15 \"$1\" | tail -5     # placing in double-quotes lets us pass filenames with spaces -->\n<!-- * head $2 $1 | tail $3        # what will this do? -->\n<!-- * $# holds the number of command-line arguments -->\n<!-- * $@ means all command-lines arguments to the script (words in a string) -->\n\n<!-- > **Quiz 11:** script.sh in molecules Users/nelle/molecules. -->\n\n<!-- > **Exercise:** write a script that takes any number of filenames, e.g., \"scriptName.sh cubane.pdb -->\n<!-- > propane.pdb\", for each file prints the number of lines and its first five lines, and separates the -->\n<!-- > output from different files by an empty line. -->\n\n<!-- In the `molecules` directory (download link mentioned <a href=\"../bash/bash-04-tar-gzip\" target=\"_blank\">here</a>), -->\n<!-- create a shell script called `scan.sh` containing the following: -->\n<!-- ```{.bash} -->\n<!-- #!/bin/bash -->\n<!-- head -n $2 $1 -->\n<!-- tail -n $3 $1 -->\n<!-- ``` -->\n<!-- While you are in that current directory, you type the following command (with space between two 1s): -->\n<!-- ```{.bash} -->\n<!-- ./scan.sh  '*.pdb'  1  1 -->\n<!-- ``` -->\n<!-- What output would you expect to see? -->\n<!-- 1. All of the lines between the first and the last lines of each file ending in `.pdb` in the current directory -->\n<!-- 2. The first and the last line of each file ending in `.pdb` in the current directory -->\n<!-- 3. The first and the last line of each file in the current directory -->\n<!-- 4. An error because of the quotes around `*.pdb` -->\n\n*[Here](https://youtu.be/UGZI6_HDyDc) and [here](https://youtu.be/rNnrcqkhXQo) are two videos of a previous version of this workshop.*\n\n## Variables\n\nIn Bash, it is possible to define variables. Let's create a variable and print its value:\n\n\n::: {.cell hash='script_cache/html/unnamed-chunk-2_9cf512a2c879144c551dd01a65b76e76'}\n\n```{.bash .cell-code}\nvar=3     # Do not add spaces around the equality sign\necho var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nvar\n```\n:::\n:::\n\n\nMmm... not what we wanted...\n\nTo retrieve the value of a shell variable, we need to prepend `$` to it:\n\n\n::: {.cell hash='script_cache/html/unnamed-chunk-3_5a6e9fe45d8799e7ae543494e50fc731'}\n\n```{.bash .cell-code}\nvar=3\necho $var\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\nSometimes you will see this notation:\n\n```{.bash}\nexport myvar=3\n```\n\nUsing `export` ensures that all inherited processes of this shell also have access to this variable.\n\n<!-- Try defining the variable *newvar* without/with 'export' and then running the script: -->\n\n<!-- ```{.bash} -->\n<!-- nano process.sh -->\n<!-- \t#!/bin/bash -->\n<!--     echo $newvar -->\n<!-- ``` -->\n\n<!-- You can assign a command's output to a variable to use in another command (this is called *command -->\n<!-- substitution*) -- we'll see this later when we play with 'find' command. -->\n\nTo delete a variable, run:\n\n\n::: {.cell hash='script_cache/html/unnamed-chunk-4_a50814f6ccb2a34fea84cb9c531a93cb'}\n\n```{.bash .cell-code}\nunset var\n```\n:::\n\n\nVariables are extremely useful in scripts.\n\n<!-- ```{bash} -->\n<!-- var=\"sun\" -->\n<!-- echo $varshine -->\n<!-- echo ${var}shine -->\n<!-- echo \"$var\"shine -->\n<!-- ``` -->\n\n<!-- ```{bash} -->\n<!-- myvar=\"hello\" -->\n<!-- echo $myvar -->\n<!-- echo ${myvar:offset} -->\n<!-- echo ${myvar:offset:length} -->\n<!-- echo ${myvar:2:3}    # 3 characters starting from character 2 -->\n<!-- echo ${myvar/l/L}    # replace the first match of a pattern -->\n<!-- echo ${myvar//l/L}   # replace all matches of a pattern -->\n<!-- ``` -->\n\n### Variable manipulation\n\nWhen recalling the value of a variable, you can make changes to it.\n\n:::{.example}\n\nExample:\n\n:::\n\n\n::: {.cell hash='script_cache/html/unnamed-chunk-5_15a365f9da11738740e51ebdcb8e0743'}\n\n```{.bash .cell-code}\nmyvar=\"hello\"\necho $myvar\necho ${myvar:2:3}    # Print 3 characters starting from character 2\necho ${myvar/l/L}    # Replace the first match of a pattern\necho ${myvar//l/L}   # Replace all matches of a pattern\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\nllo\nheLlo\nheLLo\n```\n:::\n:::\n\n\n### Environment variables\n\n[Environment variables](https://en.wikipedia.org/wiki/Environment_variable) help control the behaviour of processes on a machine. You can think of them as customizations of your system.\n\nMany are set automatically.\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\necho $HOME\n```\n\n```\n/home/user20\n```\n\nThere are many other environment variables (e.g. `PATH`, `PWD`, `PS1`). To see the list, you can run `printenv` or `env`.\n\nIf you want to add new environment variables, you can add them to your `~/.bashrc` file which is sourced each time you start a new shell.\n\n<!-- Play with variables and their values. Change the prompt, e.g. `PS1=\"\\u@\\h \\w> \"`. -->\n\n*[Here](https://youtu.be/nNf4Xb56yEs) is a video of a previous version of this workshop.*\n\n## Scripts in other languages\n\nAs a side note, it is possible to incorporate scripts in other languages into your bash code.\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\nfunction test() {\n    randomFile=${RANDOM}${RANDOM}.py\n    cat << EOF > $randomFile\n#!/usr/bin/python3\nprint(\"do something in Python\")\nEOF\n    chmod u+x $randomFile\n    ./$randomFile\n    /bin/rm $randomFile\n}\n```\n\n:::{.note}\n\n`EOF` is a random delimiter string and `<<` tells Bash to wait for that delimiter to end the input.\n\nHere is an example of this syntax:\n\n```{.bash}\ncat << the_end\nThis text\nwill be printed\nin the terminal.\nthe_end\n```\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}