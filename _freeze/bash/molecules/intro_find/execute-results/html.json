{
  "hash": "4c9f0109b2a514f67327db1530086f79",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Finding files\naliases:\n  - find.html\nauthor: Marie-Hélène Burle\n---\n\n::: {.cell}\n\n:::\n\n:::{.callout-accordion collapse=\"true\"}\n\n## ***Data for this section***\n\nFor this section, we will play with files created by [The Carpentries](https://carpentries.org/).\n\nYou can download them into a zip file called `bash.zip` with:\n\n```{.bash}\nwget http://bit.ly/bashfile -O bash.zip\n```\n\nYou can then unzip that file with:\n\n```{.bash}\nunzip bash.zip\n```\n\nFinally, you can delete the zip file:\n\n```{.bash}\nrm bash.zip\n```\n\nYou should now have a `data-shell` directory with a `molecules` subdirectory.\n\n`cd` into it:\n\n```{.bash}\ncd data-shell/molecules\n```\n\n:::\n\n## Command `find`\n\nSearch for files inside the current working directory:\n\n```{.bash}\nfind . -type f\n```\n\n```\n./methane.pdb\n./pentane.pdb\n./sorted.txt\n./propane.pdb\n./lengths.txt\n./cubane.pdb\n./ethane.pdb\n./octane.pdb\n```\n\n`find . -type d` will instead search for directories inside the current working directory.\n\nHere are other examples:\n\n```{.bash}\nfind . -maxdepth 1 -type f     # depth 1 is the current directory\nfind . -mindepth 2 -type f     # current directory and one level down\nfind . -name haiku.txt      # finds specific file\nls data       # shows one.txt two.txt\nfind . -name *.txt      # still finds one file -- why? answer: expands *.txt to haiku.txt\nfind . -name '*.txt'    # finds all three files -- good!\n```\n\nLet's wrap the last command into `$()`—called *command substitution*—as if it were a variable:\n\n```{.bash}\necho $(find . -name '*.txt')   # will print ./data/one.txt ./data/two.txt ./haiku.txt\nls -l $(find . -name '*.txt')   # will expand to ls -l ./data/one.txt ./data/two.txt ./haiku.txt\nwc -l $(find . -name '*.txt')   # will expand to wc -l ./data/one.txt ./data/two.txt ./haiku.txt\ngrep elegant $(find . -name '*.txt')   # will look for 'elegant' inside all *.txt files\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n`grep`'s `-v` flag inverts pattern matching, so that only lines that do **not** match the pattern are printed.\n\nGiven that, which of the following commands will find all files in `/data` whose names end in `ose.dat` (e.g. `sucrose.dat` or `maltose.dat`), but do not contain the word `temp`?\n\n1. `find /data -name '*.dat' | grep ose | grep -v temp`\n2. `find /data -name ose.dat | grep -v temp`\n3. `grep -v temp $(find /data -name '*ose.dat')`\n4. None of the above\n\n:::\n\n*[Here](https://youtu.be/AnwsnESj82Q) is a video of a previous version of this workshop.*\n\n## Running a command on the results of `find`\n\nLet's say that you want to run a command on each of the files in the output of `find`. You can always do something using command substitution like this:\n\n```{.bash}\nfor f in $(find . -name \"*.txt\")\ndo\n    command on $f\ndone\n```\n\nAlternatively, you can make it a one-liner:\n\n```{.bash}\nfind . -name \"*.txt\" -exec command {} \\;\n```\n\nAnother—perhaps more elegant—one-line alternative is to use `xargs`. In its simplest usage, `xargs` command lets you construct a list of arguments:\n\n```{.bash}\nfind . -name \"*.txt\"                   # returns multiple lines\nfind . -name \"*.txt\" | xargs           # use those lines to construct a list\nfind . -name \"*.txt\" | xargs command   # pass this list as arguments to `command`\ncommand $(find . -name \"*.txt\")        # command substitution, achieving the same result (this is riskier!)\ncommand `(find . -name \"*.txt\")`       # alternative syntax for command substitution\n```\n\nIn these examples, `xargs` achieves the same result as command substitution, but it is safer in terms of memory usage and the length of lists you can pass.\n\nWhen would you need to use this? A good example is with the command `grep`. `grep` takes a search stream (and not a list of files) as its standard input:\n\n```{.bash}\ncat filename | grep pattern\n```\n\nTo pass a list of files to grep, you can use `xargs` that takes that list from its standard input and converts it into a list of arguments that is then passed to `grep`:\n\n```{.bash}\nfind . -name \"*.txt\" | xargs grep pattern   # search for `pattern` inside all those files (`grep` does not take a list of files as standard input)\n```\n\n<!-- Write a one-line command that will search for a string in all files in the current directory and all its subdirectories and will hide errors (e.g. due to permissions). -->\n\n<!-- Play with command substitution using both `$(...)` and ``` `...` ``` syntax. -->\n\n*[Here](https://youtu.be/aFrMKkjMIHY) is a video of a previous version of this workshop.*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}