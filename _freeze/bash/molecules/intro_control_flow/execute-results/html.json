{
  "hash": "96c1455908fb44cddde5c85a4a6f6fc0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Control flow\naliases:\n  - control_flow.html\nauthor:\n  - Marie-Hélène Burle\n  - Alex Razoumov\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::{.def}\n\nBy default, scripts get executed linearly from top to bottom. Often however, you will want to control what gets executed when.\n\nThis section covers various ways to control the flow of execution through a script.\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n\n## Data for this section (same data as previous sections)\n\nFor this section, we will play with files created by [The Carpentries](https://carpentries.org/).\n\nYou can download them into a zip file called `bash.zip` with:\n\n```{.bash}\nwget https://bit.ly/bashfile -O bash.zip\n```\n\nYou can then unzip that file with:\n\n```{.bash}\nunzip bash.zip\n```\n\nYou should now have a `data-shell` directory with a `molecules` subdirectory.\n\n`cd` into it:\n\n```{.bash}\ncd data-shell/molecules\n```\n\n:::\n\n## Next command conditional on success\n\nCommands can be limited to running only if the previous commands ran successfully thanks to `&&`.\n\n:::{.example}\n\nExample:\n\n:::\n\nLook at the following commands:\n\n```{.bash}\nunzip bash.zip\nrm bash.zip\n```\n\nThis is equivalent to:\n\n```{.bash}\nunzip bash.zip;\nrm bash.zip\n```\n\nand to:\n\n```{.bash}\nunzip bash.zip; rm bash.zip\n```\n\nThis is what we did to get the data for the past few sessions.\n\nIn both cases, both commands will try to run. Now, if for some reason, the unzipping fails, we have deleted the zip file and we have to re-download it. Not a big deal here, but in some situations, executing a command if the one before fails can be a real bummer.\n\nTo prevent this, we can use the double-ampersand (`&&`) operator, which plays the role of a logical AND statement:\n\n```{.bash}\nunzip bash.zip &&\nrm bash.zip\n```\n\nThis is equivalent to:\n\n```{.bash}\nunzip bash.zip && rm bash.zip\n```\n\nIf the unzipping works (if it returns a zero [exit status](https://en.wikipedia.org/wiki/Exit_status)), then the Zip file gets deleted. If however, the unzipping fails (if it returns a non-zero exit status), the script aborts and we haven't lost our Zip file.\n\n## Next command conditional on failure\n\nThe opposite of `&&` is `||` which plays the role of a logical OR statement: the following command only gets executed if the first one fails.\n\nExample:\n\n```{.bash}\n[ -e file ] || echo File does not exist\n```\n\n## Conditional executions\n\nSections of scripts can be executed (or not) based on conditions thanks to *if statements*.\n\n### Syntax\n\n```{.bash}\nif [ predicate1 ]\nthen\n\tcommand1\n\tcommand2\n\t...\nelif [ predicate2 ]\nthen\n\tcommand3\n\tcommand4\n\t...\nelse\n\tcommand5\n\tcommand6\n\t...\nfi\n```\n\n### Example\n\nLet's create a file called `check.sh` with the following if statement:\n\n```{.bash}\nfor f in $@\ndo\n    if [ -e $f ]      # Make sure to have spaces around each bracket\n    then\n        echo $f exists\n    else\n        echo $f does not exist\n    fi\ndone\n```\n\nNow, let's make it executable:\n\n```{.bash}\nchmod u+x check.sh\n```\n\nAnd let's run this:\n\n```{.bash}\n./check.sh file1 file2 check.sh file3\n```\n\n### Predicates\n\nHere are a few predicates:\n\n`[ $var == 'text' ]` checks whether `var` is equal to `'text'`.\n\n`[ $var == number ]` checks whether `var` is equal to `number`.\n\n`[ -e file ]` checks whether `file` exists.\n\n`[ -d name ]` checks whether `name` is a directory.\n\n`[ -f name ]` checks whether `name` is a file.\n\n## Conditionally repeated executions\n\nSections of scripts can be repeated as long as a condition returns `True` thanks to *while loops*.\n\n### Syntax\n\nThe syntax of a while loop in Bash is:\n\n```{.bash}\nwhile predicate\ndo\n\tcommand1\n\tcommand2\n\t...\ndone\n```\n\nThe set of commands in the body of the while loop are executed as long as the predicate returns true.\n\nBe careful that while loop can lead to infinite loops. Such loops need to be manually interrupted (by pressing `<Ctrl+C>`).\n\n:::{.example}\n\nExample of infinite loop:\n\n:::\n\n```{.bash}\nwhile true\ndo\n    echo \"Press <Ctrl+C> to stop\"\n\tsleep 1\ndone\n```\n\n*[Here](https://youtu.be/cCunoOIksAE) is a video of a previous version of this workshop.*\n\n## Repeated executions\n\nSections of scripts can be repeated for each element of a list thanks to *for loops*.\n\n### Syntax\n\nThe general structure of a for loop is as follows:\n\n```{.bash}\nfor <iterable> in <list>\ndo\n\t<command1>\n\t<command2>\n\t...\ndone\n```\n\n### Example\n\nThe `molecules` directory contains the following `.pdb` files:\n\n```{.bash}\nls *.pdb\n```\n\n```\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n```\n\nWe want to rename these files by prepending \"gas_\" to their current names.\n\nWildcards don't work here:\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nmv *.pdb gas_*.pdb\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmv: target 'gas_propane.pdb': Not a directory\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\nThe solution is to use a for loop:\n\n```{.bash}\nfor file in *.pdb\ndo\n\tmv $file gas_$file\ndone\n```\n\nThis can also be written as a one-liner, although it is harder to read:\n\n```{.bash}\nfor file in *.pdb; do mv $file gas_$file; done\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nUsing what we learnt in the [string manipulation](https://mint.westdri.ca/bash/variables.html#string-manipulation) section, how could you remove the `gas_` prefix to all these files?\n\n:::\n\n### Collections\n\nFor loops run a set of commands for each item of a collection. How do you create those collections?\n\n#### Listing items one by one\n\nThe least efficient method is to list all the items one by one:\n\n:::{.example}\n\nExample:\n\n:::\n\n```{.bash}\nfor i in file1 file2 file3\ndo\n\techo $i\ndone\n```\n\n```\nfile1\nfile2\nfile3\n```\n\n#### Wildcards\n\nAs we have already seen, wildcards are very useful to build for loops.\n\n#### Brace expansion\n\nCollections can also be created with brace expansion.\n\n:::{.example}\n\nExamples:\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1,2,5}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::{.note}\n\nMake sure not to add a space after the commas.\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {list,of,strings}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist of strings\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {file1,file2}.sh\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1.sh file2.sh\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nls -l {ethane,methane,pentane}.pdb\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nls: cannot access 'ethane.pdb': No such file or directory\nls: cannot access 'methane.pdb': No such file or directory\nls: cannot access 'pentane.pdb': No such file or directory\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1..5}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 3 4 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {01..10}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n01 02 03 04 05 06 07 08 09 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {r..v}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nr s t u v\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {v..r}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nv u t s r\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {a..e}{1..3}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\na1 a2 a3 b1 b2 b3 c1 c2 c3 d1 d2 d3 e1 e2 e3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {a..c}{a..c}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\naa ab ac ba bb bc ca cb cc\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1..5}.txt\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.txt 2.txt 3.txt 4.txt 5.txt\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho file{3..6}.sh\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile3.sh file4.sh file5.sh file6.sh\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\nBrace expansion can be used to create lists iterated over in loops, but also to apply commands to files or directories.\n\n#### Sequences\n\nCollections can also be sequences:\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nseq 1 2 10\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n3\n5\n7\n9\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n:::{.note}\n\nHere, `1` is the start of the sequence, `10` is the end, and `2` is the step.\n\n:::\n\nSuch a sequence could be used in a loop this way:\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor i in $(seq 1 2 10)\ndo\n\techo file$i.txt\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1.txt\nfile3.txt\nfile5.txt\nfile7.txt\nfile9.txt\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n<!-- for ((i=1; i<=5; i++)) do echo $i; done   # can use C-style loops -->\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nIn a directory the command `ls` returns:\n\n```\nfructose.dat  glucose.dat  sucrose.dat  maltose.txt\n```\n\nWhat would be the output of the following loop?\n\n```{.bash}\nfor datafile in *.dat\ndo\n  cat $datafile >> sugar.dat\ndone\n```\n\n1. All of the text from `fructose.dat`, `glucose.dat` and `sucrose.dat` would be concatenated and saved to a file called `sugar.dat`.\n\n2. The text from `sucrose.dat` will be saved to a file called `sugar.dat`.\n\n3. All of the text from `fructose.dat`, `glucose.dat`, `sucrose.dat`, and `maltose.txt` would be concatenated and saved to a file called `sugar.dat`.\n\n4. All of the text from `fructose.dat`, `glucose.dat` and `sucrose.dat` will be printed to the screen and saved into a file called `sugar.dat`.\n\n:::\n\n<!-- Write a loop that concatenates all .pdb files in `data-shell/molecules` subdirectory into one file called `allmolecules.txt`, prepending each fragment with the name of the corresponding .pdb file, and separating different files with an empty line. Run the loop, make sure it works, bring it up with the &nbsp;**↑**&nbsp; key and paste into the chat. -->\n\n<!-- What will the loop `for i in hello 1 2 * bye; do echo $i; done` print? Try answering without running the loop. -->\n\n<!-- Create a loop that writes into 10 files `chapter01.md`, `chapter02.md`, ..., `chapter10.md`. Each file should contain -->\n<!-- chapter-specific lines, e.g. `chapter05.md` will contain exactly these lines: -->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}