{
  "hash": "98ff7fd829980e75cefc913a4fd809db",
  "result": {
    "markdown": "---\ntitle: Searching for files\nauthor:\n  - Marie-Hélène Burle\n  - Alex Razoumov\n---\n\n::: {.cell hash='search_cache/html/unnamed-chunk-1_93c60734e27e245deda19f1179481bab'}\n\n:::\n\n\n:::{.callout-accordion collapse=\"true\"}\n\n## ***Data for this section***\n\nFor this section, we will be using data put together by [The Carpentries](https://carpentries.org/). You can download it by clicking [here](http://bit.ly/bashfile).\n\nThis will download a zip filed called `bfiles.zip`. Unzip it to your home directory. You should now see a `data-shell` directory. In it is a subdirectory called `molecules`.\n\nThis is what we will use for now, so `cd` into it:\n\n```{.bash}\ncd data-shell/molecules\n```\n\n:::\n\n## Command `find`\n\nSearch for files inside the current working directory:\n\n```{.bash}\nfind . -type f\n```\n\n```\n./methane.pdb\n./pentane.pdb\n./sorted.txt\n./propane.pdb\n./lengths.txt\n./cubane.pdb\n./ethane.pdb\n./octane.pdb\n```\n\n`find . -type d` will instead search for directories inside the current working directory.\n\n```{.bash}\nfind . -maxdepth 1 -type f     # depth 1 is the current directory\nfind . -mindepth 2 -type f     # current directory and one level down\nfind . -name haiku.txt      # finds specific file\nls data       # shows one.txt two.txt\nfind . -name *.txt      # still finds one file -- why? answer: expands *.txt to haiku.txt\nfind . -name '*.txt'    # finds all three files -- good!\n```\n\nLet's wrap the last command into `$()`—called *command substitution*—as if it were a variable:\n\n```{.bash}\necho $(find . -name '*.txt')   # will print ./data/one.txt ./data/two.txt ./haiku.txt\nls -l $(find . -name '*.txt')   # will expand to ls -l ./data/one.txt ./data/two.txt ./haiku.txt\nwc -l $(find . -name '*.txt')   # will expand to wc -l ./data/one.txt ./data/two.txt ./haiku.txt\ngrep elegant $(find . -name '*.txt')   # will look for 'elegant' inside all *.txt files\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\n`grep`'s `-v` flag inverts pattern matching, so that only lines that do **not** match the pattern are printed.\n\nGiven that, which of the following commands will find all files in `/data` whose names end in `ose.dat` (e.g. `sucrose.dat` or `maltose.dat`), but do not contain the word `temp`?\n\n1. `find /data -name '*.dat' | grep ose | grep -v temp`\n2. `find /data -name ose.dat | grep -v temp`\n3. `grep -v temp $(find /data -name '*ose.dat')`\n4. None of the above\n\n:::\n\n*[Here](https://youtu.be/AnwsnESj82Q) is a video of a previous version of this workshop.*\n\n## Running a command on the results of `find`\n\nLet's say you want to run a command on each of the files in the output of `find`. You can always do something\nusing command substitution like this:\n\n```{.bash}\nfor f in $(find . -name \"*.txt\")\n  do\n    command on $f\n  done\n```\n\nAlternatively, you can make it a one-liner:\n\n```{.bash}\nfind . -name \"*.txt\" -exec command {} \\;       # important to have spaces\n```\n\nAnother -- perhaps more elegant -- one-line alternative is to use `xargs`. In its simplest usage, `xargs`\ncommand lets you construct a list of arguments:\n\n```{.bash}\nfind . -name \"*.txt\"                   # returns multiple lines\nfind . -name \"*.txt\" | xargs           # use those lines to construct a list\nfind . -name \"*.txt\" | xargs command   # pass this list as arguments to `command`\ncommand $(find . -name \"*.txt\")        # command substitution, achieving the same result (this is riskier!)\ncommand `(find . -name \"*.txt\")`       # alternative syntax for command substitution\n```\n\nIn these examples, `xargs` achieves the same result as command substitution, but it is safer in terms of\nmemory usage and the length of lists you can pass.\n\nWhere would you use this? Well, consider `grep` command that takes a search stream (and not a list of files)\nas its standard input:\n\n```{.bash}\ncat filename | grep pattern\n```\n\nTo pass a list of files to grep, you can use `xargs` that takes that list from its standard input and converts\nit into a list of arguments that is then passed to `grep`:\n\n```{.bash}\nfind . -name \"*.txt\" | xargs grep pattern   # search for `pattern` inside all those files (`grep` does not take a list of files as standard input)\n```\n\n\n{{< question num=\"`recursive search`\" >}}\n\n\nWrite a one-line command that will search for a string in all files in the current directory and all its subdirectories,\nand will hide errors (e.g. due to permissions).\n\n{{< /question >}}\n\n\n{{< question num=\"`command substitution`\" >}}\n\n\nPlay with command substitution using both `$(...)` and ``` `...` ``` syntax.\n\n{{< /question >}}\n\n\n\n*[Here](https://youtu.be/aFrMKkjMIHY) is a video of a previous version of this workshop.*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}