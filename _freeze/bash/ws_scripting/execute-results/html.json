{
  "hash": "32ad26f210c1eb8f7a92b8b93d8fffc0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Automation & scripting in bash for beginners\naliases:\n  - intro_scripting.html\nauthor: Marie-Hélène Burle\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n:::{.def}\n\nThis workshop will demystify the command line and get you started using Bash and Bash scripting.\n\n*Warning: you might find that working in the command line is actually really fun and addictive!*\n\n:::\n\n## Background\n\n### What are Unix shells?\n\nA Unix shell is a command line interpreter: the user enters commands as text, either interactively in the command line or in a script, and the shell passes them to the operating system.\n\n#### Bash\n\nBash (<em>Bourne Again SHell</em>), released in 1989, is part of the GNU Project and is the default Unix shell on many systems (MacOS recently changed its default to zsh).\n\n#### Other shells\n\nPrior to Bash, the default was the Bourne shell (sh).\n\nA new and popular shell (backward compatible with Bash) is zsh. It extends Bash's capabilities.\n\nAnother shell in the same family is the KornShell (ksh).\n\nAll these shells are quite similar. The C shell (csh) however was modeled on the C programming language.\n\nBash is the most common shell and the one which makes the most sense to learn as a first Unix shell.\n\n### Why use a shell?\n\nWhile automating GUI operations is really difficult, it is easy to rerun a script (a file with a number of commands). Unix shells thus allow the creation of reproducible workflows and the automation of repetitive tasks.\n\nThey are powerful to launch tools, modify files, search text, or combine commands.\n\nThey also allow to work on remote machines and HPC systems.\n\n## How we will use Bash today\n\nBash is a Unix shell. You thus need a Unix or Unix-like operating system.\n\nWe will connect to a remote HPC system via SSH (secure shell). HPC systems always run Linux.\n\nThose on Linux or MacOS can alternatively use Bash directly on their machine. On MacOS, the default is now zsh (you can see that by typing `echo $SHELL` in Terminal), but zsh is fully compatible with Bash commands, so it is totally fine to use it instead. If you really want to use Bash, simply launch it by typing in Terminal: `bash`.\n\n### Connecting to a remote HPC system via SSH\n\n#### Usernames and password\n\nWe will give you a link to an etherpad during the workshop. Add your name next to a free username to claim it.\n\nWe will also give you the password for our training cluster. When prompted, enter it.\n\n:::{.note}\n\nNote that you will not see any character as you type the password: this is called blind typing and is a Linux safety feature. Type slowly and make sure not to make typos. It can be unsettling at first not to get any feed-back while typing.\n\n:::\n\n#### Linux and MacOS users\n\nLinux users: open the terminal emulator of your choice.\\\nMacOS users: open \"Terminal\".\n\nThen type:\n\n```{.bash}\nssh userxx@bashworkshop.c3.ca  # Replace userxx by your username (e.g. user09)\n```\n\n#### Windows users\n\nWe suggest using [the free version of MobaXterm.](https://mobaxterm.mobatek.net/download.html)\n\nMobaXterm comes with a terminal emulator and a GUI interface for SSH sessions.\n\nOpen MobaXterm, click on \"Session\", then \"SSH\", and fill in the Remote host name and your username. [Here](https://mobaxterm.mobatek.net/demo.html) is a live demo.\n\n## Bash: the basics\n\n### The prompt\n\nIn command-line interfaces, a command prompt is a sequence of characters indicating that the interpreter is ready to accept input. It can also provide some information (e.g. time, error types, username and hostname, etc.)\n\nThe Bash prompt is customizable. By default, it often gives the username and the hostname, and it typically ends with `$`.\n\n### Help on commands\n\nMan pages:\n\n```{.bash}\nman <command>\n```\n\n:::{.note}\n\nMan pages open in a pager (usually `less`).\\\nNavigate up/down with the space bar and the `b` key.\\\nQuit the pager with the `q` key.\n\n:::\n\nHelp pages:\n\n```{.bash}\n<command> --help\n```\n\nInspect commands:\n\n```{.bash}\ncommand -V <command>\n```\n\n### Examples of commands\n\n- Print working directory: `pwd`\n- Change directory: `cd`\n- Print: `echo`\n- Print content of a file: `cat`\n- List: `ls`\n- Copy: `cp`\n- Move or rename: `mv`\n- Create a new directory: `mkdir`\n- Create a new file: `touch`\n\n### Keybindings\n\nClear the terminal (command `clear`) with C-l (this means: press the Ctrl and L keys at the same time).\n\nNavigate command history with C-p and C-n (or up and down arrows).\n\nYou can auto-complete commands by pressing the tab key.\n\n## Bash scripting: the basics\n\nInstead of typing commands one at a time directly in a terminal, you can write them down, one per line, in a text file called a script.\n\nThey will be run in the order in which they are written when you execute the script.\n\nThis is a great way to automate tasks: to rerun this sequence of commands, you simply have to rerun the script.\n\n### File name\n\nShell scripts, including Bash scripts, are usually given the extension `sh` (e.g. `my_script.sh`).\n\nYou can store scripts anywhere, but a common practice is to store them in a `~/bin` directory.\n\n### Syntax\n\n#### Shebang\n\nScripts can be written for any interpreter (e.g. Bash, Python, R, etc.) The way to tell the system which one to use is to use a shebang (`#!`) followed by the path of the interpreter on the first line of the script.\n\nTo use Bash, start your scripts with:\n\n```{.bash}\n#!/bin/bash\n```\n\nYou may also encounter this notation:\n\n```{.bash}\n#!/usr/bin/env bash\n```\n\nIf you are curious, you can read the answers to [this Stack Overflow question](https://stackoverflow.com/q/16365130/9210961) for the differences between the two.\n\n#### Comments\n\nAnything to the left of `#` is ignored by the interpreter and is for human consumption only.\n\n```{.bash}\n# You can write full-line comments\n\npwd\t\t  # You can also write comments after commands\n```\n\n### Executing scripts\n\nThere are two ways to execute a script:\n\n```{.bash}\nbash my_script.sh\n```\n\n```{.bash}\n./my_script.sh\t# The dot represents the current directory\n```\n\nIn the latter case, you need to make sure that your script is executable by first running:\n\n```{.bash}\nchmod u+x my_script.sh\t# This makes the script executable by the user (i.e. you)\n```\n\n### Our first script\n\nOpen a text editor (e.g. nano) and type:\n\n```{.bash}\n#!/bin/bash\n\necho \"This is our first script.\"\n```\n\nSave and close the file.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nNow run the script with one, then the other method. \\\nWhat does this script do?\n\n:::\n\n## Variables\n\n### Declaring variables\n\nYou can declare a variable (i.e. a name that holds a value) with the `=` sign.\n\n[!! Make sure not to put spaces around the equal sign.]{.emph}\n\n```{.bash}\nvariable=Test\n```\n\n### Quotes\n\nLet's experiment with quotes:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=This string is the value of the variable\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbash: line 1: string: command not found\n```\n\n\n:::\n:::\n\n\n\n\nOops...\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=\"This string is the value of the variable\"\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis string is the value of the variable\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable='This string is the value of the variable'\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis string is the value of the variable\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable='This string's the value of the variable'\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbash: -c: line 1: unexpected EOF while looking for matching `''\n```\n\n\n:::\n:::\n\n\n\n\nOops...\n\nOne solution to this is to use double quotes:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=\"This string's the value of the variable\"\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis string's the value of the variable\n```\n\n\n:::\n:::\n\n\n\n\nAlternatively, single quotes can be escaped:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable='This string'\"'\"'s the value of the variable'\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThis string's the value of the variable\n```\n\n\n:::\n:::\n\n\n\n\n:::{.note}\n\nAdmittedly, this last one is a little crazy. It is the way to escape single quotes in single-quoted strings.\n\nThe first `'` ends the first string, both `\"` create a double-quoted string with `'` (escaped) in it, then the last `'` starts the second string.\n\nEscaping double quotes is a lot easier and simply requires `\\\"`.\n\n:::\n\n### Expanding a variable's value\n\nTo expand a variable (to access its value), you need to prepend its name with `$`:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=Test\necho variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nvariable\n```\n\n\n:::\n:::\n\n\n\n\nMmmm... not really want we want!\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=Test\necho $variable\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=Test; echo \"$variable\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest\n```\n\n\n:::\n:::\n\n\n\n\n[!! Single quotes don't expand variables.]{.emph}\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nvariable=Test; echo '$variable'\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$variable\n```\n\n\n:::\n:::\n\n\n\n\n### Passing variables to a Bash script\n\nCreate a script called `name.sh` with the following content:\n\n```{.bash}\n#!/bin/bash\n\necho \"My name is $1.\"  # $1 refers to the first variable passed to the script\n```\n\nYou can now pass a variable to this script with:\n\n```{.bash}\nbash name.sh Marie\n```\n\n```\nMy name is Marie.\n```\n\nYou can pass several variables to a script. Copy `name.sh` to `name2.sh` and edit `name2.sh` to look like the following:\n\n```{.bash}\n#!/bin/bash\n\necho \"My name is $1 and I am $2 years old.\"\n```\n\n```{.bash}\nbash name2.sh Marie 43\n```\n\n```\nMy name is Marie and I am 43 years old.\n```\n\nYou can also pass any number of variables to a script:\n\n```{.bash}\n#!/bin/bash\n\necho $@\n```\n\n```{.bash}\nbash script.sh argument1 argument2 argument3 argument4\n```\n\n```\nargument1 argument2 argument3 argument4\n```\n\n### Brace expansion\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1..5}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 3 4 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {01..10}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n01 02 03 04 05 06 07 08 09 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {1..5}.txt\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.txt 2.txt 3.txt 4.txt 5.txt\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {r..v}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nr s t u v\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {file1,file2}.sh\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfile1.sh file2.sh\n```\n\n\n:::\n:::\n\n\n\n\n[!! Make sure not to add a space after the comma.]{.emph}\n\n```{.bash}\ntouch {file1,file2}.sh\n```\n\n```{.bash}\ntouch file{3..6}.sh\n```\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho {list,of,strings}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist of strings\n```\n\n\n:::\n:::\n\n\n\n\n### Wildcards\n\nWildcards are really powerful to apply a command to all the elements having a common pattern.\n\nFor instance, we can delete all the files we created earlier (`file1.sh`, `file2.sh`, etc.) with a single command:\n\n```{.bash}\nrm file*.sh\n```\n\n[!! Be very careful that `rm` is irreversible. Deleted files do not go to the trash: they are gone.]{.emph}\n\n## Loops\n\nTo apply a set of commands to all the elements of a list, you can use for loops. The general structure is as follows:\n\n```{.bash}\nfor <iterable> in <list>\ndo\n\t<statement1>\n\t<statement2>\n\t...\ndone\n```\n\nLet's create the script `names.sh`:\n\n```{.bash}\n#!/bin/bash\n\nfor name in $@\ndo\n\techo $name\ndone\n```\n\nNow let's run it with a list of arguments:\n\n```{.bash}\nbash names.sh Patrick Paul Marie Alex\n```\n\n```\nPatrick\nPaul\nMarie\nAlex\n```\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nCompare the outputs of the following 2 scripts:\n\n- script1.sh:\n\n```{.bash}\n#!/bin/bash\n\necho $@\n```\n\n- script2.sh:\n\n```{.bash}\n#!/bin/bash\n\nfor i in $@\ndo\n\techo $i\ndone\n```\n\nHow do you explain the difference between running:\n\n```{.bash}\nbash script1.sh arg1 arg2 arg3\n```\n\nand running:\n\n```{.bash}\nbash script2.sh arg1 arg2 arg3\n```\n\n:::\n\n## Let's put it all together to automate some task\n\nThis is a rather silly example, but bear with me and let's imagine that it actually makes sense (of course, you don't write that many thesis chapters so you would probably never automate these tasks...)\n\nSo... let's imagine that each time you write a thesis chapter, you do the same things:\n\n- you create a directory with the name of the chapter,\n- you create a number of subdirectories (for your source code, your manuscript, your data, and your results),\n- you create a Python script in the source code directory,\n- you create a markdown document in your manuscript directory,\n- you put the whole thing under version control with Git,\n- you create a `.gitignore` file in which you put the data subdirectory.\n\n:::{.exo}\n\n:::{.yourturn}\n\nYour turn:\n\n:::\n\nWrite a script that would do all this, then test the script.\n\nGive it a try on your own before looking at the solution below...\n\n:::\n\n:::{.callout-warning collapse=\"true\"}\n\n## Solution\n\nHere is what the script looks like (let's call it `chapter.sh`):\n\n```{.bash}\n#!/bin/bash\n\nmkdir $1\ncd $1\nmkdir src data results ms\ntouch src/$1.py ms/$1.md\ngit init\necho data/ > .gitignore\n```\n\nYou then run the script:\n\n```{.bash}\nbash chapter.sh chapter1\n```\n\nYou can verify that all the files and directories got created with:\n\n```{.bash}\ntree chapter1\n```\n\n```\nchapter1/\n├── data\n├── ms\n│   └── chapter1.md\n├── results\n└── src\n    └── chapter1.py\n```\n\nand:\n\n```{.bash}\nls -aF chapter1\n```\n\n```\n./  ../  data/  .git/  .gitignore  ms/  results/  src/\n```\n\nYou can also verify the content of your `.gitignore` file with:\n\n```{.bash}\ncat chapter1/.gitignore\n```\n\n```\ndata/\n```\n\n:::\n\n## Resources\n\nOne very useful (although very dense) resource is the [Bash manual.](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)\n\nYou can also get information on Bash from within Bash with:\n\n```{.bash}\ninfo bash\n```\n\nand:\n\n```{.bash}\nman bash\n```\n\nThere are also countless resources online and don't forget to Google anything you don't know how to do: you will almost certainly find the answer on [StackOverflow](https://stackoverflow.com/) or some Stack Exchange site.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}