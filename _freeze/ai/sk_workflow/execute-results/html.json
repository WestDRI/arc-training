{
  "hash": "3cc1b5ca3747fb7a53e3f5cfd09a46ae",
  "result": {
    "markdown": "---\ntitle: Sklearn workflow\nauthor: Marie-Hélène Burle\n---\n\n:::{.def}\n\nScikit-learn has a very clean and consistent API, making it very easy to use: a similar workflow can be applied to most techniques. Let's go over two examples.\n\n*This code was modified from [Matthew Greenberg](https://science.ucalgary.ca/mathematics-statistics/contacts/matthew-greenberg).*\n\n:::\n\n## Load packages\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom sklearn.datasets import fetch_california_housing, load_breast_cancer\nfrom sklearn.linear_model import LinearRegression, LogisticRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import mean_squared_error, mean_absolute_percentage_error, accuracy_score\n\nimport pandas as pd\n\nimport matplotlib\nfrom matplotlib import pyplot as plt\n\nimport numpy as np\n\nfrom collections import Counter\n```\n\n::: {.cell-output .cell-output-error}\n```\nModuleNotFoundError: No module named 'sklearn'\n```\n:::\n:::\n\n\n## Example 1: California housing dataset\n\n### Load and explore the data\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ncal_housing = fetch_california_housing()\ntype(cal_housing)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'fetch_california_housing' is not defined\n```\n:::\n:::\n\n\nLet's look at the attributes of `cal_housing`:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndir(cal_housing)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ncal_housing.feature_names\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(cal_housing.DESCR)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nX = cal_housing.data\ny = cal_housing.target\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nThis can also be obtained with `X, y = fetch_california_housing(return_X_y=True)`.\n\n:::\n\nLet's have a look at the shape of `X` and `y`:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nX.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'X' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ny.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'y' is not defined\n```\n:::\n:::\n\n\nWhile not at all necessary, we can turn this bunch object into a more familiar data frame to explore the data further:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ncal_housing_df = pd.DataFrame(cal_housing.data, columns=cal_housing.feature_names)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'pd' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ncal_housing_df.head()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing_df' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ncal_housing_df.tail()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing_df' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ncal_housing_df.info()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing_df' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ncal_housing_df.describe() \n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'cal_housing_df' is not defined\n```\n:::\n:::\n\n\nWe can even plot it:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nplt.hist(y)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'plt' is not defined\n```\n:::\n:::\n\n\n### Create and fit a model\n\nLet's start with a very simple model: linear regression.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nmodel = LinearRegression().fit(X, y)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'LinearRegression' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nThis is equivalent to:\n\n```{.python}\nmodel = LinearRegression()\nmodel.fit(X, y)\n```\n\nFirst, we create an instance of the class `LinearRegression`, then we call `.fit()` on it to fit the model.\n\n:::\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nmodel.coef_\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nTrailing underscores indicate that an attribute is estimated. `.coef_` here is an estimated value.\n\n:::\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nmodel.coef_.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nmodel.intercept_\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\nWe can now get our predictions:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ny_hat = model.predict(X)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\nAnd calculate some measures of error:\n\n- Sum of squared errors\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nnp.sum((y - y_hat) ** 2)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n- Mean squared error\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nmean_squared_error(y, y_hat)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'mean_squared_error' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nMSE could also be calculated with `np.mean((y - y_hat)**2)`.\n\n:::\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nmean_absolute_percentage_error(y, y_hat)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'mean_absolute_percentage_error' is not defined\n```\n:::\n:::\n\n\nIndex of minimum value:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nmodel.coef_.argmin()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\nIndex of maximum value:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nmodel.coef_.argmax()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nXX = np.concatenate([np.ones((len(X), 1)), X], axis=1)\n\nbeta = np.linalg.lstsq(XX, y, rcond=None)[0]\nintercept_, *coef_ = beta\n\nintercept_, model.intercept_\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nnp.allclose(coef_, model.coef_)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nThis means that the two arrays are equal element-wise, within a certain tolerance.\n\n:::\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nX_test = np.random.normal(size=(10, X.shape[1]))\nX_test.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ny_test = X_test @ coef_ + intercept_\ny_test\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'X_test' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nmodel.predict(X_test)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\nOf course, instead of `LinearRegression()`, we could have used another model such as a random forest regressor (a meta estimator that fits a number of classifying decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting) for instance:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nmodel = RandomForestRegressor().fit(X, y).predict(X_test)\nmodel\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'RandomForestRegressor' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nWhich is equivalent to:\n\n```{.python}\nmodel = RandomForestRegressor()\nmodel.fit(X, y).predict(X_test)\n```\n\n:::\n\n## Example 2: breast cancer\n\n### Load and explore the data\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nb_cancer = load_breast_cancer()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'load_breast_cancer' is not defined\n```\n:::\n:::\n\n\nLet's print the description of this dataset:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nprint(b_cancer.DESCR)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'b_cancer' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nb_cancer.feature_names\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'b_cancer' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nb_cancer.target_names\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'b_cancer' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nX = b_cancer.data\ny = b_cancer.target\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'b_cancer' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nHere again, we could have used instead `X, y = load_breast_cancer(return_X_y=True)`.\n\n:::\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nX.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'X' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ny.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'y' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nset(y)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'y' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nCounter(y)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'Counter' is not defined\n```\n:::\n:::\n\n\n### Create and fit a first model\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nmodel = LogisticRegression(max_iter=10000)\ny_hat = model.fit(X, y).predict(X)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'LogisticRegression' is not defined\n```\n:::\n:::\n\n\nGet some measure of accuracy:\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\naccuracy_score(y, y_hat)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'accuracy_score' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\nThis can also be obtained with:\n\n```{.python}\nnp.mean(y_hat == y)\n```\n\n:::\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndef sigmoid(x):\n  return 1/(1 + np.exp(-x))\n\nx = np.linspace(-10, 10, 100)\nplt.plot(x, sigmoid(x), lw=3)\nplt.title(\"The Sigmoid Function $\\\\sigma(x)$\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ny_pred = 1*(sigmoid(X @ model.coef_.squeeze() + model.intercept_) > 0.5)\nassert np.all(y_pred == model.predict(X))\n\nnp.allclose(\n    model.predict_proba(X)[:, 1],\n    sigmoid(X @ model.coef_.squeeze() + model.intercept_)\n)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'X' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\ndef make_spirals(k=20, s=1.0, n=2000):\n    X = np.zeros((n, 2))\n    y = np.round(np.random.uniform(size=n)).astype(int)\n    r = np.random.uniform(size=n)*k*np.pi\n    rr = r**0.5\n    theta = rr + np.random.normal(loc=0, scale=s, size=n)\n    theta[y == 1] = theta[y == 1] + np.pi\n    X[:,0] = rr*np.cos(theta)\n    X[:,1] = rr*np.sin(theta)\n    return X, y\n\nX, y = make_spirals()\ncmap = matplotlib.colormaps[\"viridis\"]\n\na = cmap(0)\na = [*a[:3], 0.3]\nb = cmap(0.99)\nb = [*b[:3], 0.3]\n\nplt.figure(figsize=(7,7))\nax = plt.gca()\nax.set_aspect(\"equal\")\nax.plot(X[y == 0, 0], X[y == 0, 1], 'o', color=a, ms=8, label=\"$y=0$\")\nax.plot(X[y == 1, 0], X[y == 1, 1], 'o', color=b, ms=8, label=\"$y=1$\")\nplt.title(\"Spirals\")\nplt.legend()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n### Create and fit a second model\n\nHere, we use a logistic regression:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nmodel = LogisticRegression()\ny_hat = model.fit(X, y).predict(X)\naccuracy_score(y, y_hat)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'LogisticRegression' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nu = np.linspace(-8, 8, 100)\nv = np.linspace(-8, 8, 100)\nU, V = np.meshgrid(u, v)\nUV = np.array([U.ravel(), V.ravel()]).T\nU.shape, V.shape, UV.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n:::{.note}\n\n`np.ravel` returns a contiguous flattened array.\n\n:::\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nW = model.predict(UV).reshape(U.shape)\nW.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\nplt.pcolormesh(U, V, W)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'plt' is not defined\n```\n:::\n:::\n\n\n### Create and fit a third model\n\nLet's use a k-nearest neighbours classifier this time:\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\nmodel = KNeighborsClassifier(n_neighbors=5)\ny_hat = model.fit(X, y).predict(X)\naccuracy_score(y, y_hat)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'KNeighborsClassifier' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\nu = np.linspace(-8, 8, 100)\nv = np.linspace(-8, 8, 100)\nU, V = np.meshgrid(u, v)\nUV = np.array([U.ravel(), V.ravel()]).T\nU.shape, V.shape, UV.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'np' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nW = model.predict(UV).reshape(U.shape)\nW.shape\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'model' is not defined\n```\n:::\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nplt.pcolormesh(U, V, W)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'plt' is not defined\n```\n:::\n:::\n\n\nWe can iterate over various values of `k` to see how the accuracy and pseudocolor plot evolve:\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2, 4, figsize=(9.8, 5))\nfig.suptitle(\"Decision Regions\")\n\nu = np.linspace(-8, 8, 100)\nv = np.linspace(-8, 8, 100)\nU, V = np.meshgrid(u, v)\nUV = np.array([U.ravel(), V.ravel()]).T\n\nks = np.arange(1, 16, 2)\n\nfor k, ax in zip(ks, axes.ravel()):\n  model = KNeighborsClassifier(n_neighbors=k)\n  model.fit(X, y)\n  acc = accuracy_score(y, model.predict(X))\n  W = model.predict(UV).reshape(U.shape)\n  ax.imshow(W, origin=\"lower\", cmap=cmap)\n  ax.set_axis_off()\n  ax.set_title(f\"$k$={k}, acc={acc:.2f}\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'plt' is not defined\n```\n:::\n:::\n\n\n",
    "supporting": [
      "sk_workflow_files"
    ],
    "filters": [],
    "includes": {}
  }
}