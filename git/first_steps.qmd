---
title: First steps
author: Marie-Hélène Burle
---

:::{.def}

In this section, we will initialize our first Git repository, learn to explore it, and create a few commits.

:::

## Download mock data

Let's download a mock project with a couple of files:

{{< downloadthis project.zip dname="project" label="Download the data" >}}

Navigate to your Download directory (with `cd`) and unzip the file with:

```{.bash}
unzip project.zip
```

You should now have a `project` directory with a number of subdirectories and files. This is the project we will use today.

Enter the project:

```{.bash}
cd project
```

## Inspecting our project

First, let's have a look at our (very small) mock project.

Let's list the content of `project`:

```{.bash}
ls -F
```

```
data/
ms/
results/
src/
```

There are 4 subdirectories.

```{.bash}
ls -a	  # Show hidden files
```

```
.
..
data
ms
results
src
```

As you can see, there are no hidden files.

```{.bash}
ls -R
```

```
.:
data
ms
results
src

./data:
dataset.csv

./ms:
proposal.md

./results:

./src:
script.py
```

Now we can see the content of each subdirectory.

You probably don't have the `tree` command, so don't worry if this doesn't work on your machine: this is only to show you the same result in a more readable format:

```{.bash}
tree
```

```
.
├── data
│   └── dataset.csv
├── ms
│   └── proposal.md
├── results
└── src
    └── script.py

5 directories, 3 files
```

Let's look at the content of the files:

```{.bash}
cat data/dataset.csv
```

```
var1,var2,var3,
1,2,1,
0,1,0,
3,3,3
```

This is our very exciting data set.

```{.bash}
cat ms/proposal.md
```

```
# Summary

This is the summary for our proposal.

# Funding

Information on funding for the project.

# Methods

Here we have some methods using our Python scripts.

# Expected results

We hope to achieve a lot.

# Conclusion

This is truly a great proposal.
```

And a no less exciting manuscript (the proposal for our project).

```{.bash}
cat src/script.py
```

```
import pandas as pd
from matplotlib import pyplot as plt

df = pd.read_csv('../data/dataset.csv')

df.plot()
plt.savefig('../results/plot.png', dpi=300)
```

And finally, a Python script.

## Initializing a Git repository

*Make sure to be at the root of the project (here, inside the `project` directory) before initializing the repository.*

Now, you can run the command that will turn your `project` directory into a Git repository:

```{.bash}
git init
```

````
Initialized empty Git repository in project/.git/
````

:::{.note}

Git is very verbose: you will often get useful feed-back after running commands.

:::

When you run this command, Git creates a `.git` repository. This is where it will store all its files.

You can see that this repository was created by running:

```{.bash}
ls -a
```

````
.
..
.git
data
ms
results
src
````

:::{.example}

If you run `git init` in the wrong location, you can easily fix this: simply delete the `.git` directory that you created!

:::

:::{.info}

##### **Git commands**

All commands start with `git`.

A typical command is of the form:

```
git <command> [flags] [arguments]
```

:::{.example}

Example of a command we used to configure Git:

:::

```{.bash}
git config --global "Your Name"
```

:::

## Creating commits

You can think of a commit as a snapshot of a particular version of your project.

You should create a new commit whenever you think that your project is at a point to which you might want to go back to.

Let's create a first commit with the state of our chapter 3 before we do any more work to it:

```{.bash}
git add .
git commit -m "Initial commit"
```

To create a commit, we first need to add the file(s) we want to add to our commit to the staging area (also called "index"). This is done with the command `git add`. To add all the files, we can use `git add .` (`.` represents the current directory).

Once we have added some files to the staging area, we can create a commit. But each commit has a message associated to it. One way to add this message is to use the command to create commits (`git commit`) with the `-m` flag (for "message"). Here, our message is simply "Initial commit".

:::{.info}

Git saves the history of a project as a series of snapshots:

![](img/01.png)

Those snapshots are called commits:

![](img/02.png)

Each commit is identified by a unique *hash* and contains these metadata:

- author,
- date and time,
- the hash of parent commit(s),
- a message.

As soon as you create the first commit, a pointer called a *branch* is created and it points to that commit. By default, that first branch is called `main`:

![](img/03.png)

Another pointer (`HEAD`) points to the branch `main`. `HEAD` indicates where we are in the project history.

:::

We can now do some work in our chapter 3. For instance, let's imagine that we are adding a result section to our chapter3.md file.

```{.bash}
echo "
## Results

We now have a bunch of results in our markdown manuscript." >> ms/chapter3.md
```

[Make sure to use `>>` here and not `>`: `>>` prepends content while `>` replaces any existing content.]{.emph}

If this new addition is important enough to justify making a new commit (how often you commit is up to you), we can do so:

```{.bash}
git add ms/chapter3.md
git commit -m "Add result section to manuscript"
```

````
[main 451c47b] Add result section to manuscript
 1 file changed, 4 insertions(+)
````

:::{.info}

As you create more commits, the history of your project grows ...

![](img/04.png)

... and the pointers `HEAD` and `main` automatically move to the last commit:

![](img/05.png)

For simplicity, the diagrams can be simplified this way:

![](img/06.png)

:::

### Advice for great commit messages
<br>
![](https://imgs.xkcd.com/comics/git_commit.png){fig-alt="noshadow"}

:::{.caption}

from [xkcd.com](https://xkcd.com/)

:::

- Use the present tense
- The first line is a summary of the commit and is less than 50 characters long
- Leave a blank line below
- Then add the body of your commit message with more details

:::{.example}

Example of a good commit message:

:::

```{.bash}
git commit -m "Reduce boundary conditions by a factor of 0.3

Update boundaries
Rerun model and update table
Rephrase method section in ms"
```

Future you will thank you! (And so will your collaborators).

## Understanding the staging area

New Git users are often confused about the two-step commit process (first, you stage with `git add`, then you commit with `git commit`). This intermediate step seems, at first, totally unnecessary. In fact, it is very useful: without it, commits would always include all new changes made to a project and they would thus be very messy. The staging area allows to prepare ("stage") the next commit. This way, you only commit what you want when you want.

:::{.example}

Let's go over a simple example:

:::

We don't always work linearly. Maybe you are working on a section of your manuscript when you realize by chance that there is a mistake in your script. You fix that mistake. On your next commit, it might make little sense to commit together that fix and your manuscript changes since they are not related. If your commits are random bag of changes, it will be very hard for future you to navigate your project history.

It is a lot better to only stage your script fix, commit it, then only stage your manuscript update, and commit this in a different commit.

The staging area allows you to pick and chose the changes from one or various files that constitute some coherent change to the project and that make sense to commit together.
